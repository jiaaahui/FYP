
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model building
 * 
 */
export type building = $Result.DefaultSelection<Prisma.$buildingPayload>
/**
 * Model chats
 * 
 */
export type chats = $Result.DefaultSelection<Prisma.$chatsPayload>
/**
 * Model customer
 * 
 */
export type customer = $Result.DefaultSelection<Prisma.$customerPayload>
/**
 * Model employee
 * 
 */
export type employee = $Result.DefaultSelection<Prisma.$employeePayload>
/**
 * Model employeeteamassignment
 * 
 */
export type employeeteamassignment = $Result.DefaultSelection<Prisma.$employeeteamassignmentPayload>
/**
 * Model lorrytrip
 * 
 */
export type lorrytrip = $Result.DefaultSelection<Prisma.$lorrytripPayload>
/**
 * Model orderproduct
 * 
 */
export type orderproduct = $Result.DefaultSelection<Prisma.$orderproductPayload>
/**
 * Model orders
 * 
 */
export type orders = $Result.DefaultSelection<Prisma.$ordersPayload>
/**
 * Model product
 * 
 */
export type product = $Result.DefaultSelection<Prisma.$productPayload>
/**
 * Model team
 * 
 */
export type team = $Result.DefaultSelection<Prisma.$teamPayload>
/**
 * Model timeslot
 * 
 */
export type timeslot = $Result.DefaultSelection<Prisma.$timeslotPayload>
/**
 * Model truck
 * 
 */
export type truck = $Result.DefaultSelection<Prisma.$truckPayload>
/**
 * Model truckzone
 * 
 */
export type truckzone = $Result.DefaultSelection<Prisma.$truckzonePayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model zone
 * 
 */
export type zone = $Result.DefaultSelection<Prisma.$zonePayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Buildings
 * const buildings = await prisma.building.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Buildings
   * const buildings = await prisma.building.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.building`: Exposes CRUD operations for the **building** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Buildings
    * const buildings = await prisma.building.findMany()
    * ```
    */
  get building(): Prisma.buildingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chats`: Exposes CRUD operations for the **chats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chats.findMany()
    * ```
    */
  get chats(): Prisma.chatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.customerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.employeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeteamassignment`: Exposes CRUD operations for the **employeeteamassignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employeeteamassignments
    * const employeeteamassignments = await prisma.employeeteamassignment.findMany()
    * ```
    */
  get employeeteamassignment(): Prisma.employeeteamassignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lorrytrip`: Exposes CRUD operations for the **lorrytrip** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lorrytrips
    * const lorrytrips = await prisma.lorrytrip.findMany()
    * ```
    */
  get lorrytrip(): Prisma.lorrytripDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderproduct`: Exposes CRUD operations for the **orderproduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orderproducts
    * const orderproducts = await prisma.orderproduct.findMany()
    * ```
    */
  get orderproduct(): Prisma.orderproductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): Prisma.ordersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.productDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.teamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeslot`: Exposes CRUD operations for the **timeslot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Timeslots
    * const timeslots = await prisma.timeslot.findMany()
    * ```
    */
  get timeslot(): Prisma.timeslotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.truck`: Exposes CRUD operations for the **truck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trucks
    * const trucks = await prisma.truck.findMany()
    * ```
    */
  get truck(): Prisma.truckDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.truckzone`: Exposes CRUD operations for the **truckzone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Truckzones
    * const truckzones = await prisma.truckzone.findMany()
    * ```
    */
  get truckzone(): Prisma.truckzoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.zoneDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    building: 'building',
    chats: 'chats',
    customer: 'customer',
    employee: 'employee',
    employeeteamassignment: 'employeeteamassignment',
    lorrytrip: 'lorrytrip',
    orderproduct: 'orderproduct',
    orders: 'orders',
    product: 'product',
    team: 'team',
    timeslot: 'timeslot',
    truck: 'truck',
    truckzone: 'truckzone',
    users: 'users',
    zone: 'zone'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "building" | "chats" | "customer" | "employee" | "employeeteamassignment" | "lorrytrip" | "orderproduct" | "orders" | "product" | "team" | "timeslot" | "truck" | "truckzone" | "users" | "zone"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      building: {
        payload: Prisma.$buildingPayload<ExtArgs>
        fields: Prisma.buildingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.buildingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.buildingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>
          }
          findFirst: {
            args: Prisma.buildingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.buildingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>
          }
          findMany: {
            args: Prisma.buildingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>[]
          }
          create: {
            args: Prisma.buildingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>
          }
          createMany: {
            args: Prisma.buildingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.buildingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>[]
          }
          delete: {
            args: Prisma.buildingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>
          }
          update: {
            args: Prisma.buildingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>
          }
          deleteMany: {
            args: Prisma.buildingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.buildingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.buildingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>[]
          }
          upsert: {
            args: Prisma.buildingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$buildingPayload>
          }
          aggregate: {
            args: Prisma.BuildingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuilding>
          }
          groupBy: {
            args: Prisma.buildingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuildingGroupByOutputType>[]
          }
          count: {
            args: Prisma.buildingCountArgs<ExtArgs>
            result: $Utils.Optional<BuildingCountAggregateOutputType> | number
          }
        }
      }
      chats: {
        payload: Prisma.$chatsPayload<ExtArgs>
        fields: Prisma.chatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          findFirst: {
            args: Prisma.chatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          findMany: {
            args: Prisma.chatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>[]
          }
          create: {
            args: Prisma.chatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          createMany: {
            args: Prisma.chatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>[]
          }
          delete: {
            args: Prisma.chatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          update: {
            args: Prisma.chatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          deleteMany: {
            args: Prisma.chatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>[]
          }
          upsert: {
            args: Prisma.chatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          aggregate: {
            args: Prisma.ChatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChats>
          }
          groupBy: {
            args: Prisma.chatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatsCountArgs<ExtArgs>
            result: $Utils.Optional<ChatsCountAggregateOutputType> | number
          }
        }
      }
      customer: {
        payload: Prisma.$customerPayload<ExtArgs>
        fields: Prisma.customerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findFirst: {
            args: Prisma.customerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findMany: {
            args: Prisma.customerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          create: {
            args: Prisma.customerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          createMany: {
            args: Prisma.customerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.customerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          delete: {
            args: Prisma.customerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          update: {
            args: Prisma.customerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          deleteMany: {
            args: Prisma.customerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.customerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          upsert: {
            args: Prisma.customerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.customerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.customerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      employee: {
        payload: Prisma.$employeePayload<ExtArgs>
        fields: Prisma.employeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          findFirst: {
            args: Prisma.employeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          findMany: {
            args: Prisma.employeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>[]
          }
          create: {
            args: Prisma.employeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          createMany: {
            args: Prisma.employeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.employeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>[]
          }
          delete: {
            args: Prisma.employeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          update: {
            args: Prisma.employeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          deleteMany: {
            args: Prisma.employeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.employeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>[]
          }
          upsert: {
            args: Prisma.employeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.employeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.employeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      employeeteamassignment: {
        payload: Prisma.$employeeteamassignmentPayload<ExtArgs>
        fields: Prisma.employeeteamassignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employeeteamassignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeteamassignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employeeteamassignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeteamassignmentPayload>
          }
          findFirst: {
            args: Prisma.employeeteamassignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeteamassignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employeeteamassignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeteamassignmentPayload>
          }
          findMany: {
            args: Prisma.employeeteamassignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeteamassignmentPayload>[]
          }
          create: {
            args: Prisma.employeeteamassignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeteamassignmentPayload>
          }
          createMany: {
            args: Prisma.employeeteamassignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.employeeteamassignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeteamassignmentPayload>[]
          }
          delete: {
            args: Prisma.employeeteamassignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeteamassignmentPayload>
          }
          update: {
            args: Prisma.employeeteamassignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeteamassignmentPayload>
          }
          deleteMany: {
            args: Prisma.employeeteamassignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employeeteamassignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.employeeteamassignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeteamassignmentPayload>[]
          }
          upsert: {
            args: Prisma.employeeteamassignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeeteamassignmentPayload>
          }
          aggregate: {
            args: Prisma.EmployeeteamassignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeteamassignment>
          }
          groupBy: {
            args: Prisma.employeeteamassignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeteamassignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.employeeteamassignmentCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeteamassignmentCountAggregateOutputType> | number
          }
        }
      }
      lorrytrip: {
        payload: Prisma.$lorrytripPayload<ExtArgs>
        fields: Prisma.lorrytripFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lorrytripFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lorrytripPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lorrytripFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lorrytripPayload>
          }
          findFirst: {
            args: Prisma.lorrytripFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lorrytripPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lorrytripFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lorrytripPayload>
          }
          findMany: {
            args: Prisma.lorrytripFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lorrytripPayload>[]
          }
          create: {
            args: Prisma.lorrytripCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lorrytripPayload>
          }
          createMany: {
            args: Prisma.lorrytripCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.lorrytripCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lorrytripPayload>[]
          }
          delete: {
            args: Prisma.lorrytripDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lorrytripPayload>
          }
          update: {
            args: Prisma.lorrytripUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lorrytripPayload>
          }
          deleteMany: {
            args: Prisma.lorrytripDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lorrytripUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.lorrytripUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lorrytripPayload>[]
          }
          upsert: {
            args: Prisma.lorrytripUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lorrytripPayload>
          }
          aggregate: {
            args: Prisma.LorrytripAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLorrytrip>
          }
          groupBy: {
            args: Prisma.lorrytripGroupByArgs<ExtArgs>
            result: $Utils.Optional<LorrytripGroupByOutputType>[]
          }
          count: {
            args: Prisma.lorrytripCountArgs<ExtArgs>
            result: $Utils.Optional<LorrytripCountAggregateOutputType> | number
          }
        }
      }
      orderproduct: {
        payload: Prisma.$orderproductPayload<ExtArgs>
        fields: Prisma.orderproductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.orderproductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderproductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.orderproductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderproductPayload>
          }
          findFirst: {
            args: Prisma.orderproductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderproductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.orderproductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderproductPayload>
          }
          findMany: {
            args: Prisma.orderproductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderproductPayload>[]
          }
          create: {
            args: Prisma.orderproductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderproductPayload>
          }
          createMany: {
            args: Prisma.orderproductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.orderproductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderproductPayload>[]
          }
          delete: {
            args: Prisma.orderproductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderproductPayload>
          }
          update: {
            args: Prisma.orderproductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderproductPayload>
          }
          deleteMany: {
            args: Prisma.orderproductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.orderproductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.orderproductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderproductPayload>[]
          }
          upsert: {
            args: Prisma.orderproductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$orderproductPayload>
          }
          aggregate: {
            args: Prisma.OrderproductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderproduct>
          }
          groupBy: {
            args: Prisma.orderproductGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderproductGroupByOutputType>[]
          }
          count: {
            args: Prisma.orderproductCountArgs<ExtArgs>
            result: $Utils.Optional<OrderproductCountAggregateOutputType> | number
          }
        }
      }
      orders: {
        payload: Prisma.$ordersPayload<ExtArgs>
        fields: Prisma.ordersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ordersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ordersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          findFirst: {
            args: Prisma.ordersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ordersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          findMany: {
            args: Prisma.ordersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>[]
          }
          create: {
            args: Prisma.ordersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          createMany: {
            args: Prisma.ordersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ordersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>[]
          }
          delete: {
            args: Prisma.ordersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          update: {
            args: Prisma.ordersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          deleteMany: {
            args: Prisma.ordersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ordersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ordersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>[]
          }
          upsert: {
            args: Prisma.ordersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ordersPayload>
          }
          aggregate: {
            args: Prisma.OrdersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrders>
          }
          groupBy: {
            args: Prisma.ordersGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ordersCountArgs<ExtArgs>
            result: $Utils.Optional<OrdersCountAggregateOutputType> | number
          }
        }
      }
      product: {
        payload: Prisma.$productPayload<ExtArgs>
        fields: Prisma.productFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findFirst: {
            args: Prisma.productFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findMany: {
            args: Prisma.productFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          create: {
            args: Prisma.productCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          createMany: {
            args: Prisma.productCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.productCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          delete: {
            args: Prisma.productDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          update: {
            args: Prisma.productUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          deleteMany: {
            args: Prisma.productDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.productUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          upsert: {
            args: Prisma.productUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.productGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.productCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      team: {
        payload: Prisma.$teamPayload<ExtArgs>
        fields: Prisma.teamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          findFirst: {
            args: Prisma.teamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          findMany: {
            args: Prisma.teamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>[]
          }
          create: {
            args: Prisma.teamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          createMany: {
            args: Prisma.teamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.teamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>[]
          }
          delete: {
            args: Prisma.teamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          update: {
            args: Prisma.teamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          deleteMany: {
            args: Prisma.teamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.teamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>[]
          }
          upsert: {
            args: Prisma.teamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.teamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.teamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      timeslot: {
        payload: Prisma.$timeslotPayload<ExtArgs>
        fields: Prisma.timeslotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.timeslotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeslotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.timeslotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeslotPayload>
          }
          findFirst: {
            args: Prisma.timeslotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeslotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.timeslotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeslotPayload>
          }
          findMany: {
            args: Prisma.timeslotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeslotPayload>[]
          }
          create: {
            args: Prisma.timeslotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeslotPayload>
          }
          createMany: {
            args: Prisma.timeslotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.timeslotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeslotPayload>[]
          }
          delete: {
            args: Prisma.timeslotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeslotPayload>
          }
          update: {
            args: Prisma.timeslotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeslotPayload>
          }
          deleteMany: {
            args: Prisma.timeslotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.timeslotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.timeslotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeslotPayload>[]
          }
          upsert: {
            args: Prisma.timeslotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$timeslotPayload>
          }
          aggregate: {
            args: Prisma.TimeslotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeslot>
          }
          groupBy: {
            args: Prisma.timeslotGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeslotGroupByOutputType>[]
          }
          count: {
            args: Prisma.timeslotCountArgs<ExtArgs>
            result: $Utils.Optional<TimeslotCountAggregateOutputType> | number
          }
        }
      }
      truck: {
        payload: Prisma.$truckPayload<ExtArgs>
        fields: Prisma.truckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.truckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.truckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckPayload>
          }
          findFirst: {
            args: Prisma.truckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.truckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckPayload>
          }
          findMany: {
            args: Prisma.truckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckPayload>[]
          }
          create: {
            args: Prisma.truckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckPayload>
          }
          createMany: {
            args: Prisma.truckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.truckCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckPayload>[]
          }
          delete: {
            args: Prisma.truckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckPayload>
          }
          update: {
            args: Prisma.truckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckPayload>
          }
          deleteMany: {
            args: Prisma.truckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.truckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.truckUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckPayload>[]
          }
          upsert: {
            args: Prisma.truckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckPayload>
          }
          aggregate: {
            args: Prisma.TruckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTruck>
          }
          groupBy: {
            args: Prisma.truckGroupByArgs<ExtArgs>
            result: $Utils.Optional<TruckGroupByOutputType>[]
          }
          count: {
            args: Prisma.truckCountArgs<ExtArgs>
            result: $Utils.Optional<TruckCountAggregateOutputType> | number
          }
        }
      }
      truckzone: {
        payload: Prisma.$truckzonePayload<ExtArgs>
        fields: Prisma.truckzoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.truckzoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckzonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.truckzoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckzonePayload>
          }
          findFirst: {
            args: Prisma.truckzoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckzonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.truckzoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckzonePayload>
          }
          findMany: {
            args: Prisma.truckzoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckzonePayload>[]
          }
          create: {
            args: Prisma.truckzoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckzonePayload>
          }
          createMany: {
            args: Prisma.truckzoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.truckzoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckzonePayload>[]
          }
          delete: {
            args: Prisma.truckzoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckzonePayload>
          }
          update: {
            args: Prisma.truckzoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckzonePayload>
          }
          deleteMany: {
            args: Prisma.truckzoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.truckzoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.truckzoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckzonePayload>[]
          }
          upsert: {
            args: Prisma.truckzoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$truckzonePayload>
          }
          aggregate: {
            args: Prisma.TruckzoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTruckzone>
          }
          groupBy: {
            args: Prisma.truckzoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<TruckzoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.truckzoneCountArgs<ExtArgs>
            result: $Utils.Optional<TruckzoneCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      zone: {
        payload: Prisma.$zonePayload<ExtArgs>
        fields: Prisma.zoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.zoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.zoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          findFirst: {
            args: Prisma.zoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.zoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          findMany: {
            args: Prisma.zoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>[]
          }
          create: {
            args: Prisma.zoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          createMany: {
            args: Prisma.zoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.zoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>[]
          }
          delete: {
            args: Prisma.zoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          update: {
            args: Prisma.zoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          deleteMany: {
            args: Prisma.zoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.zoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.zoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>[]
          }
          upsert: {
            args: Prisma.zoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$zonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.zoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.zoneCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    building?: buildingOmit
    chats?: chatsOmit
    customer?: customerOmit
    employee?: employeeOmit
    employeeteamassignment?: employeeteamassignmentOmit
    lorrytrip?: lorrytripOmit
    orderproduct?: orderproductOmit
    orders?: ordersOmit
    product?: productOmit
    team?: teamOmit
    timeslot?: timeslotOmit
    truck?: truckOmit
    truckzone?: truckzoneOmit
    users?: usersOmit
    zone?: zoneOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BuildingCountOutputType
   */

  export type BuildingCountOutputType = {
    orders: number
  }

  export type BuildingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | BuildingCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCountOutputType
     */
    select?: BuildingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    orders: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | CustomerCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    employeeteamassignment: number
    orders: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeteamassignment?: boolean | EmployeeCountOutputTypeCountEmployeeteamassignmentArgs
    orders?: boolean | EmployeeCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountEmployeeteamassignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeteamassignmentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
  }


  /**
   * Count Type LorrytripCountOutputType
   */

  export type LorrytripCountOutputType = {
    timeslot: number
  }

  export type LorrytripCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    timeslot?: boolean | LorrytripCountOutputTypeCountTimeslotArgs
  }

  // Custom InputTypes
  /**
   * LorrytripCountOutputType without action
   */
  export type LorrytripCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LorrytripCountOutputType
     */
    select?: LorrytripCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LorrytripCountOutputType without action
   */
  export type LorrytripCountOutputTypeCountTimeslotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: timeslotWhereInput
  }


  /**
   * Count Type OrdersCountOutputType
   */

  export type OrdersCountOutputType = {
    orderproduct: number
  }

  export type OrdersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderproduct?: boolean | OrdersCountOutputTypeCountOrderproductArgs
  }

  // Custom InputTypes
  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersCountOutputType
     */
    select?: OrdersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountOrderproductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderproductWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    orderproduct: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderproduct?: boolean | ProductCountOutputTypeCountOrderproductArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderproductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderproductWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    employeeteamassignment: number
    lorrytrip_lorrytrip_deliveryteamidToteam: number
    lorrytrip_lorrytrip_warehouseteamidToteam: number
    orders: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeteamassignment?: boolean | TeamCountOutputTypeCountEmployeeteamassignmentArgs
    lorrytrip_lorrytrip_deliveryteamidToteam?: boolean | TeamCountOutputTypeCountLorrytrip_lorrytrip_deliveryteamidToteamArgs
    lorrytrip_lorrytrip_warehouseteamidToteam?: boolean | TeamCountOutputTypeCountLorrytrip_lorrytrip_warehouseteamidToteamArgs
    orders?: boolean | TeamCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountEmployeeteamassignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeteamassignmentWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountLorrytrip_lorrytrip_deliveryteamidToteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lorrytripWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountLorrytrip_lorrytrip_warehouseteamidToteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lorrytripWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
  }


  /**
   * Count Type TimeslotCountOutputType
   */

  export type TimeslotCountOutputType = {
    orders: number
  }

  export type TimeslotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | TimeslotCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * TimeslotCountOutputType without action
   */
  export type TimeslotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeslotCountOutputType
     */
    select?: TimeslotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TimeslotCountOutputType without action
   */
  export type TimeslotCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
  }


  /**
   * Count Type TruckCountOutputType
   */

  export type TruckCountOutputType = {
    lorrytrip: number
    truckzone: number
  }

  export type TruckCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lorrytrip?: boolean | TruckCountOutputTypeCountLorrytripArgs
    truckzone?: boolean | TruckCountOutputTypeCountTruckzoneArgs
  }

  // Custom InputTypes
  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckCountOutputType
     */
    select?: TruckCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeCountLorrytripArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lorrytripWhereInput
  }

  /**
   * TruckCountOutputType without action
   */
  export type TruckCountOutputTypeCountTruckzoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: truckzoneWhereInput
  }


  /**
   * Count Type ZoneCountOutputType
   */

  export type ZoneCountOutputType = {
    building: number
    truckzone: number
  }

  export type ZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    building?: boolean | ZoneCountOutputTypeCountBuildingArgs
    truckzone?: boolean | ZoneCountOutputTypeCountTruckzoneArgs
  }

  // Custom InputTypes
  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneCountOutputType
     */
    select?: ZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountBuildingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: buildingWhereInput
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountTruckzoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: truckzoneWhereInput
  }


  /**
   * Models
   */

  /**
   * Model building
   */

  export type AggregateBuilding = {
    _count: BuildingCountAggregateOutputType | null
    _avg: BuildingAvgAggregateOutputType | null
    _sum: BuildingSumAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  export type BuildingAvgAggregateOutputType = {
    vehiclelengthlimit: Decimal | null
    vehiclewidthlimit: Decimal | null
    parkingdistance: number | null
  }

  export type BuildingSumAggregateOutputType = {
    vehiclelengthlimit: Decimal | null
    vehiclewidthlimit: Decimal | null
    parkingdistance: number | null
  }

  export type BuildingMinAggregateOutputType = {
    buildingid: string | null
    buildingname: string | null
    housingtype: string | null
    postalcode: string | null
    zoneid: string | null
    vehiclesizelimit: string | null
    vehiclelengthlimit: Decimal | null
    vehiclewidthlimit: Decimal | null
    loadingbayavailable: boolean | null
    liftavailable: boolean | null
    stairsavailable: boolean | null
    narrowdoorways: boolean | null
    parkingdistance: number | null
    preregistrationrequired: boolean | null
    accesstimewindowstart: Date | null
    accesstimewindowend: Date | null
    notes: string | null
    specialequipmentneeded: string | null
    liftdimensions: string | null
  }

  export type BuildingMaxAggregateOutputType = {
    buildingid: string | null
    buildingname: string | null
    housingtype: string | null
    postalcode: string | null
    zoneid: string | null
    vehiclesizelimit: string | null
    vehiclelengthlimit: Decimal | null
    vehiclewidthlimit: Decimal | null
    loadingbayavailable: boolean | null
    liftavailable: boolean | null
    stairsavailable: boolean | null
    narrowdoorways: boolean | null
    parkingdistance: number | null
    preregistrationrequired: boolean | null
    accesstimewindowstart: Date | null
    accesstimewindowend: Date | null
    notes: string | null
    specialequipmentneeded: string | null
    liftdimensions: string | null
  }

  export type BuildingCountAggregateOutputType = {
    buildingid: number
    buildingname: number
    housingtype: number
    postalcode: number
    zoneid: number
    vehiclesizelimit: number
    vehiclelengthlimit: number
    vehiclewidthlimit: number
    loadingbayavailable: number
    liftavailable: number
    stairsavailable: number
    narrowdoorways: number
    parkingdistance: number
    preregistrationrequired: number
    accesstimewindowstart: number
    accesstimewindowend: number
    notes: number
    specialequipmentneeded: number
    liftdimensions: number
    _all: number
  }


  export type BuildingAvgAggregateInputType = {
    vehiclelengthlimit?: true
    vehiclewidthlimit?: true
    parkingdistance?: true
  }

  export type BuildingSumAggregateInputType = {
    vehiclelengthlimit?: true
    vehiclewidthlimit?: true
    parkingdistance?: true
  }

  export type BuildingMinAggregateInputType = {
    buildingid?: true
    buildingname?: true
    housingtype?: true
    postalcode?: true
    zoneid?: true
    vehiclesizelimit?: true
    vehiclelengthlimit?: true
    vehiclewidthlimit?: true
    loadingbayavailable?: true
    liftavailable?: true
    stairsavailable?: true
    narrowdoorways?: true
    parkingdistance?: true
    preregistrationrequired?: true
    accesstimewindowstart?: true
    accesstimewindowend?: true
    notes?: true
    specialequipmentneeded?: true
    liftdimensions?: true
  }

  export type BuildingMaxAggregateInputType = {
    buildingid?: true
    buildingname?: true
    housingtype?: true
    postalcode?: true
    zoneid?: true
    vehiclesizelimit?: true
    vehiclelengthlimit?: true
    vehiclewidthlimit?: true
    loadingbayavailable?: true
    liftavailable?: true
    stairsavailable?: true
    narrowdoorways?: true
    parkingdistance?: true
    preregistrationrequired?: true
    accesstimewindowstart?: true
    accesstimewindowend?: true
    notes?: true
    specialequipmentneeded?: true
    liftdimensions?: true
  }

  export type BuildingCountAggregateInputType = {
    buildingid?: true
    buildingname?: true
    housingtype?: true
    postalcode?: true
    zoneid?: true
    vehiclesizelimit?: true
    vehiclelengthlimit?: true
    vehiclewidthlimit?: true
    loadingbayavailable?: true
    liftavailable?: true
    stairsavailable?: true
    narrowdoorways?: true
    parkingdistance?: true
    preregistrationrequired?: true
    accesstimewindowstart?: true
    accesstimewindowend?: true
    notes?: true
    specialequipmentneeded?: true
    liftdimensions?: true
    _all?: true
  }

  export type BuildingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which building to aggregate.
     */
    where?: buildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of buildings to fetch.
     */
    orderBy?: buildingOrderByWithRelationInput | buildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: buildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned buildings
    **/
    _count?: true | BuildingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildingMaxAggregateInputType
  }

  export type GetBuildingAggregateType<T extends BuildingAggregateArgs> = {
        [P in keyof T & keyof AggregateBuilding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuilding[P]>
      : GetScalarType<T[P], AggregateBuilding[P]>
  }




  export type buildingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: buildingWhereInput
    orderBy?: buildingOrderByWithAggregationInput | buildingOrderByWithAggregationInput[]
    by: BuildingScalarFieldEnum[] | BuildingScalarFieldEnum
    having?: buildingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildingCountAggregateInputType | true
    _avg?: BuildingAvgAggregateInputType
    _sum?: BuildingSumAggregateInputType
    _min?: BuildingMinAggregateInputType
    _max?: BuildingMaxAggregateInputType
  }

  export type BuildingGroupByOutputType = {
    buildingid: string
    buildingname: string | null
    housingtype: string | null
    postalcode: string | null
    zoneid: string | null
    vehiclesizelimit: string | null
    vehiclelengthlimit: Decimal | null
    vehiclewidthlimit: Decimal | null
    loadingbayavailable: boolean | null
    liftavailable: boolean | null
    stairsavailable: boolean | null
    narrowdoorways: boolean | null
    parkingdistance: number | null
    preregistrationrequired: boolean | null
    accesstimewindowstart: Date | null
    accesstimewindowend: Date | null
    notes: string | null
    specialequipmentneeded: string | null
    liftdimensions: string | null
    _count: BuildingCountAggregateOutputType | null
    _avg: BuildingAvgAggregateOutputType | null
    _sum: BuildingSumAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  type GetBuildingGroupByPayload<T extends buildingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildingGroupByOutputType[P]>
            : GetScalarType<T[P], BuildingGroupByOutputType[P]>
        }
      >
    >


  export type buildingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    buildingid?: boolean
    buildingname?: boolean
    housingtype?: boolean
    postalcode?: boolean
    zoneid?: boolean
    vehiclesizelimit?: boolean
    vehiclelengthlimit?: boolean
    vehiclewidthlimit?: boolean
    loadingbayavailable?: boolean
    liftavailable?: boolean
    stairsavailable?: boolean
    narrowdoorways?: boolean
    parkingdistance?: boolean
    preregistrationrequired?: boolean
    accesstimewindowstart?: boolean
    accesstimewindowend?: boolean
    notes?: boolean
    specialequipmentneeded?: boolean
    liftdimensions?: boolean
    zone?: boolean | building$zoneArgs<ExtArgs>
    orders?: boolean | building$ordersArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["building"]>

  export type buildingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    buildingid?: boolean
    buildingname?: boolean
    housingtype?: boolean
    postalcode?: boolean
    zoneid?: boolean
    vehiclesizelimit?: boolean
    vehiclelengthlimit?: boolean
    vehiclewidthlimit?: boolean
    loadingbayavailable?: boolean
    liftavailable?: boolean
    stairsavailable?: boolean
    narrowdoorways?: boolean
    parkingdistance?: boolean
    preregistrationrequired?: boolean
    accesstimewindowstart?: boolean
    accesstimewindowend?: boolean
    notes?: boolean
    specialequipmentneeded?: boolean
    liftdimensions?: boolean
    zone?: boolean | building$zoneArgs<ExtArgs>
  }, ExtArgs["result"]["building"]>

  export type buildingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    buildingid?: boolean
    buildingname?: boolean
    housingtype?: boolean
    postalcode?: boolean
    zoneid?: boolean
    vehiclesizelimit?: boolean
    vehiclelengthlimit?: boolean
    vehiclewidthlimit?: boolean
    loadingbayavailable?: boolean
    liftavailable?: boolean
    stairsavailable?: boolean
    narrowdoorways?: boolean
    parkingdistance?: boolean
    preregistrationrequired?: boolean
    accesstimewindowstart?: boolean
    accesstimewindowend?: boolean
    notes?: boolean
    specialequipmentneeded?: boolean
    liftdimensions?: boolean
    zone?: boolean | building$zoneArgs<ExtArgs>
  }, ExtArgs["result"]["building"]>

  export type buildingSelectScalar = {
    buildingid?: boolean
    buildingname?: boolean
    housingtype?: boolean
    postalcode?: boolean
    zoneid?: boolean
    vehiclesizelimit?: boolean
    vehiclelengthlimit?: boolean
    vehiclewidthlimit?: boolean
    loadingbayavailable?: boolean
    liftavailable?: boolean
    stairsavailable?: boolean
    narrowdoorways?: boolean
    parkingdistance?: boolean
    preregistrationrequired?: boolean
    accesstimewindowstart?: boolean
    accesstimewindowend?: boolean
    notes?: boolean
    specialequipmentneeded?: boolean
    liftdimensions?: boolean
  }

  export type buildingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"buildingid" | "buildingname" | "housingtype" | "postalcode" | "zoneid" | "vehiclesizelimit" | "vehiclelengthlimit" | "vehiclewidthlimit" | "loadingbayavailable" | "liftavailable" | "stairsavailable" | "narrowdoorways" | "parkingdistance" | "preregistrationrequired" | "accesstimewindowstart" | "accesstimewindowend" | "notes" | "specialequipmentneeded" | "liftdimensions", ExtArgs["result"]["building"]>
  export type buildingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | building$zoneArgs<ExtArgs>
    orders?: boolean | building$ordersArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type buildingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | building$zoneArgs<ExtArgs>
  }
  export type buildingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | building$zoneArgs<ExtArgs>
  }

  export type $buildingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "building"
    objects: {
      zone: Prisma.$zonePayload<ExtArgs> | null
      orders: Prisma.$ordersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      buildingid: string
      buildingname: string | null
      housingtype: string | null
      postalcode: string | null
      zoneid: string | null
      vehiclesizelimit: string | null
      vehiclelengthlimit: Prisma.Decimal | null
      vehiclewidthlimit: Prisma.Decimal | null
      loadingbayavailable: boolean | null
      liftavailable: boolean | null
      stairsavailable: boolean | null
      narrowdoorways: boolean | null
      parkingdistance: number | null
      preregistrationrequired: boolean | null
      accesstimewindowstart: Date | null
      accesstimewindowend: Date | null
      notes: string | null
      specialequipmentneeded: string | null
      liftdimensions: string | null
    }, ExtArgs["result"]["building"]>
    composites: {}
  }

  type buildingGetPayload<S extends boolean | null | undefined | buildingDefaultArgs> = $Result.GetResult<Prisma.$buildingPayload, S>

  type buildingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<buildingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BuildingCountAggregateInputType | true
    }

  export interface buildingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['building'], meta: { name: 'building' } }
    /**
     * Find zero or one Building that matches the filter.
     * @param {buildingFindUniqueArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends buildingFindUniqueArgs>(args: SelectSubset<T, buildingFindUniqueArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Building that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {buildingFindUniqueOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends buildingFindUniqueOrThrowArgs>(args: SelectSubset<T, buildingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Building that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buildingFindFirstArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends buildingFindFirstArgs>(args?: SelectSubset<T, buildingFindFirstArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Building that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buildingFindFirstOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends buildingFindFirstOrThrowArgs>(args?: SelectSubset<T, buildingFindFirstOrThrowArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Buildings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buildingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Buildings
     * const buildings = await prisma.building.findMany()
     * 
     * // Get first 10 Buildings
     * const buildings = await prisma.building.findMany({ take: 10 })
     * 
     * // Only select the `buildingid`
     * const buildingWithBuildingidOnly = await prisma.building.findMany({ select: { buildingid: true } })
     * 
     */
    findMany<T extends buildingFindManyArgs>(args?: SelectSubset<T, buildingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Building.
     * @param {buildingCreateArgs} args - Arguments to create a Building.
     * @example
     * // Create one Building
     * const Building = await prisma.building.create({
     *   data: {
     *     // ... data to create a Building
     *   }
     * })
     * 
     */
    create<T extends buildingCreateArgs>(args: SelectSubset<T, buildingCreateArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Buildings.
     * @param {buildingCreateManyArgs} args - Arguments to create many Buildings.
     * @example
     * // Create many Buildings
     * const building = await prisma.building.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends buildingCreateManyArgs>(args?: SelectSubset<T, buildingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Buildings and returns the data saved in the database.
     * @param {buildingCreateManyAndReturnArgs} args - Arguments to create many Buildings.
     * @example
     * // Create many Buildings
     * const building = await prisma.building.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Buildings and only return the `buildingid`
     * const buildingWithBuildingidOnly = await prisma.building.createManyAndReturn({
     *   select: { buildingid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends buildingCreateManyAndReturnArgs>(args?: SelectSubset<T, buildingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Building.
     * @param {buildingDeleteArgs} args - Arguments to delete one Building.
     * @example
     * // Delete one Building
     * const Building = await prisma.building.delete({
     *   where: {
     *     // ... filter to delete one Building
     *   }
     * })
     * 
     */
    delete<T extends buildingDeleteArgs>(args: SelectSubset<T, buildingDeleteArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Building.
     * @param {buildingUpdateArgs} args - Arguments to update one Building.
     * @example
     * // Update one Building
     * const building = await prisma.building.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends buildingUpdateArgs>(args: SelectSubset<T, buildingUpdateArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Buildings.
     * @param {buildingDeleteManyArgs} args - Arguments to filter Buildings to delete.
     * @example
     * // Delete a few Buildings
     * const { count } = await prisma.building.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends buildingDeleteManyArgs>(args?: SelectSubset<T, buildingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buildingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Buildings
     * const building = await prisma.building.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends buildingUpdateManyArgs>(args: SelectSubset<T, buildingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Buildings and returns the data updated in the database.
     * @param {buildingUpdateManyAndReturnArgs} args - Arguments to update many Buildings.
     * @example
     * // Update many Buildings
     * const building = await prisma.building.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Buildings and only return the `buildingid`
     * const buildingWithBuildingidOnly = await prisma.building.updateManyAndReturn({
     *   select: { buildingid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends buildingUpdateManyAndReturnArgs>(args: SelectSubset<T, buildingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Building.
     * @param {buildingUpsertArgs} args - Arguments to update or create a Building.
     * @example
     * // Update or create a Building
     * const building = await prisma.building.upsert({
     *   create: {
     *     // ... data to create a Building
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Building we want to update
     *   }
     * })
     */
    upsert<T extends buildingUpsertArgs>(args: SelectSubset<T, buildingUpsertArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buildingCountArgs} args - Arguments to filter Buildings to count.
     * @example
     * // Count the number of Buildings
     * const count = await prisma.building.count({
     *   where: {
     *     // ... the filter for the Buildings we want to count
     *   }
     * })
    **/
    count<T extends buildingCountArgs>(
      args?: Subset<T, buildingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildingAggregateArgs>(args: Subset<T, BuildingAggregateArgs>): Prisma.PrismaPromise<GetBuildingAggregateType<T>>

    /**
     * Group by Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {buildingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends buildingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: buildingGroupByArgs['orderBy'] }
        : { orderBy?: buildingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, buildingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the building model
   */
  readonly fields: buildingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for building.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__buildingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone<T extends building$zoneArgs<ExtArgs> = {}>(args?: Subset<T, building$zoneArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orders<T extends building$ordersArgs<ExtArgs> = {}>(args?: Subset<T, building$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the building model
   */
  interface buildingFieldRefs {
    readonly buildingid: FieldRef<"building", 'String'>
    readonly buildingname: FieldRef<"building", 'String'>
    readonly housingtype: FieldRef<"building", 'String'>
    readonly postalcode: FieldRef<"building", 'String'>
    readonly zoneid: FieldRef<"building", 'String'>
    readonly vehiclesizelimit: FieldRef<"building", 'String'>
    readonly vehiclelengthlimit: FieldRef<"building", 'Decimal'>
    readonly vehiclewidthlimit: FieldRef<"building", 'Decimal'>
    readonly loadingbayavailable: FieldRef<"building", 'Boolean'>
    readonly liftavailable: FieldRef<"building", 'Boolean'>
    readonly stairsavailable: FieldRef<"building", 'Boolean'>
    readonly narrowdoorways: FieldRef<"building", 'Boolean'>
    readonly parkingdistance: FieldRef<"building", 'Int'>
    readonly preregistrationrequired: FieldRef<"building", 'Boolean'>
    readonly accesstimewindowstart: FieldRef<"building", 'DateTime'>
    readonly accesstimewindowend: FieldRef<"building", 'DateTime'>
    readonly notes: FieldRef<"building", 'String'>
    readonly specialequipmentneeded: FieldRef<"building", 'String'>
    readonly liftdimensions: FieldRef<"building", 'String'>
  }
    

  // Custom InputTypes
  /**
   * building findUnique
   */
  export type buildingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * Filter, which building to fetch.
     */
    where: buildingWhereUniqueInput
  }

  /**
   * building findUniqueOrThrow
   */
  export type buildingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * Filter, which building to fetch.
     */
    where: buildingWhereUniqueInput
  }

  /**
   * building findFirst
   */
  export type buildingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * Filter, which building to fetch.
     */
    where?: buildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of buildings to fetch.
     */
    orderBy?: buildingOrderByWithRelationInput | buildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for buildings.
     */
    cursor?: buildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * building findFirstOrThrow
   */
  export type buildingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * Filter, which building to fetch.
     */
    where?: buildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of buildings to fetch.
     */
    orderBy?: buildingOrderByWithRelationInput | buildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for buildings.
     */
    cursor?: buildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * building findMany
   */
  export type buildingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * Filter, which buildings to fetch.
     */
    where?: buildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of buildings to fetch.
     */
    orderBy?: buildingOrderByWithRelationInput | buildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing buildings.
     */
    cursor?: buildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` buildings.
     */
    skip?: number
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * building create
   */
  export type buildingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * The data needed to create a building.
     */
    data: XOR<buildingCreateInput, buildingUncheckedCreateInput>
  }

  /**
   * building createMany
   */
  export type buildingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many buildings.
     */
    data: buildingCreateManyInput | buildingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * building createManyAndReturn
   */
  export type buildingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * The data used to create many buildings.
     */
    data: buildingCreateManyInput | buildingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * building update
   */
  export type buildingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * The data needed to update a building.
     */
    data: XOR<buildingUpdateInput, buildingUncheckedUpdateInput>
    /**
     * Choose, which building to update.
     */
    where: buildingWhereUniqueInput
  }

  /**
   * building updateMany
   */
  export type buildingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update buildings.
     */
    data: XOR<buildingUpdateManyMutationInput, buildingUncheckedUpdateManyInput>
    /**
     * Filter which buildings to update
     */
    where?: buildingWhereInput
    /**
     * Limit how many buildings to update.
     */
    limit?: number
  }

  /**
   * building updateManyAndReturn
   */
  export type buildingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * The data used to update buildings.
     */
    data: XOR<buildingUpdateManyMutationInput, buildingUncheckedUpdateManyInput>
    /**
     * Filter which buildings to update
     */
    where?: buildingWhereInput
    /**
     * Limit how many buildings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * building upsert
   */
  export type buildingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * The filter to search for the building to update in case it exists.
     */
    where: buildingWhereUniqueInput
    /**
     * In case the building found by the `where` argument doesn't exist, create a new building with this data.
     */
    create: XOR<buildingCreateInput, buildingUncheckedCreateInput>
    /**
     * In case the building was found with the provided `where` argument, update it with this data.
     */
    update: XOR<buildingUpdateInput, buildingUncheckedUpdateInput>
  }

  /**
   * building delete
   */
  export type buildingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    /**
     * Filter which building to delete.
     */
    where: buildingWhereUniqueInput
  }

  /**
   * building deleteMany
   */
  export type buildingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which buildings to delete
     */
    where?: buildingWhereInput
    /**
     * Limit how many buildings to delete.
     */
    limit?: number
  }

  /**
   * building.zone
   */
  export type building$zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    where?: zoneWhereInput
  }

  /**
   * building.orders
   */
  export type building$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    cursor?: ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * building without action
   */
  export type buildingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
  }


  /**
   * Model chats
   */

  export type AggregateChats = {
    _count: ChatsCountAggregateOutputType | null
    _min: ChatsMinAggregateOutputType | null
    _max: ChatsMaxAggregateOutputType | null
  }

  export type ChatsMinAggregateOutputType = {
    chatid: string | null
    ordernumber: string | null
    members: string | null
    names: string | null
    createdat: Date | null
    lastmessageat: Date | null
  }

  export type ChatsMaxAggregateOutputType = {
    chatid: string | null
    ordernumber: string | null
    members: string | null
    names: string | null
    createdat: Date | null
    lastmessageat: Date | null
  }

  export type ChatsCountAggregateOutputType = {
    chatid: number
    ordernumber: number
    members: number
    names: number
    createdat: number
    lastmessageat: number
    _all: number
  }


  export type ChatsMinAggregateInputType = {
    chatid?: true
    ordernumber?: true
    members?: true
    names?: true
    createdat?: true
    lastmessageat?: true
  }

  export type ChatsMaxAggregateInputType = {
    chatid?: true
    ordernumber?: true
    members?: true
    names?: true
    createdat?: true
    lastmessageat?: true
  }

  export type ChatsCountAggregateInputType = {
    chatid?: true
    ordernumber?: true
    members?: true
    names?: true
    createdat?: true
    lastmessageat?: true
    _all?: true
  }

  export type ChatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chats to aggregate.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chats
    **/
    _count?: true | ChatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatsMaxAggregateInputType
  }

  export type GetChatsAggregateType<T extends ChatsAggregateArgs> = {
        [P in keyof T & keyof AggregateChats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChats[P]>
      : GetScalarType<T[P], AggregateChats[P]>
  }




  export type chatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatsWhereInput
    orderBy?: chatsOrderByWithAggregationInput | chatsOrderByWithAggregationInput[]
    by: ChatsScalarFieldEnum[] | ChatsScalarFieldEnum
    having?: chatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatsCountAggregateInputType | true
    _min?: ChatsMinAggregateInputType
    _max?: ChatsMaxAggregateInputType
  }

  export type ChatsGroupByOutputType = {
    chatid: string
    ordernumber: string | null
    members: string | null
    names: string | null
    createdat: Date | null
    lastmessageat: Date | null
    _count: ChatsCountAggregateOutputType | null
    _min: ChatsMinAggregateOutputType | null
    _max: ChatsMaxAggregateOutputType | null
  }

  type GetChatsGroupByPayload<T extends chatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatsGroupByOutputType[P]>
            : GetScalarType<T[P], ChatsGroupByOutputType[P]>
        }
      >
    >


  export type chatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatid?: boolean
    ordernumber?: boolean
    members?: boolean
    names?: boolean
    createdat?: boolean
    lastmessageat?: boolean
  }, ExtArgs["result"]["chats"]>

  export type chatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatid?: boolean
    ordernumber?: boolean
    members?: boolean
    names?: boolean
    createdat?: boolean
    lastmessageat?: boolean
  }, ExtArgs["result"]["chats"]>

  export type chatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatid?: boolean
    ordernumber?: boolean
    members?: boolean
    names?: boolean
    createdat?: boolean
    lastmessageat?: boolean
  }, ExtArgs["result"]["chats"]>

  export type chatsSelectScalar = {
    chatid?: boolean
    ordernumber?: boolean
    members?: boolean
    names?: boolean
    createdat?: boolean
    lastmessageat?: boolean
  }

  export type chatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"chatid" | "ordernumber" | "members" | "names" | "createdat" | "lastmessageat", ExtArgs["result"]["chats"]>

  export type $chatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chats"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      chatid: string
      ordernumber: string | null
      members: string | null
      names: string | null
      createdat: Date | null
      lastmessageat: Date | null
    }, ExtArgs["result"]["chats"]>
    composites: {}
  }

  type chatsGetPayload<S extends boolean | null | undefined | chatsDefaultArgs> = $Result.GetResult<Prisma.$chatsPayload, S>

  type chatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatsCountAggregateInputType | true
    }

  export interface chatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chats'], meta: { name: 'chats' } }
    /**
     * Find zero or one Chats that matches the filter.
     * @param {chatsFindUniqueArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatsFindUniqueArgs>(args: SelectSubset<T, chatsFindUniqueArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatsFindUniqueOrThrowArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatsFindUniqueOrThrowArgs>(args: SelectSubset<T, chatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsFindFirstArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatsFindFirstArgs>(args?: SelectSubset<T, chatsFindFirstArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsFindFirstOrThrowArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatsFindFirstOrThrowArgs>(args?: SelectSubset<T, chatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chats.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chats.findMany({ take: 10 })
     * 
     * // Only select the `chatid`
     * const chatsWithChatidOnly = await prisma.chats.findMany({ select: { chatid: true } })
     * 
     */
    findMany<T extends chatsFindManyArgs>(args?: SelectSubset<T, chatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chats.
     * @param {chatsCreateArgs} args - Arguments to create a Chats.
     * @example
     * // Create one Chats
     * const Chats = await prisma.chats.create({
     *   data: {
     *     // ... data to create a Chats
     *   }
     * })
     * 
     */
    create<T extends chatsCreateArgs>(args: SelectSubset<T, chatsCreateArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chats.
     * @param {chatsCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chats = await prisma.chats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatsCreateManyArgs>(args?: SelectSubset<T, chatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {chatsCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chats = await prisma.chats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `chatid`
     * const chatsWithChatidOnly = await prisma.chats.createManyAndReturn({
     *   select: { chatid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatsCreateManyAndReturnArgs>(args?: SelectSubset<T, chatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chats.
     * @param {chatsDeleteArgs} args - Arguments to delete one Chats.
     * @example
     * // Delete one Chats
     * const Chats = await prisma.chats.delete({
     *   where: {
     *     // ... filter to delete one Chats
     *   }
     * })
     * 
     */
    delete<T extends chatsDeleteArgs>(args: SelectSubset<T, chatsDeleteArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chats.
     * @param {chatsUpdateArgs} args - Arguments to update one Chats.
     * @example
     * // Update one Chats
     * const chats = await prisma.chats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatsUpdateArgs>(args: SelectSubset<T, chatsUpdateArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chats.
     * @param {chatsDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatsDeleteManyArgs>(args?: SelectSubset<T, chatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chats = await prisma.chats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatsUpdateManyArgs>(args: SelectSubset<T, chatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats and returns the data updated in the database.
     * @param {chatsUpdateManyAndReturnArgs} args - Arguments to update many Chats.
     * @example
     * // Update many Chats
     * const chats = await prisma.chats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chats and only return the `chatid`
     * const chatsWithChatidOnly = await prisma.chats.updateManyAndReturn({
     *   select: { chatid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chatsUpdateManyAndReturnArgs>(args: SelectSubset<T, chatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chats.
     * @param {chatsUpsertArgs} args - Arguments to update or create a Chats.
     * @example
     * // Update or create a Chats
     * const chats = await prisma.chats.upsert({
     *   create: {
     *     // ... data to create a Chats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chats we want to update
     *   }
     * })
     */
    upsert<T extends chatsUpsertArgs>(args: SelectSubset<T, chatsUpsertArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chats.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends chatsCountArgs>(
      args?: Subset<T, chatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatsAggregateArgs>(args: Subset<T, ChatsAggregateArgs>): Prisma.PrismaPromise<GetChatsAggregateType<T>>

    /**
     * Group by Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatsGroupByArgs['orderBy'] }
        : { orderBy?: chatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chats model
   */
  readonly fields: chatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chats model
   */
  interface chatsFieldRefs {
    readonly chatid: FieldRef<"chats", 'String'>
    readonly ordernumber: FieldRef<"chats", 'String'>
    readonly members: FieldRef<"chats", 'String'>
    readonly names: FieldRef<"chats", 'String'>
    readonly createdat: FieldRef<"chats", 'DateTime'>
    readonly lastmessageat: FieldRef<"chats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * chats findUnique
   */
  export type chatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats findUniqueOrThrow
   */
  export type chatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats findFirst
   */
  export type chatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chats.
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chats.
     */
    distinct?: ChatsScalarFieldEnum | ChatsScalarFieldEnum[]
  }

  /**
   * chats findFirstOrThrow
   */
  export type chatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chats.
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chats.
     */
    distinct?: ChatsScalarFieldEnum | ChatsScalarFieldEnum[]
  }

  /**
   * chats findMany
   */
  export type chatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chats.
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    distinct?: ChatsScalarFieldEnum | ChatsScalarFieldEnum[]
  }

  /**
   * chats create
   */
  export type chatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * The data needed to create a chats.
     */
    data: XOR<chatsCreateInput, chatsUncheckedCreateInput>
  }

  /**
   * chats createMany
   */
  export type chatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chats.
     */
    data: chatsCreateManyInput | chatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chats createManyAndReturn
   */
  export type chatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * The data used to create many chats.
     */
    data: chatsCreateManyInput | chatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chats update
   */
  export type chatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * The data needed to update a chats.
     */
    data: XOR<chatsUpdateInput, chatsUncheckedUpdateInput>
    /**
     * Choose, which chats to update.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats updateMany
   */
  export type chatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chats.
     */
    data: XOR<chatsUpdateManyMutationInput, chatsUncheckedUpdateManyInput>
    /**
     * Filter which chats to update
     */
    where?: chatsWhereInput
    /**
     * Limit how many chats to update.
     */
    limit?: number
  }

  /**
   * chats updateManyAndReturn
   */
  export type chatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * The data used to update chats.
     */
    data: XOR<chatsUpdateManyMutationInput, chatsUncheckedUpdateManyInput>
    /**
     * Filter which chats to update
     */
    where?: chatsWhereInput
    /**
     * Limit how many chats to update.
     */
    limit?: number
  }

  /**
   * chats upsert
   */
  export type chatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * The filter to search for the chats to update in case it exists.
     */
    where: chatsWhereUniqueInput
    /**
     * In case the chats found by the `where` argument doesn't exist, create a new chats with this data.
     */
    create: XOR<chatsCreateInput, chatsUncheckedCreateInput>
    /**
     * In case the chats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatsUpdateInput, chatsUncheckedUpdateInput>
  }

  /**
   * chats delete
   */
  export type chatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Filter which chats to delete.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats deleteMany
   */
  export type chatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chats to delete
     */
    where?: chatsWhereInput
    /**
     * Limit how many chats to delete.
     */
    limit?: number
  }

  /**
   * chats without action
   */
  export type chatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
  }


  /**
   * Model customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    customerid: string | null
    name: string | null
    displayname: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    postcode: string | null
    bio: string | null
    notificationsenabled: boolean | null
    createdat: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    customerid: string | null
    name: string | null
    displayname: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    postcode: string | null
    bio: string | null
    notificationsenabled: boolean | null
    createdat: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    customerid: number
    name: number
    displayname: number
    email: number
    phone: number
    address: number
    city: number
    state: number
    postcode: number
    bio: number
    notificationsenabled: number
    createdat: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    customerid?: true
    name?: true
    displayname?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    postcode?: true
    bio?: true
    notificationsenabled?: true
    createdat?: true
  }

  export type CustomerMaxAggregateInputType = {
    customerid?: true
    name?: true
    displayname?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    postcode?: true
    bio?: true
    notificationsenabled?: true
    createdat?: true
  }

  export type CustomerCountAggregateInputType = {
    customerid?: true
    name?: true
    displayname?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    state?: true
    postcode?: true
    bio?: true
    notificationsenabled?: true
    createdat?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer to aggregate.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type customerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
    orderBy?: customerOrderByWithAggregationInput | customerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: customerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    customerid: string
    name: string | null
    displayname: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    state: string | null
    postcode: string | null
    bio: string | null
    notificationsenabled: boolean | null
    createdat: Date | null
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends customerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type customerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerid?: boolean
    name?: boolean
    displayname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postcode?: boolean
    bio?: boolean
    notificationsenabled?: boolean
    createdat?: boolean
    orders?: boolean | customer$ordersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type customerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerid?: boolean
    name?: boolean
    displayname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postcode?: boolean
    bio?: boolean
    notificationsenabled?: boolean
    createdat?: boolean
  }, ExtArgs["result"]["customer"]>

  export type customerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    customerid?: boolean
    name?: boolean
    displayname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postcode?: boolean
    bio?: boolean
    notificationsenabled?: boolean
    createdat?: boolean
  }, ExtArgs["result"]["customer"]>

  export type customerSelectScalar = {
    customerid?: boolean
    name?: boolean
    displayname?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    postcode?: boolean
    bio?: boolean
    notificationsenabled?: boolean
    createdat?: boolean
  }

  export type customerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"customerid" | "name" | "displayname" | "email" | "phone" | "address" | "city" | "state" | "postcode" | "bio" | "notificationsenabled" | "createdat", ExtArgs["result"]["customer"]>
  export type customerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | customer$ordersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type customerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type customerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $customerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer"
    objects: {
      orders: Prisma.$ordersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      customerid: string
      name: string | null
      displayname: string | null
      email: string | null
      phone: string | null
      address: string | null
      city: string | null
      state: string | null
      postcode: string | null
      bio: string | null
      notificationsenabled: boolean | null
      createdat: Date | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type customerGetPayload<S extends boolean | null | undefined | customerDefaultArgs> = $Result.GetResult<Prisma.$customerPayload, S>

  type customerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface customerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer'], meta: { name: 'customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {customerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customerFindUniqueArgs>(args: SelectSubset<T, customerFindUniqueArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customerFindUniqueOrThrowArgs>(args: SelectSubset<T, customerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customerFindFirstArgs>(args?: SelectSubset<T, customerFindFirstArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customerFindFirstOrThrowArgs>(args?: SelectSubset<T, customerFindFirstOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `customerid`
     * const customerWithCustomeridOnly = await prisma.customer.findMany({ select: { customerid: true } })
     * 
     */
    findMany<T extends customerFindManyArgs>(args?: SelectSubset<T, customerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {customerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends customerCreateArgs>(args: SelectSubset<T, customerCreateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {customerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customerCreateManyArgs>(args?: SelectSubset<T, customerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {customerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `customerid`
     * const customerWithCustomeridOnly = await prisma.customer.createManyAndReturn({
     *   select: { customerid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends customerCreateManyAndReturnArgs>(args?: SelectSubset<T, customerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {customerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends customerDeleteArgs>(args: SelectSubset<T, customerDeleteArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {customerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customerUpdateArgs>(args: SelectSubset<T, customerUpdateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {customerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customerDeleteManyArgs>(args?: SelectSubset<T, customerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customerUpdateManyArgs>(args: SelectSubset<T, customerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {customerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `customerid`
     * const customerWithCustomeridOnly = await prisma.customer.updateManyAndReturn({
     *   select: { customerid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends customerUpdateManyAndReturnArgs>(args: SelectSubset<T, customerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {customerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends customerUpsertArgs>(args: SelectSubset<T, customerUpsertArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customerCountArgs>(
      args?: Subset<T, customerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customerGroupByArgs['orderBy'] }
        : { orderBy?: customerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer model
   */
  readonly fields: customerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends customer$ordersArgs<ExtArgs> = {}>(args?: Subset<T, customer$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customer model
   */
  interface customerFieldRefs {
    readonly customerid: FieldRef<"customer", 'String'>
    readonly name: FieldRef<"customer", 'String'>
    readonly displayname: FieldRef<"customer", 'String'>
    readonly email: FieldRef<"customer", 'String'>
    readonly phone: FieldRef<"customer", 'String'>
    readonly address: FieldRef<"customer", 'String'>
    readonly city: FieldRef<"customer", 'String'>
    readonly state: FieldRef<"customer", 'String'>
    readonly postcode: FieldRef<"customer", 'String'>
    readonly bio: FieldRef<"customer", 'String'>
    readonly notificationsenabled: FieldRef<"customer", 'Boolean'>
    readonly createdat: FieldRef<"customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customer findUnique
   */
  export type customerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findUniqueOrThrow
   */
  export type customerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findFirst
   */
  export type customerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findFirstOrThrow
   */
  export type customerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findMany
   */
  export type customerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer create
   */
  export type customerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to create a customer.
     */
    data: XOR<customerCreateInput, customerUncheckedCreateInput>
  }

  /**
   * customer createMany
   */
  export type customerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer createManyAndReturn
   */
  export type customerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer update
   */
  export type customerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to update a customer.
     */
    data: XOR<customerUpdateInput, customerUncheckedUpdateInput>
    /**
     * Choose, which customer to update.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer updateMany
   */
  export type customerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
  }

  /**
   * customer updateManyAndReturn
   */
  export type customerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
  }

  /**
   * customer upsert
   */
  export type customerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The filter to search for the customer to update in case it exists.
     */
    where: customerWhereUniqueInput
    /**
     * In case the customer found by the `where` argument doesn't exist, create a new customer with this data.
     */
    create: XOR<customerCreateInput, customerUncheckedCreateInput>
    /**
     * In case the customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerUpdateInput, customerUncheckedUpdateInput>
  }

  /**
   * customer delete
   */
  export type customerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter which customer to delete.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer deleteMany
   */
  export type customerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to delete.
     */
    limit?: number
  }

  /**
   * customer.orders
   */
  export type customer$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    cursor?: ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * customer without action
   */
  export type customerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
  }


  /**
   * Model employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    employeeid: string | null
    name: string | null
    email: string | null
    contact_number: string | null
    role: string | null
    active_flag: boolean | null
    displayname: string | null
    createdat: Date | null
    bio: string | null
  }

  export type EmployeeMaxAggregateOutputType = {
    employeeid: string | null
    name: string | null
    email: string | null
    contact_number: string | null
    role: string | null
    active_flag: boolean | null
    displayname: string | null
    createdat: Date | null
    bio: string | null
  }

  export type EmployeeCountAggregateOutputType = {
    employeeid: number
    name: number
    email: number
    contact_number: number
    role: number
    active_flag: number
    displayname: number
    createdat: number
    bio: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    employeeid?: true
    name?: true
    email?: true
    contact_number?: true
    role?: true
    active_flag?: true
    displayname?: true
    createdat?: true
    bio?: true
  }

  export type EmployeeMaxAggregateInputType = {
    employeeid?: true
    name?: true
    email?: true
    contact_number?: true
    role?: true
    active_flag?: true
    displayname?: true
    createdat?: true
    bio?: true
  }

  export type EmployeeCountAggregateInputType = {
    employeeid?: true
    name?: true
    email?: true
    contact_number?: true
    role?: true
    active_flag?: true
    displayname?: true
    createdat?: true
    bio?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employee to aggregate.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type employeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeWhereInput
    orderBy?: employeeOrderByWithAggregationInput | employeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: employeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    employeeid: string
    name: string | null
    email: string | null
    contact_number: string | null
    role: string | null
    active_flag: boolean | null
    displayname: string | null
    createdat: Date | null
    bio: string | null
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends employeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type employeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeid?: boolean
    name?: boolean
    email?: boolean
    contact_number?: boolean
    role?: boolean
    active_flag?: boolean
    displayname?: boolean
    createdat?: boolean
    bio?: boolean
    employeeteamassignment?: boolean | employee$employeeteamassignmentArgs<ExtArgs>
    orders?: boolean | employee$ordersArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type employeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeid?: boolean
    name?: boolean
    email?: boolean
    contact_number?: boolean
    role?: boolean
    active_flag?: boolean
    displayname?: boolean
    createdat?: boolean
    bio?: boolean
  }, ExtArgs["result"]["employee"]>

  export type employeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeid?: boolean
    name?: boolean
    email?: boolean
    contact_number?: boolean
    role?: boolean
    active_flag?: boolean
    displayname?: boolean
    createdat?: boolean
    bio?: boolean
  }, ExtArgs["result"]["employee"]>

  export type employeeSelectScalar = {
    employeeid?: boolean
    name?: boolean
    email?: boolean
    contact_number?: boolean
    role?: boolean
    active_flag?: boolean
    displayname?: boolean
    createdat?: boolean
    bio?: boolean
  }

  export type employeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"employeeid" | "name" | "email" | "contact_number" | "role" | "active_flag" | "displayname" | "createdat" | "bio", ExtArgs["result"]["employee"]>
  export type employeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeteamassignment?: boolean | employee$employeeteamassignmentArgs<ExtArgs>
    orders?: boolean | employee$ordersArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type employeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type employeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $employeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employee"
    objects: {
      employeeteamassignment: Prisma.$employeeteamassignmentPayload<ExtArgs>[]
      orders: Prisma.$ordersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      employeeid: string
      name: string | null
      email: string | null
      contact_number: string | null
      role: string | null
      active_flag: boolean | null
      displayname: string | null
      createdat: Date | null
      bio: string | null
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type employeeGetPayload<S extends boolean | null | undefined | employeeDefaultArgs> = $Result.GetResult<Prisma.$employeePayload, S>

  type employeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface employeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employee'], meta: { name: 'employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {employeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employeeFindUniqueArgs>(args: SelectSubset<T, employeeFindUniqueArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employeeFindUniqueOrThrowArgs>(args: SelectSubset<T, employeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employeeFindFirstArgs>(args?: SelectSubset<T, employeeFindFirstArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employeeFindFirstOrThrowArgs>(args?: SelectSubset<T, employeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `employeeid`
     * const employeeWithEmployeeidOnly = await prisma.employee.findMany({ select: { employeeid: true } })
     * 
     */
    findMany<T extends employeeFindManyArgs>(args?: SelectSubset<T, employeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {employeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends employeeCreateArgs>(args: SelectSubset<T, employeeCreateArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {employeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employeeCreateManyArgs>(args?: SelectSubset<T, employeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {employeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `employeeid`
     * const employeeWithEmployeeidOnly = await prisma.employee.createManyAndReturn({
     *   select: { employeeid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends employeeCreateManyAndReturnArgs>(args?: SelectSubset<T, employeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {employeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends employeeDeleteArgs>(args: SelectSubset<T, employeeDeleteArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {employeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employeeUpdateArgs>(args: SelectSubset<T, employeeUpdateArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {employeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employeeDeleteManyArgs>(args?: SelectSubset<T, employeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employeeUpdateManyArgs>(args: SelectSubset<T, employeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {employeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `employeeid`
     * const employeeWithEmployeeidOnly = await prisma.employee.updateManyAndReturn({
     *   select: { employeeid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends employeeUpdateManyAndReturnArgs>(args: SelectSubset<T, employeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {employeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends employeeUpsertArgs>(args: SelectSubset<T, employeeUpsertArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends employeeCountArgs>(
      args?: Subset<T, employeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employeeGroupByArgs['orderBy'] }
        : { orderBy?: employeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employee model
   */
  readonly fields: employeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employeeteamassignment<T extends employee$employeeteamassignmentArgs<ExtArgs> = {}>(args?: Subset<T, employee$employeeteamassignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeeteamassignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends employee$ordersArgs<ExtArgs> = {}>(args?: Subset<T, employee$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employee model
   */
  interface employeeFieldRefs {
    readonly employeeid: FieldRef<"employee", 'String'>
    readonly name: FieldRef<"employee", 'String'>
    readonly email: FieldRef<"employee", 'String'>
    readonly contact_number: FieldRef<"employee", 'String'>
    readonly role: FieldRef<"employee", 'String'>
    readonly active_flag: FieldRef<"employee", 'Boolean'>
    readonly displayname: FieldRef<"employee", 'String'>
    readonly createdat: FieldRef<"employee", 'DateTime'>
    readonly bio: FieldRef<"employee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * employee findUnique
   */
  export type employeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee findUniqueOrThrow
   */
  export type employeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee findFirst
   */
  export type employeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee findFirstOrThrow
   */
  export type employeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employee to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee findMany
   */
  export type employeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where?: employeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeeOrderByWithRelationInput | employeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employees.
     */
    cursor?: employeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * employee create
   */
  export type employeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The data needed to create a employee.
     */
    data: XOR<employeeCreateInput, employeeUncheckedCreateInput>
  }

  /**
   * employee createMany
   */
  export type employeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employees.
     */
    data: employeeCreateManyInput | employeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employee createManyAndReturn
   */
  export type employeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * The data used to create many employees.
     */
    data: employeeCreateManyInput | employeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employee update
   */
  export type employeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The data needed to update a employee.
     */
    data: XOR<employeeUpdateInput, employeeUncheckedUpdateInput>
    /**
     * Choose, which employee to update.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee updateMany
   */
  export type employeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employees.
     */
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyInput>
    /**
     * Filter which employees to update
     */
    where?: employeeWhereInput
    /**
     * Limit how many employees to update.
     */
    limit?: number
  }

  /**
   * employee updateManyAndReturn
   */
  export type employeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * The data used to update employees.
     */
    data: XOR<employeeUpdateManyMutationInput, employeeUncheckedUpdateManyInput>
    /**
     * Filter which employees to update
     */
    where?: employeeWhereInput
    /**
     * Limit how many employees to update.
     */
    limit?: number
  }

  /**
   * employee upsert
   */
  export type employeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * The filter to search for the employee to update in case it exists.
     */
    where: employeeWhereUniqueInput
    /**
     * In case the employee found by the `where` argument doesn't exist, create a new employee with this data.
     */
    create: XOR<employeeCreateInput, employeeUncheckedCreateInput>
    /**
     * In case the employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employeeUpdateInput, employeeUncheckedUpdateInput>
  }

  /**
   * employee delete
   */
  export type employeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    /**
     * Filter which employee to delete.
     */
    where: employeeWhereUniqueInput
  }

  /**
   * employee deleteMany
   */
  export type employeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employees to delete
     */
    where?: employeeWhereInput
    /**
     * Limit how many employees to delete.
     */
    limit?: number
  }

  /**
   * employee.employeeteamassignment
   */
  export type employee$employeeteamassignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeteamassignment
     */
    select?: employeeteamassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeteamassignment
     */
    omit?: employeeteamassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeteamassignmentInclude<ExtArgs> | null
    where?: employeeteamassignmentWhereInput
    orderBy?: employeeteamassignmentOrderByWithRelationInput | employeeteamassignmentOrderByWithRelationInput[]
    cursor?: employeeteamassignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeteamassignmentScalarFieldEnum | EmployeeteamassignmentScalarFieldEnum[]
  }

  /**
   * employee.orders
   */
  export type employee$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    cursor?: ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * employee without action
   */
  export type employeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
  }


  /**
   * Model employeeteamassignment
   */

  export type AggregateEmployeeteamassignment = {
    _count: EmployeeteamassignmentCountAggregateOutputType | null
    _min: EmployeeteamassignmentMinAggregateOutputType | null
    _max: EmployeeteamassignmentMaxAggregateOutputType | null
  }

  export type EmployeeteamassignmentMinAggregateOutputType = {
    employeeid: string | null
    teamid: string | null
  }

  export type EmployeeteamassignmentMaxAggregateOutputType = {
    employeeid: string | null
    teamid: string | null
  }

  export type EmployeeteamassignmentCountAggregateOutputType = {
    employeeid: number
    teamid: number
    _all: number
  }


  export type EmployeeteamassignmentMinAggregateInputType = {
    employeeid?: true
    teamid?: true
  }

  export type EmployeeteamassignmentMaxAggregateInputType = {
    employeeid?: true
    teamid?: true
  }

  export type EmployeeteamassignmentCountAggregateInputType = {
    employeeid?: true
    teamid?: true
    _all?: true
  }

  export type EmployeeteamassignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employeeteamassignment to aggregate.
     */
    where?: employeeteamassignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employeeteamassignments to fetch.
     */
    orderBy?: employeeteamassignmentOrderByWithRelationInput | employeeteamassignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employeeteamassignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employeeteamassignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employeeteamassignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employeeteamassignments
    **/
    _count?: true | EmployeeteamassignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeteamassignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeteamassignmentMaxAggregateInputType
  }

  export type GetEmployeeteamassignmentAggregateType<T extends EmployeeteamassignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeteamassignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeteamassignment[P]>
      : GetScalarType<T[P], AggregateEmployeeteamassignment[P]>
  }




  export type employeeteamassignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeeteamassignmentWhereInput
    orderBy?: employeeteamassignmentOrderByWithAggregationInput | employeeteamassignmentOrderByWithAggregationInput[]
    by: EmployeeteamassignmentScalarFieldEnum[] | EmployeeteamassignmentScalarFieldEnum
    having?: employeeteamassignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeteamassignmentCountAggregateInputType | true
    _min?: EmployeeteamassignmentMinAggregateInputType
    _max?: EmployeeteamassignmentMaxAggregateInputType
  }

  export type EmployeeteamassignmentGroupByOutputType = {
    employeeid: string
    teamid: string
    _count: EmployeeteamassignmentCountAggregateOutputType | null
    _min: EmployeeteamassignmentMinAggregateOutputType | null
    _max: EmployeeteamassignmentMaxAggregateOutputType | null
  }

  type GetEmployeeteamassignmentGroupByPayload<T extends employeeteamassignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeteamassignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeteamassignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeteamassignmentGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeteamassignmentGroupByOutputType[P]>
        }
      >
    >


  export type employeeteamassignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeid?: boolean
    teamid?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeteamassignment"]>

  export type employeeteamassignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeid?: boolean
    teamid?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeteamassignment"]>

  export type employeeteamassignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employeeid?: boolean
    teamid?: boolean
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeteamassignment"]>

  export type employeeteamassignmentSelectScalar = {
    employeeid?: boolean
    teamid?: boolean
  }

  export type employeeteamassignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"employeeid" | "teamid", ExtArgs["result"]["employeeteamassignment"]>
  export type employeeteamassignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }
  export type employeeteamassignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }
  export type employeeteamassignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | employeeDefaultArgs<ExtArgs>
    team?: boolean | teamDefaultArgs<ExtArgs>
  }

  export type $employeeteamassignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employeeteamassignment"
    objects: {
      employee: Prisma.$employeePayload<ExtArgs>
      team: Prisma.$teamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      employeeid: string
      teamid: string
    }, ExtArgs["result"]["employeeteamassignment"]>
    composites: {}
  }

  type employeeteamassignmentGetPayload<S extends boolean | null | undefined | employeeteamassignmentDefaultArgs> = $Result.GetResult<Prisma.$employeeteamassignmentPayload, S>

  type employeeteamassignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employeeteamassignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeteamassignmentCountAggregateInputType | true
    }

  export interface employeeteamassignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employeeteamassignment'], meta: { name: 'employeeteamassignment' } }
    /**
     * Find zero or one Employeeteamassignment that matches the filter.
     * @param {employeeteamassignmentFindUniqueArgs} args - Arguments to find a Employeeteamassignment
     * @example
     * // Get one Employeeteamassignment
     * const employeeteamassignment = await prisma.employeeteamassignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employeeteamassignmentFindUniqueArgs>(args: SelectSubset<T, employeeteamassignmentFindUniqueArgs<ExtArgs>>): Prisma__employeeteamassignmentClient<$Result.GetResult<Prisma.$employeeteamassignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employeeteamassignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employeeteamassignmentFindUniqueOrThrowArgs} args - Arguments to find a Employeeteamassignment
     * @example
     * // Get one Employeeteamassignment
     * const employeeteamassignment = await prisma.employeeteamassignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employeeteamassignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, employeeteamassignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employeeteamassignmentClient<$Result.GetResult<Prisma.$employeeteamassignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employeeteamassignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeteamassignmentFindFirstArgs} args - Arguments to find a Employeeteamassignment
     * @example
     * // Get one Employeeteamassignment
     * const employeeteamassignment = await prisma.employeeteamassignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employeeteamassignmentFindFirstArgs>(args?: SelectSubset<T, employeeteamassignmentFindFirstArgs<ExtArgs>>): Prisma__employeeteamassignmentClient<$Result.GetResult<Prisma.$employeeteamassignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employeeteamassignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeteamassignmentFindFirstOrThrowArgs} args - Arguments to find a Employeeteamassignment
     * @example
     * // Get one Employeeteamassignment
     * const employeeteamassignment = await prisma.employeeteamassignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employeeteamassignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, employeeteamassignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__employeeteamassignmentClient<$Result.GetResult<Prisma.$employeeteamassignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employeeteamassignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeteamassignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employeeteamassignments
     * const employeeteamassignments = await prisma.employeeteamassignment.findMany()
     * 
     * // Get first 10 Employeeteamassignments
     * const employeeteamassignments = await prisma.employeeteamassignment.findMany({ take: 10 })
     * 
     * // Only select the `employeeid`
     * const employeeteamassignmentWithEmployeeidOnly = await prisma.employeeteamassignment.findMany({ select: { employeeid: true } })
     * 
     */
    findMany<T extends employeeteamassignmentFindManyArgs>(args?: SelectSubset<T, employeeteamassignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeeteamassignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employeeteamassignment.
     * @param {employeeteamassignmentCreateArgs} args - Arguments to create a Employeeteamassignment.
     * @example
     * // Create one Employeeteamassignment
     * const Employeeteamassignment = await prisma.employeeteamassignment.create({
     *   data: {
     *     // ... data to create a Employeeteamassignment
     *   }
     * })
     * 
     */
    create<T extends employeeteamassignmentCreateArgs>(args: SelectSubset<T, employeeteamassignmentCreateArgs<ExtArgs>>): Prisma__employeeteamassignmentClient<$Result.GetResult<Prisma.$employeeteamassignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employeeteamassignments.
     * @param {employeeteamassignmentCreateManyArgs} args - Arguments to create many Employeeteamassignments.
     * @example
     * // Create many Employeeteamassignments
     * const employeeteamassignment = await prisma.employeeteamassignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employeeteamassignmentCreateManyArgs>(args?: SelectSubset<T, employeeteamassignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employeeteamassignments and returns the data saved in the database.
     * @param {employeeteamassignmentCreateManyAndReturnArgs} args - Arguments to create many Employeeteamassignments.
     * @example
     * // Create many Employeeteamassignments
     * const employeeteamassignment = await prisma.employeeteamassignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employeeteamassignments and only return the `employeeid`
     * const employeeteamassignmentWithEmployeeidOnly = await prisma.employeeteamassignment.createManyAndReturn({
     *   select: { employeeid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends employeeteamassignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, employeeteamassignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeeteamassignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employeeteamassignment.
     * @param {employeeteamassignmentDeleteArgs} args - Arguments to delete one Employeeteamassignment.
     * @example
     * // Delete one Employeeteamassignment
     * const Employeeteamassignment = await prisma.employeeteamassignment.delete({
     *   where: {
     *     // ... filter to delete one Employeeteamassignment
     *   }
     * })
     * 
     */
    delete<T extends employeeteamassignmentDeleteArgs>(args: SelectSubset<T, employeeteamassignmentDeleteArgs<ExtArgs>>): Prisma__employeeteamassignmentClient<$Result.GetResult<Prisma.$employeeteamassignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employeeteamassignment.
     * @param {employeeteamassignmentUpdateArgs} args - Arguments to update one Employeeteamassignment.
     * @example
     * // Update one Employeeteamassignment
     * const employeeteamassignment = await prisma.employeeteamassignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employeeteamassignmentUpdateArgs>(args: SelectSubset<T, employeeteamassignmentUpdateArgs<ExtArgs>>): Prisma__employeeteamassignmentClient<$Result.GetResult<Prisma.$employeeteamassignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employeeteamassignments.
     * @param {employeeteamassignmentDeleteManyArgs} args - Arguments to filter Employeeteamassignments to delete.
     * @example
     * // Delete a few Employeeteamassignments
     * const { count } = await prisma.employeeteamassignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employeeteamassignmentDeleteManyArgs>(args?: SelectSubset<T, employeeteamassignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employeeteamassignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeteamassignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employeeteamassignments
     * const employeeteamassignment = await prisma.employeeteamassignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employeeteamassignmentUpdateManyArgs>(args: SelectSubset<T, employeeteamassignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employeeteamassignments and returns the data updated in the database.
     * @param {employeeteamassignmentUpdateManyAndReturnArgs} args - Arguments to update many Employeeteamassignments.
     * @example
     * // Update many Employeeteamassignments
     * const employeeteamassignment = await prisma.employeeteamassignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employeeteamassignments and only return the `employeeid`
     * const employeeteamassignmentWithEmployeeidOnly = await prisma.employeeteamassignment.updateManyAndReturn({
     *   select: { employeeid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends employeeteamassignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, employeeteamassignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeeteamassignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employeeteamassignment.
     * @param {employeeteamassignmentUpsertArgs} args - Arguments to update or create a Employeeteamassignment.
     * @example
     * // Update or create a Employeeteamassignment
     * const employeeteamassignment = await prisma.employeeteamassignment.upsert({
     *   create: {
     *     // ... data to create a Employeeteamassignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employeeteamassignment we want to update
     *   }
     * })
     */
    upsert<T extends employeeteamassignmentUpsertArgs>(args: SelectSubset<T, employeeteamassignmentUpsertArgs<ExtArgs>>): Prisma__employeeteamassignmentClient<$Result.GetResult<Prisma.$employeeteamassignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employeeteamassignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeteamassignmentCountArgs} args - Arguments to filter Employeeteamassignments to count.
     * @example
     * // Count the number of Employeeteamassignments
     * const count = await prisma.employeeteamassignment.count({
     *   where: {
     *     // ... the filter for the Employeeteamassignments we want to count
     *   }
     * })
    **/
    count<T extends employeeteamassignmentCountArgs>(
      args?: Subset<T, employeeteamassignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeteamassignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employeeteamassignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeteamassignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeteamassignmentAggregateArgs>(args: Subset<T, EmployeeteamassignmentAggregateArgs>): Prisma.PrismaPromise<GetEmployeeteamassignmentAggregateType<T>>

    /**
     * Group by Employeeteamassignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeeteamassignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employeeteamassignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employeeteamassignmentGroupByArgs['orderBy'] }
        : { orderBy?: employeeteamassignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employeeteamassignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeteamassignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employeeteamassignment model
   */
  readonly fields: employeeteamassignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employeeteamassignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employeeteamassignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends employeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, employeeDefaultArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends teamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teamDefaultArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employeeteamassignment model
   */
  interface employeeteamassignmentFieldRefs {
    readonly employeeid: FieldRef<"employeeteamassignment", 'String'>
    readonly teamid: FieldRef<"employeeteamassignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * employeeteamassignment findUnique
   */
  export type employeeteamassignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeteamassignment
     */
    select?: employeeteamassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeteamassignment
     */
    omit?: employeeteamassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeteamassignmentInclude<ExtArgs> | null
    /**
     * Filter, which employeeteamassignment to fetch.
     */
    where: employeeteamassignmentWhereUniqueInput
  }

  /**
   * employeeteamassignment findUniqueOrThrow
   */
  export type employeeteamassignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeteamassignment
     */
    select?: employeeteamassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeteamassignment
     */
    omit?: employeeteamassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeteamassignmentInclude<ExtArgs> | null
    /**
     * Filter, which employeeteamassignment to fetch.
     */
    where: employeeteamassignmentWhereUniqueInput
  }

  /**
   * employeeteamassignment findFirst
   */
  export type employeeteamassignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeteamassignment
     */
    select?: employeeteamassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeteamassignment
     */
    omit?: employeeteamassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeteamassignmentInclude<ExtArgs> | null
    /**
     * Filter, which employeeteamassignment to fetch.
     */
    where?: employeeteamassignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employeeteamassignments to fetch.
     */
    orderBy?: employeeteamassignmentOrderByWithRelationInput | employeeteamassignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employeeteamassignments.
     */
    cursor?: employeeteamassignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employeeteamassignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employeeteamassignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employeeteamassignments.
     */
    distinct?: EmployeeteamassignmentScalarFieldEnum | EmployeeteamassignmentScalarFieldEnum[]
  }

  /**
   * employeeteamassignment findFirstOrThrow
   */
  export type employeeteamassignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeteamassignment
     */
    select?: employeeteamassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeteamassignment
     */
    omit?: employeeteamassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeteamassignmentInclude<ExtArgs> | null
    /**
     * Filter, which employeeteamassignment to fetch.
     */
    where?: employeeteamassignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employeeteamassignments to fetch.
     */
    orderBy?: employeeteamassignmentOrderByWithRelationInput | employeeteamassignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employeeteamassignments.
     */
    cursor?: employeeteamassignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employeeteamassignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employeeteamassignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employeeteamassignments.
     */
    distinct?: EmployeeteamassignmentScalarFieldEnum | EmployeeteamassignmentScalarFieldEnum[]
  }

  /**
   * employeeteamassignment findMany
   */
  export type employeeteamassignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeteamassignment
     */
    select?: employeeteamassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeteamassignment
     */
    omit?: employeeteamassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeteamassignmentInclude<ExtArgs> | null
    /**
     * Filter, which employeeteamassignments to fetch.
     */
    where?: employeeteamassignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employeeteamassignments to fetch.
     */
    orderBy?: employeeteamassignmentOrderByWithRelationInput | employeeteamassignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employeeteamassignments.
     */
    cursor?: employeeteamassignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employeeteamassignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employeeteamassignments.
     */
    skip?: number
    distinct?: EmployeeteamassignmentScalarFieldEnum | EmployeeteamassignmentScalarFieldEnum[]
  }

  /**
   * employeeteamassignment create
   */
  export type employeeteamassignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeteamassignment
     */
    select?: employeeteamassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeteamassignment
     */
    omit?: employeeteamassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeteamassignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a employeeteamassignment.
     */
    data: XOR<employeeteamassignmentCreateInput, employeeteamassignmentUncheckedCreateInput>
  }

  /**
   * employeeteamassignment createMany
   */
  export type employeeteamassignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employeeteamassignments.
     */
    data: employeeteamassignmentCreateManyInput | employeeteamassignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employeeteamassignment createManyAndReturn
   */
  export type employeeteamassignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeteamassignment
     */
    select?: employeeteamassignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employeeteamassignment
     */
    omit?: employeeteamassignmentOmit<ExtArgs> | null
    /**
     * The data used to create many employeeteamassignments.
     */
    data: employeeteamassignmentCreateManyInput | employeeteamassignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeteamassignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * employeeteamassignment update
   */
  export type employeeteamassignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeteamassignment
     */
    select?: employeeteamassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeteamassignment
     */
    omit?: employeeteamassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeteamassignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a employeeteamassignment.
     */
    data: XOR<employeeteamassignmentUpdateInput, employeeteamassignmentUncheckedUpdateInput>
    /**
     * Choose, which employeeteamassignment to update.
     */
    where: employeeteamassignmentWhereUniqueInput
  }

  /**
   * employeeteamassignment updateMany
   */
  export type employeeteamassignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employeeteamassignments.
     */
    data: XOR<employeeteamassignmentUpdateManyMutationInput, employeeteamassignmentUncheckedUpdateManyInput>
    /**
     * Filter which employeeteamassignments to update
     */
    where?: employeeteamassignmentWhereInput
    /**
     * Limit how many employeeteamassignments to update.
     */
    limit?: number
  }

  /**
   * employeeteamassignment updateManyAndReturn
   */
  export type employeeteamassignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeteamassignment
     */
    select?: employeeteamassignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employeeteamassignment
     */
    omit?: employeeteamassignmentOmit<ExtArgs> | null
    /**
     * The data used to update employeeteamassignments.
     */
    data: XOR<employeeteamassignmentUpdateManyMutationInput, employeeteamassignmentUncheckedUpdateManyInput>
    /**
     * Filter which employeeteamassignments to update
     */
    where?: employeeteamassignmentWhereInput
    /**
     * Limit how many employeeteamassignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeteamassignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * employeeteamassignment upsert
   */
  export type employeeteamassignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeteamassignment
     */
    select?: employeeteamassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeteamassignment
     */
    omit?: employeeteamassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeteamassignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the employeeteamassignment to update in case it exists.
     */
    where: employeeteamassignmentWhereUniqueInput
    /**
     * In case the employeeteamassignment found by the `where` argument doesn't exist, create a new employeeteamassignment with this data.
     */
    create: XOR<employeeteamassignmentCreateInput, employeeteamassignmentUncheckedCreateInput>
    /**
     * In case the employeeteamassignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employeeteamassignmentUpdateInput, employeeteamassignmentUncheckedUpdateInput>
  }

  /**
   * employeeteamassignment delete
   */
  export type employeeteamassignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeteamassignment
     */
    select?: employeeteamassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeteamassignment
     */
    omit?: employeeteamassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeteamassignmentInclude<ExtArgs> | null
    /**
     * Filter which employeeteamassignment to delete.
     */
    where: employeeteamassignmentWhereUniqueInput
  }

  /**
   * employeeteamassignment deleteMany
   */
  export type employeeteamassignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employeeteamassignments to delete
     */
    where?: employeeteamassignmentWhereInput
    /**
     * Limit how many employeeteamassignments to delete.
     */
    limit?: number
  }

  /**
   * employeeteamassignment without action
   */
  export type employeeteamassignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeteamassignment
     */
    select?: employeeteamassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeteamassignment
     */
    omit?: employeeteamassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeteamassignmentInclude<ExtArgs> | null
  }


  /**
   * Model lorrytrip
   */

  export type AggregateLorrytrip = {
    _count: LorrytripCountAggregateOutputType | null
    _min: LorrytripMinAggregateOutputType | null
    _max: LorrytripMaxAggregateOutputType | null
  }

  export type LorrytripMinAggregateOutputType = {
    lorrytripid: string | null
    deliveryteamid: string | null
    warehouseteamid: string | null
    truckid: string | null
  }

  export type LorrytripMaxAggregateOutputType = {
    lorrytripid: string | null
    deliveryteamid: string | null
    warehouseteamid: string | null
    truckid: string | null
  }

  export type LorrytripCountAggregateOutputType = {
    lorrytripid: number
    deliveryteamid: number
    warehouseteamid: number
    truckid: number
    _all: number
  }


  export type LorrytripMinAggregateInputType = {
    lorrytripid?: true
    deliveryteamid?: true
    warehouseteamid?: true
    truckid?: true
  }

  export type LorrytripMaxAggregateInputType = {
    lorrytripid?: true
    deliveryteamid?: true
    warehouseteamid?: true
    truckid?: true
  }

  export type LorrytripCountAggregateInputType = {
    lorrytripid?: true
    deliveryteamid?: true
    warehouseteamid?: true
    truckid?: true
    _all?: true
  }

  export type LorrytripAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lorrytrip to aggregate.
     */
    where?: lorrytripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lorrytrips to fetch.
     */
    orderBy?: lorrytripOrderByWithRelationInput | lorrytripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lorrytripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lorrytrips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lorrytrips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lorrytrips
    **/
    _count?: true | LorrytripCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LorrytripMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LorrytripMaxAggregateInputType
  }

  export type GetLorrytripAggregateType<T extends LorrytripAggregateArgs> = {
        [P in keyof T & keyof AggregateLorrytrip]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLorrytrip[P]>
      : GetScalarType<T[P], AggregateLorrytrip[P]>
  }




  export type lorrytripGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lorrytripWhereInput
    orderBy?: lorrytripOrderByWithAggregationInput | lorrytripOrderByWithAggregationInput[]
    by: LorrytripScalarFieldEnum[] | LorrytripScalarFieldEnum
    having?: lorrytripScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LorrytripCountAggregateInputType | true
    _min?: LorrytripMinAggregateInputType
    _max?: LorrytripMaxAggregateInputType
  }

  export type LorrytripGroupByOutputType = {
    lorrytripid: string
    deliveryteamid: string | null
    warehouseteamid: string | null
    truckid: string | null
    _count: LorrytripCountAggregateOutputType | null
    _min: LorrytripMinAggregateOutputType | null
    _max: LorrytripMaxAggregateOutputType | null
  }

  type GetLorrytripGroupByPayload<T extends lorrytripGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LorrytripGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LorrytripGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LorrytripGroupByOutputType[P]>
            : GetScalarType<T[P], LorrytripGroupByOutputType[P]>
        }
      >
    >


  export type lorrytripSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lorrytripid?: boolean
    deliveryteamid?: boolean
    warehouseteamid?: boolean
    truckid?: boolean
    team_lorrytrip_deliveryteamidToteam?: boolean | lorrytrip$team_lorrytrip_deliveryteamidToteamArgs<ExtArgs>
    truck?: boolean | lorrytrip$truckArgs<ExtArgs>
    team_lorrytrip_warehouseteamidToteam?: boolean | lorrytrip$team_lorrytrip_warehouseteamidToteamArgs<ExtArgs>
    timeslot?: boolean | lorrytrip$timeslotArgs<ExtArgs>
    _count?: boolean | LorrytripCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lorrytrip"]>

  export type lorrytripSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lorrytripid?: boolean
    deliveryteamid?: boolean
    warehouseteamid?: boolean
    truckid?: boolean
    team_lorrytrip_deliveryteamidToteam?: boolean | lorrytrip$team_lorrytrip_deliveryteamidToteamArgs<ExtArgs>
    truck?: boolean | lorrytrip$truckArgs<ExtArgs>
    team_lorrytrip_warehouseteamidToteam?: boolean | lorrytrip$team_lorrytrip_warehouseteamidToteamArgs<ExtArgs>
  }, ExtArgs["result"]["lorrytrip"]>

  export type lorrytripSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lorrytripid?: boolean
    deliveryteamid?: boolean
    warehouseteamid?: boolean
    truckid?: boolean
    team_lorrytrip_deliveryteamidToteam?: boolean | lorrytrip$team_lorrytrip_deliveryteamidToteamArgs<ExtArgs>
    truck?: boolean | lorrytrip$truckArgs<ExtArgs>
    team_lorrytrip_warehouseteamidToteam?: boolean | lorrytrip$team_lorrytrip_warehouseteamidToteamArgs<ExtArgs>
  }, ExtArgs["result"]["lorrytrip"]>

  export type lorrytripSelectScalar = {
    lorrytripid?: boolean
    deliveryteamid?: boolean
    warehouseteamid?: boolean
    truckid?: boolean
  }

  export type lorrytripOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"lorrytripid" | "deliveryteamid" | "warehouseteamid" | "truckid", ExtArgs["result"]["lorrytrip"]>
  export type lorrytripInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team_lorrytrip_deliveryteamidToteam?: boolean | lorrytrip$team_lorrytrip_deliveryteamidToteamArgs<ExtArgs>
    truck?: boolean | lorrytrip$truckArgs<ExtArgs>
    team_lorrytrip_warehouseteamidToteam?: boolean | lorrytrip$team_lorrytrip_warehouseteamidToteamArgs<ExtArgs>
    timeslot?: boolean | lorrytrip$timeslotArgs<ExtArgs>
    _count?: boolean | LorrytripCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type lorrytripIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team_lorrytrip_deliveryteamidToteam?: boolean | lorrytrip$team_lorrytrip_deliveryteamidToteamArgs<ExtArgs>
    truck?: boolean | lorrytrip$truckArgs<ExtArgs>
    team_lorrytrip_warehouseteamidToteam?: boolean | lorrytrip$team_lorrytrip_warehouseteamidToteamArgs<ExtArgs>
  }
  export type lorrytripIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team_lorrytrip_deliveryteamidToteam?: boolean | lorrytrip$team_lorrytrip_deliveryteamidToteamArgs<ExtArgs>
    truck?: boolean | lorrytrip$truckArgs<ExtArgs>
    team_lorrytrip_warehouseteamidToteam?: boolean | lorrytrip$team_lorrytrip_warehouseteamidToteamArgs<ExtArgs>
  }

  export type $lorrytripPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lorrytrip"
    objects: {
      team_lorrytrip_deliveryteamidToteam: Prisma.$teamPayload<ExtArgs> | null
      truck: Prisma.$truckPayload<ExtArgs> | null
      team_lorrytrip_warehouseteamidToteam: Prisma.$teamPayload<ExtArgs> | null
      timeslot: Prisma.$timeslotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      lorrytripid: string
      deliveryteamid: string | null
      warehouseteamid: string | null
      truckid: string | null
    }, ExtArgs["result"]["lorrytrip"]>
    composites: {}
  }

  type lorrytripGetPayload<S extends boolean | null | undefined | lorrytripDefaultArgs> = $Result.GetResult<Prisma.$lorrytripPayload, S>

  type lorrytripCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<lorrytripFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LorrytripCountAggregateInputType | true
    }

  export interface lorrytripDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lorrytrip'], meta: { name: 'lorrytrip' } }
    /**
     * Find zero or one Lorrytrip that matches the filter.
     * @param {lorrytripFindUniqueArgs} args - Arguments to find a Lorrytrip
     * @example
     * // Get one Lorrytrip
     * const lorrytrip = await prisma.lorrytrip.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lorrytripFindUniqueArgs>(args: SelectSubset<T, lorrytripFindUniqueArgs<ExtArgs>>): Prisma__lorrytripClient<$Result.GetResult<Prisma.$lorrytripPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lorrytrip that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {lorrytripFindUniqueOrThrowArgs} args - Arguments to find a Lorrytrip
     * @example
     * // Get one Lorrytrip
     * const lorrytrip = await prisma.lorrytrip.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lorrytripFindUniqueOrThrowArgs>(args: SelectSubset<T, lorrytripFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lorrytripClient<$Result.GetResult<Prisma.$lorrytripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lorrytrip that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lorrytripFindFirstArgs} args - Arguments to find a Lorrytrip
     * @example
     * // Get one Lorrytrip
     * const lorrytrip = await prisma.lorrytrip.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lorrytripFindFirstArgs>(args?: SelectSubset<T, lorrytripFindFirstArgs<ExtArgs>>): Prisma__lorrytripClient<$Result.GetResult<Prisma.$lorrytripPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lorrytrip that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lorrytripFindFirstOrThrowArgs} args - Arguments to find a Lorrytrip
     * @example
     * // Get one Lorrytrip
     * const lorrytrip = await prisma.lorrytrip.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lorrytripFindFirstOrThrowArgs>(args?: SelectSubset<T, lorrytripFindFirstOrThrowArgs<ExtArgs>>): Prisma__lorrytripClient<$Result.GetResult<Prisma.$lorrytripPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lorrytrips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lorrytripFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lorrytrips
     * const lorrytrips = await prisma.lorrytrip.findMany()
     * 
     * // Get first 10 Lorrytrips
     * const lorrytrips = await prisma.lorrytrip.findMany({ take: 10 })
     * 
     * // Only select the `lorrytripid`
     * const lorrytripWithLorrytripidOnly = await prisma.lorrytrip.findMany({ select: { lorrytripid: true } })
     * 
     */
    findMany<T extends lorrytripFindManyArgs>(args?: SelectSubset<T, lorrytripFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lorrytripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lorrytrip.
     * @param {lorrytripCreateArgs} args - Arguments to create a Lorrytrip.
     * @example
     * // Create one Lorrytrip
     * const Lorrytrip = await prisma.lorrytrip.create({
     *   data: {
     *     // ... data to create a Lorrytrip
     *   }
     * })
     * 
     */
    create<T extends lorrytripCreateArgs>(args: SelectSubset<T, lorrytripCreateArgs<ExtArgs>>): Prisma__lorrytripClient<$Result.GetResult<Prisma.$lorrytripPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lorrytrips.
     * @param {lorrytripCreateManyArgs} args - Arguments to create many Lorrytrips.
     * @example
     * // Create many Lorrytrips
     * const lorrytrip = await prisma.lorrytrip.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lorrytripCreateManyArgs>(args?: SelectSubset<T, lorrytripCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lorrytrips and returns the data saved in the database.
     * @param {lorrytripCreateManyAndReturnArgs} args - Arguments to create many Lorrytrips.
     * @example
     * // Create many Lorrytrips
     * const lorrytrip = await prisma.lorrytrip.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lorrytrips and only return the `lorrytripid`
     * const lorrytripWithLorrytripidOnly = await prisma.lorrytrip.createManyAndReturn({
     *   select: { lorrytripid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends lorrytripCreateManyAndReturnArgs>(args?: SelectSubset<T, lorrytripCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lorrytripPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lorrytrip.
     * @param {lorrytripDeleteArgs} args - Arguments to delete one Lorrytrip.
     * @example
     * // Delete one Lorrytrip
     * const Lorrytrip = await prisma.lorrytrip.delete({
     *   where: {
     *     // ... filter to delete one Lorrytrip
     *   }
     * })
     * 
     */
    delete<T extends lorrytripDeleteArgs>(args: SelectSubset<T, lorrytripDeleteArgs<ExtArgs>>): Prisma__lorrytripClient<$Result.GetResult<Prisma.$lorrytripPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lorrytrip.
     * @param {lorrytripUpdateArgs} args - Arguments to update one Lorrytrip.
     * @example
     * // Update one Lorrytrip
     * const lorrytrip = await prisma.lorrytrip.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lorrytripUpdateArgs>(args: SelectSubset<T, lorrytripUpdateArgs<ExtArgs>>): Prisma__lorrytripClient<$Result.GetResult<Prisma.$lorrytripPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lorrytrips.
     * @param {lorrytripDeleteManyArgs} args - Arguments to filter Lorrytrips to delete.
     * @example
     * // Delete a few Lorrytrips
     * const { count } = await prisma.lorrytrip.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lorrytripDeleteManyArgs>(args?: SelectSubset<T, lorrytripDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lorrytrips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lorrytripUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lorrytrips
     * const lorrytrip = await prisma.lorrytrip.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lorrytripUpdateManyArgs>(args: SelectSubset<T, lorrytripUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lorrytrips and returns the data updated in the database.
     * @param {lorrytripUpdateManyAndReturnArgs} args - Arguments to update many Lorrytrips.
     * @example
     * // Update many Lorrytrips
     * const lorrytrip = await prisma.lorrytrip.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lorrytrips and only return the `lorrytripid`
     * const lorrytripWithLorrytripidOnly = await prisma.lorrytrip.updateManyAndReturn({
     *   select: { lorrytripid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends lorrytripUpdateManyAndReturnArgs>(args: SelectSubset<T, lorrytripUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lorrytripPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lorrytrip.
     * @param {lorrytripUpsertArgs} args - Arguments to update or create a Lorrytrip.
     * @example
     * // Update or create a Lorrytrip
     * const lorrytrip = await prisma.lorrytrip.upsert({
     *   create: {
     *     // ... data to create a Lorrytrip
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lorrytrip we want to update
     *   }
     * })
     */
    upsert<T extends lorrytripUpsertArgs>(args: SelectSubset<T, lorrytripUpsertArgs<ExtArgs>>): Prisma__lorrytripClient<$Result.GetResult<Prisma.$lorrytripPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lorrytrips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lorrytripCountArgs} args - Arguments to filter Lorrytrips to count.
     * @example
     * // Count the number of Lorrytrips
     * const count = await prisma.lorrytrip.count({
     *   where: {
     *     // ... the filter for the Lorrytrips we want to count
     *   }
     * })
    **/
    count<T extends lorrytripCountArgs>(
      args?: Subset<T, lorrytripCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LorrytripCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lorrytrip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LorrytripAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LorrytripAggregateArgs>(args: Subset<T, LorrytripAggregateArgs>): Prisma.PrismaPromise<GetLorrytripAggregateType<T>>

    /**
     * Group by Lorrytrip.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lorrytripGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lorrytripGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lorrytripGroupByArgs['orderBy'] }
        : { orderBy?: lorrytripGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lorrytripGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLorrytripGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lorrytrip model
   */
  readonly fields: lorrytripFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lorrytrip.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lorrytripClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team_lorrytrip_deliveryteamidToteam<T extends lorrytrip$team_lorrytrip_deliveryteamidToteamArgs<ExtArgs> = {}>(args?: Subset<T, lorrytrip$team_lorrytrip_deliveryteamidToteamArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    truck<T extends lorrytrip$truckArgs<ExtArgs> = {}>(args?: Subset<T, lorrytrip$truckArgs<ExtArgs>>): Prisma__truckClient<$Result.GetResult<Prisma.$truckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    team_lorrytrip_warehouseteamidToteam<T extends lorrytrip$team_lorrytrip_warehouseteamidToteamArgs<ExtArgs> = {}>(args?: Subset<T, lorrytrip$team_lorrytrip_warehouseteamidToteamArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    timeslot<T extends lorrytrip$timeslotArgs<ExtArgs> = {}>(args?: Subset<T, lorrytrip$timeslotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$timeslotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lorrytrip model
   */
  interface lorrytripFieldRefs {
    readonly lorrytripid: FieldRef<"lorrytrip", 'String'>
    readonly deliveryteamid: FieldRef<"lorrytrip", 'String'>
    readonly warehouseteamid: FieldRef<"lorrytrip", 'String'>
    readonly truckid: FieldRef<"lorrytrip", 'String'>
  }
    

  // Custom InputTypes
  /**
   * lorrytrip findUnique
   */
  export type lorrytripFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripInclude<ExtArgs> | null
    /**
     * Filter, which lorrytrip to fetch.
     */
    where: lorrytripWhereUniqueInput
  }

  /**
   * lorrytrip findUniqueOrThrow
   */
  export type lorrytripFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripInclude<ExtArgs> | null
    /**
     * Filter, which lorrytrip to fetch.
     */
    where: lorrytripWhereUniqueInput
  }

  /**
   * lorrytrip findFirst
   */
  export type lorrytripFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripInclude<ExtArgs> | null
    /**
     * Filter, which lorrytrip to fetch.
     */
    where?: lorrytripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lorrytrips to fetch.
     */
    orderBy?: lorrytripOrderByWithRelationInput | lorrytripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lorrytrips.
     */
    cursor?: lorrytripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lorrytrips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lorrytrips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lorrytrips.
     */
    distinct?: LorrytripScalarFieldEnum | LorrytripScalarFieldEnum[]
  }

  /**
   * lorrytrip findFirstOrThrow
   */
  export type lorrytripFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripInclude<ExtArgs> | null
    /**
     * Filter, which lorrytrip to fetch.
     */
    where?: lorrytripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lorrytrips to fetch.
     */
    orderBy?: lorrytripOrderByWithRelationInput | lorrytripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lorrytrips.
     */
    cursor?: lorrytripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lorrytrips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lorrytrips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lorrytrips.
     */
    distinct?: LorrytripScalarFieldEnum | LorrytripScalarFieldEnum[]
  }

  /**
   * lorrytrip findMany
   */
  export type lorrytripFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripInclude<ExtArgs> | null
    /**
     * Filter, which lorrytrips to fetch.
     */
    where?: lorrytripWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lorrytrips to fetch.
     */
    orderBy?: lorrytripOrderByWithRelationInput | lorrytripOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lorrytrips.
     */
    cursor?: lorrytripWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lorrytrips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lorrytrips.
     */
    skip?: number
    distinct?: LorrytripScalarFieldEnum | LorrytripScalarFieldEnum[]
  }

  /**
   * lorrytrip create
   */
  export type lorrytripCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripInclude<ExtArgs> | null
    /**
     * The data needed to create a lorrytrip.
     */
    data: XOR<lorrytripCreateInput, lorrytripUncheckedCreateInput>
  }

  /**
   * lorrytrip createMany
   */
  export type lorrytripCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lorrytrips.
     */
    data: lorrytripCreateManyInput | lorrytripCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lorrytrip createManyAndReturn
   */
  export type lorrytripCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * The data used to create many lorrytrips.
     */
    data: lorrytripCreateManyInput | lorrytripCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * lorrytrip update
   */
  export type lorrytripUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripInclude<ExtArgs> | null
    /**
     * The data needed to update a lorrytrip.
     */
    data: XOR<lorrytripUpdateInput, lorrytripUncheckedUpdateInput>
    /**
     * Choose, which lorrytrip to update.
     */
    where: lorrytripWhereUniqueInput
  }

  /**
   * lorrytrip updateMany
   */
  export type lorrytripUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lorrytrips.
     */
    data: XOR<lorrytripUpdateManyMutationInput, lorrytripUncheckedUpdateManyInput>
    /**
     * Filter which lorrytrips to update
     */
    where?: lorrytripWhereInput
    /**
     * Limit how many lorrytrips to update.
     */
    limit?: number
  }

  /**
   * lorrytrip updateManyAndReturn
   */
  export type lorrytripUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * The data used to update lorrytrips.
     */
    data: XOR<lorrytripUpdateManyMutationInput, lorrytripUncheckedUpdateManyInput>
    /**
     * Filter which lorrytrips to update
     */
    where?: lorrytripWhereInput
    /**
     * Limit how many lorrytrips to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * lorrytrip upsert
   */
  export type lorrytripUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripInclude<ExtArgs> | null
    /**
     * The filter to search for the lorrytrip to update in case it exists.
     */
    where: lorrytripWhereUniqueInput
    /**
     * In case the lorrytrip found by the `where` argument doesn't exist, create a new lorrytrip with this data.
     */
    create: XOR<lorrytripCreateInput, lorrytripUncheckedCreateInput>
    /**
     * In case the lorrytrip was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lorrytripUpdateInput, lorrytripUncheckedUpdateInput>
  }

  /**
   * lorrytrip delete
   */
  export type lorrytripDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripInclude<ExtArgs> | null
    /**
     * Filter which lorrytrip to delete.
     */
    where: lorrytripWhereUniqueInput
  }

  /**
   * lorrytrip deleteMany
   */
  export type lorrytripDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lorrytrips to delete
     */
    where?: lorrytripWhereInput
    /**
     * Limit how many lorrytrips to delete.
     */
    limit?: number
  }

  /**
   * lorrytrip.team_lorrytrip_deliveryteamidToteam
   */
  export type lorrytrip$team_lorrytrip_deliveryteamidToteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
  }

  /**
   * lorrytrip.truck
   */
  export type lorrytrip$truckArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truck
     */
    omit?: truckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckInclude<ExtArgs> | null
    where?: truckWhereInput
  }

  /**
   * lorrytrip.team_lorrytrip_warehouseteamidToteam
   */
  export type lorrytrip$team_lorrytrip_warehouseteamidToteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
  }

  /**
   * lorrytrip.timeslot
   */
  export type lorrytrip$timeslotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeslot
     */
    select?: timeslotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeslot
     */
    omit?: timeslotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: timeslotInclude<ExtArgs> | null
    where?: timeslotWhereInput
    orderBy?: timeslotOrderByWithRelationInput | timeslotOrderByWithRelationInput[]
    cursor?: timeslotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeslotScalarFieldEnum | TimeslotScalarFieldEnum[]
  }

  /**
   * lorrytrip without action
   */
  export type lorrytripDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripInclude<ExtArgs> | null
  }


  /**
   * Model orderproduct
   */

  export type AggregateOrderproduct = {
    _count: OrderproductCountAggregateOutputType | null
    _avg: OrderproductAvgAggregateOutputType | null
    _sum: OrderproductSumAggregateOutputType | null
    _min: OrderproductMinAggregateOutputType | null
    _max: OrderproductMaxAggregateOutputType | null
  }

  export type OrderproductAvgAggregateOutputType = {
    quantity: number | null
  }

  export type OrderproductSumAggregateOutputType = {
    quantity: number | null
  }

  export type OrderproductMinAggregateOutputType = {
    orderid: string | null
    productid: string | null
    quantity: number | null
  }

  export type OrderproductMaxAggregateOutputType = {
    orderid: string | null
    productid: string | null
    quantity: number | null
  }

  export type OrderproductCountAggregateOutputType = {
    orderid: number
    productid: number
    quantity: number
    _all: number
  }


  export type OrderproductAvgAggregateInputType = {
    quantity?: true
  }

  export type OrderproductSumAggregateInputType = {
    quantity?: true
  }

  export type OrderproductMinAggregateInputType = {
    orderid?: true
    productid?: true
    quantity?: true
  }

  export type OrderproductMaxAggregateInputType = {
    orderid?: true
    productid?: true
    quantity?: true
  }

  export type OrderproductCountAggregateInputType = {
    orderid?: true
    productid?: true
    quantity?: true
    _all?: true
  }

  export type OrderproductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderproduct to aggregate.
     */
    where?: orderproductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderproducts to fetch.
     */
    orderBy?: orderproductOrderByWithRelationInput | orderproductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orderproductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderproducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderproducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orderproducts
    **/
    _count?: true | OrderproductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderproductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderproductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderproductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderproductMaxAggregateInputType
  }

  export type GetOrderproductAggregateType<T extends OrderproductAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderproduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderproduct[P]>
      : GetScalarType<T[P], AggregateOrderproduct[P]>
  }




  export type orderproductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderproductWhereInput
    orderBy?: orderproductOrderByWithAggregationInput | orderproductOrderByWithAggregationInput[]
    by: OrderproductScalarFieldEnum[] | OrderproductScalarFieldEnum
    having?: orderproductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderproductCountAggregateInputType | true
    _avg?: OrderproductAvgAggregateInputType
    _sum?: OrderproductSumAggregateInputType
    _min?: OrderproductMinAggregateInputType
    _max?: OrderproductMaxAggregateInputType
  }

  export type OrderproductGroupByOutputType = {
    orderid: string
    productid: string
    quantity: number | null
    _count: OrderproductCountAggregateOutputType | null
    _avg: OrderproductAvgAggregateOutputType | null
    _sum: OrderproductSumAggregateOutputType | null
    _min: OrderproductMinAggregateOutputType | null
    _max: OrderproductMaxAggregateOutputType | null
  }

  type GetOrderproductGroupByPayload<T extends orderproductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderproductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderproductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderproductGroupByOutputType[P]>
            : GetScalarType<T[P], OrderproductGroupByOutputType[P]>
        }
      >
    >


  export type orderproductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderid?: boolean
    productid?: boolean
    quantity?: boolean
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderproduct"]>

  export type orderproductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderid?: boolean
    productid?: boolean
    quantity?: boolean
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderproduct"]>

  export type orderproductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderid?: boolean
    productid?: boolean
    quantity?: boolean
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderproduct"]>

  export type orderproductSelectScalar = {
    orderid?: boolean
    productid?: boolean
    quantity?: boolean
  }

  export type orderproductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"orderid" | "productid" | "quantity", ExtArgs["result"]["orderproduct"]>
  export type orderproductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }
  export type orderproductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }
  export type orderproductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ordersDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }

  export type $orderproductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "orderproduct"
    objects: {
      orders: Prisma.$ordersPayload<ExtArgs>
      product: Prisma.$productPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      orderid: string
      productid: string
      quantity: number | null
    }, ExtArgs["result"]["orderproduct"]>
    composites: {}
  }

  type orderproductGetPayload<S extends boolean | null | undefined | orderproductDefaultArgs> = $Result.GetResult<Prisma.$orderproductPayload, S>

  type orderproductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<orderproductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderproductCountAggregateInputType | true
    }

  export interface orderproductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['orderproduct'], meta: { name: 'orderproduct' } }
    /**
     * Find zero or one Orderproduct that matches the filter.
     * @param {orderproductFindUniqueArgs} args - Arguments to find a Orderproduct
     * @example
     * // Get one Orderproduct
     * const orderproduct = await prisma.orderproduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends orderproductFindUniqueArgs>(args: SelectSubset<T, orderproductFindUniqueArgs<ExtArgs>>): Prisma__orderproductClient<$Result.GetResult<Prisma.$orderproductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Orderproduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {orderproductFindUniqueOrThrowArgs} args - Arguments to find a Orderproduct
     * @example
     * // Get one Orderproduct
     * const orderproduct = await prisma.orderproduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends orderproductFindUniqueOrThrowArgs>(args: SelectSubset<T, orderproductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__orderproductClient<$Result.GetResult<Prisma.$orderproductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orderproduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderproductFindFirstArgs} args - Arguments to find a Orderproduct
     * @example
     * // Get one Orderproduct
     * const orderproduct = await prisma.orderproduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends orderproductFindFirstArgs>(args?: SelectSubset<T, orderproductFindFirstArgs<ExtArgs>>): Prisma__orderproductClient<$Result.GetResult<Prisma.$orderproductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orderproduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderproductFindFirstOrThrowArgs} args - Arguments to find a Orderproduct
     * @example
     * // Get one Orderproduct
     * const orderproduct = await prisma.orderproduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends orderproductFindFirstOrThrowArgs>(args?: SelectSubset<T, orderproductFindFirstOrThrowArgs<ExtArgs>>): Prisma__orderproductClient<$Result.GetResult<Prisma.$orderproductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orderproducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderproductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orderproducts
     * const orderproducts = await prisma.orderproduct.findMany()
     * 
     * // Get first 10 Orderproducts
     * const orderproducts = await prisma.orderproduct.findMany({ take: 10 })
     * 
     * // Only select the `orderid`
     * const orderproductWithOrderidOnly = await prisma.orderproduct.findMany({ select: { orderid: true } })
     * 
     */
    findMany<T extends orderproductFindManyArgs>(args?: SelectSubset<T, orderproductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderproductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Orderproduct.
     * @param {orderproductCreateArgs} args - Arguments to create a Orderproduct.
     * @example
     * // Create one Orderproduct
     * const Orderproduct = await prisma.orderproduct.create({
     *   data: {
     *     // ... data to create a Orderproduct
     *   }
     * })
     * 
     */
    create<T extends orderproductCreateArgs>(args: SelectSubset<T, orderproductCreateArgs<ExtArgs>>): Prisma__orderproductClient<$Result.GetResult<Prisma.$orderproductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orderproducts.
     * @param {orderproductCreateManyArgs} args - Arguments to create many Orderproducts.
     * @example
     * // Create many Orderproducts
     * const orderproduct = await prisma.orderproduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends orderproductCreateManyArgs>(args?: SelectSubset<T, orderproductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orderproducts and returns the data saved in the database.
     * @param {orderproductCreateManyAndReturnArgs} args - Arguments to create many Orderproducts.
     * @example
     * // Create many Orderproducts
     * const orderproduct = await prisma.orderproduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orderproducts and only return the `orderid`
     * const orderproductWithOrderidOnly = await prisma.orderproduct.createManyAndReturn({
     *   select: { orderid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends orderproductCreateManyAndReturnArgs>(args?: SelectSubset<T, orderproductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderproductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Orderproduct.
     * @param {orderproductDeleteArgs} args - Arguments to delete one Orderproduct.
     * @example
     * // Delete one Orderproduct
     * const Orderproduct = await prisma.orderproduct.delete({
     *   where: {
     *     // ... filter to delete one Orderproduct
     *   }
     * })
     * 
     */
    delete<T extends orderproductDeleteArgs>(args: SelectSubset<T, orderproductDeleteArgs<ExtArgs>>): Prisma__orderproductClient<$Result.GetResult<Prisma.$orderproductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Orderproduct.
     * @param {orderproductUpdateArgs} args - Arguments to update one Orderproduct.
     * @example
     * // Update one Orderproduct
     * const orderproduct = await prisma.orderproduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends orderproductUpdateArgs>(args: SelectSubset<T, orderproductUpdateArgs<ExtArgs>>): Prisma__orderproductClient<$Result.GetResult<Prisma.$orderproductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orderproducts.
     * @param {orderproductDeleteManyArgs} args - Arguments to filter Orderproducts to delete.
     * @example
     * // Delete a few Orderproducts
     * const { count } = await prisma.orderproduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends orderproductDeleteManyArgs>(args?: SelectSubset<T, orderproductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orderproducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderproductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orderproducts
     * const orderproduct = await prisma.orderproduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends orderproductUpdateManyArgs>(args: SelectSubset<T, orderproductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orderproducts and returns the data updated in the database.
     * @param {orderproductUpdateManyAndReturnArgs} args - Arguments to update many Orderproducts.
     * @example
     * // Update many Orderproducts
     * const orderproduct = await prisma.orderproduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orderproducts and only return the `orderid`
     * const orderproductWithOrderidOnly = await prisma.orderproduct.updateManyAndReturn({
     *   select: { orderid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends orderproductUpdateManyAndReturnArgs>(args: SelectSubset<T, orderproductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderproductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Orderproduct.
     * @param {orderproductUpsertArgs} args - Arguments to update or create a Orderproduct.
     * @example
     * // Update or create a Orderproduct
     * const orderproduct = await prisma.orderproduct.upsert({
     *   create: {
     *     // ... data to create a Orderproduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orderproduct we want to update
     *   }
     * })
     */
    upsert<T extends orderproductUpsertArgs>(args: SelectSubset<T, orderproductUpsertArgs<ExtArgs>>): Prisma__orderproductClient<$Result.GetResult<Prisma.$orderproductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orderproducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderproductCountArgs} args - Arguments to filter Orderproducts to count.
     * @example
     * // Count the number of Orderproducts
     * const count = await prisma.orderproduct.count({
     *   where: {
     *     // ... the filter for the Orderproducts we want to count
     *   }
     * })
    **/
    count<T extends orderproductCountArgs>(
      args?: Subset<T, orderproductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderproductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orderproduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderproductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderproductAggregateArgs>(args: Subset<T, OrderproductAggregateArgs>): Prisma.PrismaPromise<GetOrderproductAggregateType<T>>

    /**
     * Group by Orderproduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderproductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends orderproductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: orderproductGroupByArgs['orderBy'] }
        : { orderBy?: orderproductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, orderproductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderproductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the orderproduct model
   */
  readonly fields: orderproductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for orderproduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__orderproductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends ordersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ordersDefaultArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the orderproduct model
   */
  interface orderproductFieldRefs {
    readonly orderid: FieldRef<"orderproduct", 'String'>
    readonly productid: FieldRef<"orderproduct", 'String'>
    readonly quantity: FieldRef<"orderproduct", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * orderproduct findUnique
   */
  export type orderproductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderproduct
     */
    select?: orderproductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orderproduct
     */
    omit?: orderproductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderproductInclude<ExtArgs> | null
    /**
     * Filter, which orderproduct to fetch.
     */
    where: orderproductWhereUniqueInput
  }

  /**
   * orderproduct findUniqueOrThrow
   */
  export type orderproductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderproduct
     */
    select?: orderproductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orderproduct
     */
    omit?: orderproductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderproductInclude<ExtArgs> | null
    /**
     * Filter, which orderproduct to fetch.
     */
    where: orderproductWhereUniqueInput
  }

  /**
   * orderproduct findFirst
   */
  export type orderproductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderproduct
     */
    select?: orderproductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orderproduct
     */
    omit?: orderproductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderproductInclude<ExtArgs> | null
    /**
     * Filter, which orderproduct to fetch.
     */
    where?: orderproductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderproducts to fetch.
     */
    orderBy?: orderproductOrderByWithRelationInput | orderproductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderproducts.
     */
    cursor?: orderproductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderproducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderproducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderproducts.
     */
    distinct?: OrderproductScalarFieldEnum | OrderproductScalarFieldEnum[]
  }

  /**
   * orderproduct findFirstOrThrow
   */
  export type orderproductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderproduct
     */
    select?: orderproductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orderproduct
     */
    omit?: orderproductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderproductInclude<ExtArgs> | null
    /**
     * Filter, which orderproduct to fetch.
     */
    where?: orderproductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderproducts to fetch.
     */
    orderBy?: orderproductOrderByWithRelationInput | orderproductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orderproducts.
     */
    cursor?: orderproductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderproducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderproducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orderproducts.
     */
    distinct?: OrderproductScalarFieldEnum | OrderproductScalarFieldEnum[]
  }

  /**
   * orderproduct findMany
   */
  export type orderproductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderproduct
     */
    select?: orderproductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orderproduct
     */
    omit?: orderproductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderproductInclude<ExtArgs> | null
    /**
     * Filter, which orderproducts to fetch.
     */
    where?: orderproductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orderproducts to fetch.
     */
    orderBy?: orderproductOrderByWithRelationInput | orderproductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orderproducts.
     */
    cursor?: orderproductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orderproducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orderproducts.
     */
    skip?: number
    distinct?: OrderproductScalarFieldEnum | OrderproductScalarFieldEnum[]
  }

  /**
   * orderproduct create
   */
  export type orderproductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderproduct
     */
    select?: orderproductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orderproduct
     */
    omit?: orderproductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderproductInclude<ExtArgs> | null
    /**
     * The data needed to create a orderproduct.
     */
    data: XOR<orderproductCreateInput, orderproductUncheckedCreateInput>
  }

  /**
   * orderproduct createMany
   */
  export type orderproductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orderproducts.
     */
    data: orderproductCreateManyInput | orderproductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * orderproduct createManyAndReturn
   */
  export type orderproductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderproduct
     */
    select?: orderproductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the orderproduct
     */
    omit?: orderproductOmit<ExtArgs> | null
    /**
     * The data used to create many orderproducts.
     */
    data: orderproductCreateManyInput | orderproductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderproductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * orderproduct update
   */
  export type orderproductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderproduct
     */
    select?: orderproductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orderproduct
     */
    omit?: orderproductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderproductInclude<ExtArgs> | null
    /**
     * The data needed to update a orderproduct.
     */
    data: XOR<orderproductUpdateInput, orderproductUncheckedUpdateInput>
    /**
     * Choose, which orderproduct to update.
     */
    where: orderproductWhereUniqueInput
  }

  /**
   * orderproduct updateMany
   */
  export type orderproductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orderproducts.
     */
    data: XOR<orderproductUpdateManyMutationInput, orderproductUncheckedUpdateManyInput>
    /**
     * Filter which orderproducts to update
     */
    where?: orderproductWhereInput
    /**
     * Limit how many orderproducts to update.
     */
    limit?: number
  }

  /**
   * orderproduct updateManyAndReturn
   */
  export type orderproductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderproduct
     */
    select?: orderproductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the orderproduct
     */
    omit?: orderproductOmit<ExtArgs> | null
    /**
     * The data used to update orderproducts.
     */
    data: XOR<orderproductUpdateManyMutationInput, orderproductUncheckedUpdateManyInput>
    /**
     * Filter which orderproducts to update
     */
    where?: orderproductWhereInput
    /**
     * Limit how many orderproducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderproductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * orderproduct upsert
   */
  export type orderproductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderproduct
     */
    select?: orderproductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orderproduct
     */
    omit?: orderproductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderproductInclude<ExtArgs> | null
    /**
     * The filter to search for the orderproduct to update in case it exists.
     */
    where: orderproductWhereUniqueInput
    /**
     * In case the orderproduct found by the `where` argument doesn't exist, create a new orderproduct with this data.
     */
    create: XOR<orderproductCreateInput, orderproductUncheckedCreateInput>
    /**
     * In case the orderproduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orderproductUpdateInput, orderproductUncheckedUpdateInput>
  }

  /**
   * orderproduct delete
   */
  export type orderproductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderproduct
     */
    select?: orderproductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orderproduct
     */
    omit?: orderproductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderproductInclude<ExtArgs> | null
    /**
     * Filter which orderproduct to delete.
     */
    where: orderproductWhereUniqueInput
  }

  /**
   * orderproduct deleteMany
   */
  export type orderproductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orderproducts to delete
     */
    where?: orderproductWhereInput
    /**
     * Limit how many orderproducts to delete.
     */
    limit?: number
  }

  /**
   * orderproduct without action
   */
  export type orderproductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderproduct
     */
    select?: orderproductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orderproduct
     */
    omit?: orderproductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderproductInclude<ExtArgs> | null
  }


  /**
   * Model orders
   */

  export type AggregateOrders = {
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  export type OrdersAvgAggregateOutputType = {
    numberofattempts: number | null
    customerrating: Decimal | null
  }

  export type OrdersSumAggregateOutputType = {
    numberofattempts: number | null
    customerrating: Decimal | null
  }

  export type OrdersMinAggregateOutputType = {
    orderid: string | null
    customerid: string | null
    employeeid: string | null
    deliveryteamid: string | null
    buildingid: string | null
    timeslotid: string | null
    numberofattempts: number | null
    scheduledstartdatetime: Date | null
    scheduledenddatetime: Date | null
    actualstartdatetime: Date | null
    actualenddatetime: Date | null
    actualarrivaldatetime: Date | null
    customerrating: Decimal | null
    delayreason: string | null
    customerfeedback: string | null
    proofofdeliveryurl: string | null
    orderstatus: string | null
    updatedat: Date | null
    createdat: Date | null
  }

  export type OrdersMaxAggregateOutputType = {
    orderid: string | null
    customerid: string | null
    employeeid: string | null
    deliveryteamid: string | null
    buildingid: string | null
    timeslotid: string | null
    numberofattempts: number | null
    scheduledstartdatetime: Date | null
    scheduledenddatetime: Date | null
    actualstartdatetime: Date | null
    actualenddatetime: Date | null
    actualarrivaldatetime: Date | null
    customerrating: Decimal | null
    delayreason: string | null
    customerfeedback: string | null
    proofofdeliveryurl: string | null
    orderstatus: string | null
    updatedat: Date | null
    createdat: Date | null
  }

  export type OrdersCountAggregateOutputType = {
    orderid: number
    customerid: number
    employeeid: number
    deliveryteamid: number
    buildingid: number
    timeslotid: number
    numberofattempts: number
    scheduledstartdatetime: number
    scheduledenddatetime: number
    actualstartdatetime: number
    actualenddatetime: number
    actualarrivaldatetime: number
    customerrating: number
    delayreason: number
    customerfeedback: number
    proofofdeliveryurl: number
    orderstatus: number
    updatedat: number
    createdat: number
    _all: number
  }


  export type OrdersAvgAggregateInputType = {
    numberofattempts?: true
    customerrating?: true
  }

  export type OrdersSumAggregateInputType = {
    numberofattempts?: true
    customerrating?: true
  }

  export type OrdersMinAggregateInputType = {
    orderid?: true
    customerid?: true
    employeeid?: true
    deliveryteamid?: true
    buildingid?: true
    timeslotid?: true
    numberofattempts?: true
    scheduledstartdatetime?: true
    scheduledenddatetime?: true
    actualstartdatetime?: true
    actualenddatetime?: true
    actualarrivaldatetime?: true
    customerrating?: true
    delayreason?: true
    customerfeedback?: true
    proofofdeliveryurl?: true
    orderstatus?: true
    updatedat?: true
    createdat?: true
  }

  export type OrdersMaxAggregateInputType = {
    orderid?: true
    customerid?: true
    employeeid?: true
    deliveryteamid?: true
    buildingid?: true
    timeslotid?: true
    numberofattempts?: true
    scheduledstartdatetime?: true
    scheduledenddatetime?: true
    actualstartdatetime?: true
    actualenddatetime?: true
    actualarrivaldatetime?: true
    customerrating?: true
    delayreason?: true
    customerfeedback?: true
    proofofdeliveryurl?: true
    orderstatus?: true
    updatedat?: true
    createdat?: true
  }

  export type OrdersCountAggregateInputType = {
    orderid?: true
    customerid?: true
    employeeid?: true
    deliveryteamid?: true
    buildingid?: true
    timeslotid?: true
    numberofattempts?: true
    scheduledstartdatetime?: true
    scheduledenddatetime?: true
    actualstartdatetime?: true
    actualenddatetime?: true
    actualarrivaldatetime?: true
    customerrating?: true
    delayreason?: true
    customerfeedback?: true
    proofofdeliveryurl?: true
    orderstatus?: true
    updatedat?: true
    createdat?: true
    _all?: true
  }

  export type OrdersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orders to aggregate.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orders
    **/
    _count?: true | OrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdersMaxAggregateInputType
  }

  export type GetOrdersAggregateType<T extends OrdersAggregateArgs> = {
        [P in keyof T & keyof AggregateOrders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrders[P]>
      : GetScalarType<T[P], AggregateOrders[P]>
  }




  export type ordersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithAggregationInput | ordersOrderByWithAggregationInput[]
    by: OrdersScalarFieldEnum[] | OrdersScalarFieldEnum
    having?: ordersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdersCountAggregateInputType | true
    _avg?: OrdersAvgAggregateInputType
    _sum?: OrdersSumAggregateInputType
    _min?: OrdersMinAggregateInputType
    _max?: OrdersMaxAggregateInputType
  }

  export type OrdersGroupByOutputType = {
    orderid: string
    customerid: string | null
    employeeid: string | null
    deliveryteamid: string | null
    buildingid: string | null
    timeslotid: string | null
    numberofattempts: number | null
    scheduledstartdatetime: Date | null
    scheduledenddatetime: Date | null
    actualstartdatetime: Date | null
    actualenddatetime: Date | null
    actualarrivaldatetime: Date | null
    customerrating: Decimal | null
    delayreason: string | null
    customerfeedback: string | null
    proofofdeliveryurl: string | null
    orderstatus: string | null
    updatedat: Date | null
    createdat: Date | null
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  type GetOrdersGroupByPayload<T extends ordersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdersGroupByOutputType[P]>
            : GetScalarType<T[P], OrdersGroupByOutputType[P]>
        }
      >
    >


  export type ordersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderid?: boolean
    customerid?: boolean
    employeeid?: boolean
    deliveryteamid?: boolean
    buildingid?: boolean
    timeslotid?: boolean
    numberofattempts?: boolean
    scheduledstartdatetime?: boolean
    scheduledenddatetime?: boolean
    actualstartdatetime?: boolean
    actualenddatetime?: boolean
    actualarrivaldatetime?: boolean
    customerrating?: boolean
    delayreason?: boolean
    customerfeedback?: boolean
    proofofdeliveryurl?: boolean
    orderstatus?: boolean
    updatedat?: boolean
    createdat?: boolean
    orderproduct?: boolean | orders$orderproductArgs<ExtArgs>
    building?: boolean | orders$buildingArgs<ExtArgs>
    customer?: boolean | orders$customerArgs<ExtArgs>
    team?: boolean | orders$teamArgs<ExtArgs>
    employee?: boolean | orders$employeeArgs<ExtArgs>
    timeslot?: boolean | orders$timeslotArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type ordersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderid?: boolean
    customerid?: boolean
    employeeid?: boolean
    deliveryteamid?: boolean
    buildingid?: boolean
    timeslotid?: boolean
    numberofattempts?: boolean
    scheduledstartdatetime?: boolean
    scheduledenddatetime?: boolean
    actualstartdatetime?: boolean
    actualenddatetime?: boolean
    actualarrivaldatetime?: boolean
    customerrating?: boolean
    delayreason?: boolean
    customerfeedback?: boolean
    proofofdeliveryurl?: boolean
    orderstatus?: boolean
    updatedat?: boolean
    createdat?: boolean
    building?: boolean | orders$buildingArgs<ExtArgs>
    customer?: boolean | orders$customerArgs<ExtArgs>
    team?: boolean | orders$teamArgs<ExtArgs>
    employee?: boolean | orders$employeeArgs<ExtArgs>
    timeslot?: boolean | orders$timeslotArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type ordersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    orderid?: boolean
    customerid?: boolean
    employeeid?: boolean
    deliveryteamid?: boolean
    buildingid?: boolean
    timeslotid?: boolean
    numberofattempts?: boolean
    scheduledstartdatetime?: boolean
    scheduledenddatetime?: boolean
    actualstartdatetime?: boolean
    actualenddatetime?: boolean
    actualarrivaldatetime?: boolean
    customerrating?: boolean
    delayreason?: boolean
    customerfeedback?: boolean
    proofofdeliveryurl?: boolean
    orderstatus?: boolean
    updatedat?: boolean
    createdat?: boolean
    building?: boolean | orders$buildingArgs<ExtArgs>
    customer?: boolean | orders$customerArgs<ExtArgs>
    team?: boolean | orders$teamArgs<ExtArgs>
    employee?: boolean | orders$employeeArgs<ExtArgs>
    timeslot?: boolean | orders$timeslotArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type ordersSelectScalar = {
    orderid?: boolean
    customerid?: boolean
    employeeid?: boolean
    deliveryteamid?: boolean
    buildingid?: boolean
    timeslotid?: boolean
    numberofattempts?: boolean
    scheduledstartdatetime?: boolean
    scheduledenddatetime?: boolean
    actualstartdatetime?: boolean
    actualenddatetime?: boolean
    actualarrivaldatetime?: boolean
    customerrating?: boolean
    delayreason?: boolean
    customerfeedback?: boolean
    proofofdeliveryurl?: boolean
    orderstatus?: boolean
    updatedat?: boolean
    createdat?: boolean
  }

  export type ordersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"orderid" | "customerid" | "employeeid" | "deliveryteamid" | "buildingid" | "timeslotid" | "numberofattempts" | "scheduledstartdatetime" | "scheduledenddatetime" | "actualstartdatetime" | "actualenddatetime" | "actualarrivaldatetime" | "customerrating" | "delayreason" | "customerfeedback" | "proofofdeliveryurl" | "orderstatus" | "updatedat" | "createdat", ExtArgs["result"]["orders"]>
  export type ordersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderproduct?: boolean | orders$orderproductArgs<ExtArgs>
    building?: boolean | orders$buildingArgs<ExtArgs>
    customer?: boolean | orders$customerArgs<ExtArgs>
    team?: boolean | orders$teamArgs<ExtArgs>
    employee?: boolean | orders$employeeArgs<ExtArgs>
    timeslot?: boolean | orders$timeslotArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ordersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    building?: boolean | orders$buildingArgs<ExtArgs>
    customer?: boolean | orders$customerArgs<ExtArgs>
    team?: boolean | orders$teamArgs<ExtArgs>
    employee?: boolean | orders$employeeArgs<ExtArgs>
    timeslot?: boolean | orders$timeslotArgs<ExtArgs>
  }
  export type ordersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    building?: boolean | orders$buildingArgs<ExtArgs>
    customer?: boolean | orders$customerArgs<ExtArgs>
    team?: boolean | orders$teamArgs<ExtArgs>
    employee?: boolean | orders$employeeArgs<ExtArgs>
    timeslot?: boolean | orders$timeslotArgs<ExtArgs>
  }

  export type $ordersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "orders"
    objects: {
      orderproduct: Prisma.$orderproductPayload<ExtArgs>[]
      building: Prisma.$buildingPayload<ExtArgs> | null
      customer: Prisma.$customerPayload<ExtArgs> | null
      team: Prisma.$teamPayload<ExtArgs> | null
      employee: Prisma.$employeePayload<ExtArgs> | null
      timeslot: Prisma.$timeslotPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      orderid: string
      customerid: string | null
      employeeid: string | null
      deliveryteamid: string | null
      buildingid: string | null
      timeslotid: string | null
      numberofattempts: number | null
      scheduledstartdatetime: Date | null
      scheduledenddatetime: Date | null
      actualstartdatetime: Date | null
      actualenddatetime: Date | null
      actualarrivaldatetime: Date | null
      customerrating: Prisma.Decimal | null
      delayreason: string | null
      customerfeedback: string | null
      proofofdeliveryurl: string | null
      orderstatus: string | null
      updatedat: Date | null
      createdat: Date | null
    }, ExtArgs["result"]["orders"]>
    composites: {}
  }

  type ordersGetPayload<S extends boolean | null | undefined | ordersDefaultArgs> = $Result.GetResult<Prisma.$ordersPayload, S>

  type ordersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ordersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrdersCountAggregateInputType | true
    }

  export interface ordersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['orders'], meta: { name: 'orders' } }
    /**
     * Find zero or one Orders that matches the filter.
     * @param {ordersFindUniqueArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ordersFindUniqueArgs>(args: SelectSubset<T, ordersFindUniqueArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Orders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ordersFindUniqueOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ordersFindUniqueOrThrowArgs>(args: SelectSubset<T, ordersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindFirstArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ordersFindFirstArgs>(args?: SelectSubset<T, ordersFindFirstArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Orders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindFirstOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ordersFindFirstOrThrowArgs>(args?: SelectSubset<T, ordersFindFirstOrThrowArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.orders.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.orders.findMany({ take: 10 })
     * 
     * // Only select the `orderid`
     * const ordersWithOrderidOnly = await prisma.orders.findMany({ select: { orderid: true } })
     * 
     */
    findMany<T extends ordersFindManyArgs>(args?: SelectSubset<T, ordersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Orders.
     * @param {ordersCreateArgs} args - Arguments to create a Orders.
     * @example
     * // Create one Orders
     * const Orders = await prisma.orders.create({
     *   data: {
     *     // ... data to create a Orders
     *   }
     * })
     * 
     */
    create<T extends ordersCreateArgs>(args: SelectSubset<T, ordersCreateArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {ordersCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ordersCreateManyArgs>(args?: SelectSubset<T, ordersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {ordersCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `orderid`
     * const ordersWithOrderidOnly = await prisma.orders.createManyAndReturn({
     *   select: { orderid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ordersCreateManyAndReturnArgs>(args?: SelectSubset<T, ordersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Orders.
     * @param {ordersDeleteArgs} args - Arguments to delete one Orders.
     * @example
     * // Delete one Orders
     * const Orders = await prisma.orders.delete({
     *   where: {
     *     // ... filter to delete one Orders
     *   }
     * })
     * 
     */
    delete<T extends ordersDeleteArgs>(args: SelectSubset<T, ordersDeleteArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Orders.
     * @param {ordersUpdateArgs} args - Arguments to update one Orders.
     * @example
     * // Update one Orders
     * const orders = await prisma.orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ordersUpdateArgs>(args: SelectSubset<T, ordersUpdateArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {ordersDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ordersDeleteManyArgs>(args?: SelectSubset<T, ordersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ordersUpdateManyArgs>(args: SelectSubset<T, ordersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {ordersUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `orderid`
     * const ordersWithOrderidOnly = await prisma.orders.updateManyAndReturn({
     *   select: { orderid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ordersUpdateManyAndReturnArgs>(args: SelectSubset<T, ordersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Orders.
     * @param {ordersUpsertArgs} args - Arguments to update or create a Orders.
     * @example
     * // Update or create a Orders
     * const orders = await prisma.orders.upsert({
     *   create: {
     *     // ... data to create a Orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orders we want to update
     *   }
     * })
     */
    upsert<T extends ordersUpsertArgs>(args: SelectSubset<T, ordersUpsertArgs<ExtArgs>>): Prisma__ordersClient<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.orders.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends ordersCountArgs>(
      args?: Subset<T, ordersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdersAggregateArgs>(args: Subset<T, OrdersAggregateArgs>): Prisma.PrismaPromise<GetOrdersAggregateType<T>>

    /**
     * Group by Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ordersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ordersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ordersGroupByArgs['orderBy'] }
        : { orderBy?: ordersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ordersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the orders model
   */
  readonly fields: ordersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ordersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderproduct<T extends orders$orderproductArgs<ExtArgs> = {}>(args?: Subset<T, orders$orderproductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderproductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    building<T extends orders$buildingArgs<ExtArgs> = {}>(args?: Subset<T, orders$buildingArgs<ExtArgs>>): Prisma__buildingClient<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends orders$customerArgs<ExtArgs> = {}>(args?: Subset<T, orders$customerArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    team<T extends orders$teamArgs<ExtArgs> = {}>(args?: Subset<T, orders$teamArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employee<T extends orders$employeeArgs<ExtArgs> = {}>(args?: Subset<T, orders$employeeArgs<ExtArgs>>): Prisma__employeeClient<$Result.GetResult<Prisma.$employeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    timeslot<T extends orders$timeslotArgs<ExtArgs> = {}>(args?: Subset<T, orders$timeslotArgs<ExtArgs>>): Prisma__timeslotClient<$Result.GetResult<Prisma.$timeslotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the orders model
   */
  interface ordersFieldRefs {
    readonly orderid: FieldRef<"orders", 'String'>
    readonly customerid: FieldRef<"orders", 'String'>
    readonly employeeid: FieldRef<"orders", 'String'>
    readonly deliveryteamid: FieldRef<"orders", 'String'>
    readonly buildingid: FieldRef<"orders", 'String'>
    readonly timeslotid: FieldRef<"orders", 'String'>
    readonly numberofattempts: FieldRef<"orders", 'Int'>
    readonly scheduledstartdatetime: FieldRef<"orders", 'DateTime'>
    readonly scheduledenddatetime: FieldRef<"orders", 'DateTime'>
    readonly actualstartdatetime: FieldRef<"orders", 'DateTime'>
    readonly actualenddatetime: FieldRef<"orders", 'DateTime'>
    readonly actualarrivaldatetime: FieldRef<"orders", 'DateTime'>
    readonly customerrating: FieldRef<"orders", 'Decimal'>
    readonly delayreason: FieldRef<"orders", 'String'>
    readonly customerfeedback: FieldRef<"orders", 'String'>
    readonly proofofdeliveryurl: FieldRef<"orders", 'String'>
    readonly orderstatus: FieldRef<"orders", 'String'>
    readonly updatedat: FieldRef<"orders", 'DateTime'>
    readonly createdat: FieldRef<"orders", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * orders findUnique
   */
  export type ordersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders findUniqueOrThrow
   */
  export type ordersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders findFirst
   */
  export type ordersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * orders findFirstOrThrow
   */
  export type ordersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * orders findMany
   */
  export type ordersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orders.
     */
    cursor?: ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * orders create
   */
  export type ordersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * The data needed to create a orders.
     */
    data: XOR<ordersCreateInput, ordersUncheckedCreateInput>
  }

  /**
   * orders createMany
   */
  export type ordersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orders.
     */
    data: ordersCreateManyInput | ordersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * orders createManyAndReturn
   */
  export type ordersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * The data used to create many orders.
     */
    data: ordersCreateManyInput | ordersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * orders update
   */
  export type ordersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * The data needed to update a orders.
     */
    data: XOR<ordersUpdateInput, ordersUncheckedUpdateInput>
    /**
     * Choose, which orders to update.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders updateMany
   */
  export type ordersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orders.
     */
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: ordersWhereInput
    /**
     * Limit how many orders to update.
     */
    limit?: number
  }

  /**
   * orders updateManyAndReturn
   */
  export type ordersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * The data used to update orders.
     */
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: ordersWhereInput
    /**
     * Limit how many orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * orders upsert
   */
  export type ordersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * The filter to search for the orders to update in case it exists.
     */
    where: ordersWhereUniqueInput
    /**
     * In case the orders found by the `where` argument doesn't exist, create a new orders with this data.
     */
    create: XOR<ordersCreateInput, ordersUncheckedCreateInput>
    /**
     * In case the orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ordersUpdateInput, ordersUncheckedUpdateInput>
  }

  /**
   * orders delete
   */
  export type ordersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    /**
     * Filter which orders to delete.
     */
    where: ordersWhereUniqueInput
  }

  /**
   * orders deleteMany
   */
  export type ordersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orders to delete
     */
    where?: ordersWhereInput
    /**
     * Limit how many orders to delete.
     */
    limit?: number
  }

  /**
   * orders.orderproduct
   */
  export type orders$orderproductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderproduct
     */
    select?: orderproductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orderproduct
     */
    omit?: orderproductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderproductInclude<ExtArgs> | null
    where?: orderproductWhereInput
    orderBy?: orderproductOrderByWithRelationInput | orderproductOrderByWithRelationInput[]
    cursor?: orderproductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderproductScalarFieldEnum | OrderproductScalarFieldEnum[]
  }

  /**
   * orders.building
   */
  export type orders$buildingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    where?: buildingWhereInput
  }

  /**
   * orders.customer
   */
  export type orders$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    where?: customerWhereInput
  }

  /**
   * orders.team
   */
  export type orders$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
  }

  /**
   * orders.employee
   */
  export type orders$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employee
     */
    select?: employeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employee
     */
    omit?: employeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeInclude<ExtArgs> | null
    where?: employeeWhereInput
  }

  /**
   * orders.timeslot
   */
  export type orders$timeslotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeslot
     */
    select?: timeslotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeslot
     */
    omit?: timeslotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: timeslotInclude<ExtArgs> | null
    where?: timeslotWhereInput
  }

  /**
   * orders without action
   */
  export type ordersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
  }


  /**
   * Model product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    packagelengthcm: number | null
    packagewidthcm: number | null
    packageheightcm: number | null
    dismantleextratime: number | null
    estimatedinstallationtimemin: number | null
    estimatedinstallationtimemax: number | null
  }

  export type ProductSumAggregateOutputType = {
    packagelengthcm: number | null
    packagewidthcm: number | null
    packageheightcm: number | null
    dismantleextratime: number | null
    estimatedinstallationtimemin: number | null
    estimatedinstallationtimemax: number | null
  }

  export type ProductMinAggregateOutputType = {
    productid: string | null
    productname: string | null
    packagelengthcm: number | null
    packagewidthcm: number | null
    packageheightcm: number | null
    installerteamrequiredflag: boolean | null
    dismantlerequiredflag: boolean | null
    dismantleextratime: number | null
    estimatedinstallationtimemin: number | null
    estimatedinstallationtimemax: number | null
    fragileflag: boolean | null
    noliedownflag: boolean | null
  }

  export type ProductMaxAggregateOutputType = {
    productid: string | null
    productname: string | null
    packagelengthcm: number | null
    packagewidthcm: number | null
    packageheightcm: number | null
    installerteamrequiredflag: boolean | null
    dismantlerequiredflag: boolean | null
    dismantleextratime: number | null
    estimatedinstallationtimemin: number | null
    estimatedinstallationtimemax: number | null
    fragileflag: boolean | null
    noliedownflag: boolean | null
  }

  export type ProductCountAggregateOutputType = {
    productid: number
    productname: number
    packagelengthcm: number
    packagewidthcm: number
    packageheightcm: number
    installerteamrequiredflag: number
    dismantlerequiredflag: number
    dismantleextratime: number
    estimatedinstallationtimemin: number
    estimatedinstallationtimemax: number
    fragileflag: number
    noliedownflag: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    packagelengthcm?: true
    packagewidthcm?: true
    packageheightcm?: true
    dismantleextratime?: true
    estimatedinstallationtimemin?: true
    estimatedinstallationtimemax?: true
  }

  export type ProductSumAggregateInputType = {
    packagelengthcm?: true
    packagewidthcm?: true
    packageheightcm?: true
    dismantleextratime?: true
    estimatedinstallationtimemin?: true
    estimatedinstallationtimemax?: true
  }

  export type ProductMinAggregateInputType = {
    productid?: true
    productname?: true
    packagelengthcm?: true
    packagewidthcm?: true
    packageheightcm?: true
    installerteamrequiredflag?: true
    dismantlerequiredflag?: true
    dismantleextratime?: true
    estimatedinstallationtimemin?: true
    estimatedinstallationtimemax?: true
    fragileflag?: true
    noliedownflag?: true
  }

  export type ProductMaxAggregateInputType = {
    productid?: true
    productname?: true
    packagelengthcm?: true
    packagewidthcm?: true
    packageheightcm?: true
    installerteamrequiredflag?: true
    dismantlerequiredflag?: true
    dismantleextratime?: true
    estimatedinstallationtimemin?: true
    estimatedinstallationtimemax?: true
    fragileflag?: true
    noliedownflag?: true
  }

  export type ProductCountAggregateInputType = {
    productid?: true
    productname?: true
    packagelengthcm?: true
    packagewidthcm?: true
    packageheightcm?: true
    installerteamrequiredflag?: true
    dismantlerequiredflag?: true
    dismantleextratime?: true
    estimatedinstallationtimemin?: true
    estimatedinstallationtimemax?: true
    fragileflag?: true
    noliedownflag?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product to aggregate.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type productGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
    orderBy?: productOrderByWithAggregationInput | productOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    productid: string
    productname: string | null
    packagelengthcm: number | null
    packagewidthcm: number | null
    packageheightcm: number | null
    installerteamrequiredflag: boolean | null
    dismantlerequiredflag: boolean | null
    dismantleextratime: number | null
    estimatedinstallationtimemin: number | null
    estimatedinstallationtimemax: number | null
    fragileflag: boolean | null
    noliedownflag: boolean | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type productSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productid?: boolean
    productname?: boolean
    packagelengthcm?: boolean
    packagewidthcm?: boolean
    packageheightcm?: boolean
    installerteamrequiredflag?: boolean
    dismantlerequiredflag?: boolean
    dismantleextratime?: boolean
    estimatedinstallationtimemin?: boolean
    estimatedinstallationtimemax?: boolean
    fragileflag?: boolean
    noliedownflag?: boolean
    orderproduct?: boolean | product$orderproductArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type productSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productid?: boolean
    productname?: boolean
    packagelengthcm?: boolean
    packagewidthcm?: boolean
    packageheightcm?: boolean
    installerteamrequiredflag?: boolean
    dismantlerequiredflag?: boolean
    dismantleextratime?: boolean
    estimatedinstallationtimemin?: boolean
    estimatedinstallationtimemax?: boolean
    fragileflag?: boolean
    noliedownflag?: boolean
  }, ExtArgs["result"]["product"]>

  export type productSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productid?: boolean
    productname?: boolean
    packagelengthcm?: boolean
    packagewidthcm?: boolean
    packageheightcm?: boolean
    installerteamrequiredflag?: boolean
    dismantlerequiredflag?: boolean
    dismantleextratime?: boolean
    estimatedinstallationtimemin?: boolean
    estimatedinstallationtimemax?: boolean
    fragileflag?: boolean
    noliedownflag?: boolean
  }, ExtArgs["result"]["product"]>

  export type productSelectScalar = {
    productid?: boolean
    productname?: boolean
    packagelengthcm?: boolean
    packagewidthcm?: boolean
    packageheightcm?: boolean
    installerteamrequiredflag?: boolean
    dismantlerequiredflag?: boolean
    dismantleextratime?: boolean
    estimatedinstallationtimemin?: boolean
    estimatedinstallationtimemax?: boolean
    fragileflag?: boolean
    noliedownflag?: boolean
  }

  export type productOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"productid" | "productname" | "packagelengthcm" | "packagewidthcm" | "packageheightcm" | "installerteamrequiredflag" | "dismantlerequiredflag" | "dismantleextratime" | "estimatedinstallationtimemin" | "estimatedinstallationtimemax" | "fragileflag" | "noliedownflag", ExtArgs["result"]["product"]>
  export type productInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderproduct?: boolean | product$orderproductArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type productIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type productIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $productPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product"
    objects: {
      orderproduct: Prisma.$orderproductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      productid: string
      productname: string | null
      packagelengthcm: number | null
      packagewidthcm: number | null
      packageheightcm: number | null
      installerteamrequiredflag: boolean | null
      dismantlerequiredflag: boolean | null
      dismantleextratime: number | null
      estimatedinstallationtimemin: number | null
      estimatedinstallationtimemax: number | null
      fragileflag: boolean | null
      noliedownflag: boolean | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type productGetPayload<S extends boolean | null | undefined | productDefaultArgs> = $Result.GetResult<Prisma.$productPayload, S>

  type productCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<productFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface productDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product'], meta: { name: 'product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {productFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productFindUniqueArgs>(args: SelectSubset<T, productFindUniqueArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {productFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productFindUniqueOrThrowArgs>(args: SelectSubset<T, productFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productFindFirstArgs>(args?: SelectSubset<T, productFindFirstArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productFindFirstOrThrowArgs>(args?: SelectSubset<T, productFindFirstOrThrowArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `productid`
     * const productWithProductidOnly = await prisma.product.findMany({ select: { productid: true } })
     * 
     */
    findMany<T extends productFindManyArgs>(args?: SelectSubset<T, productFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {productCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends productCreateArgs>(args: SelectSubset<T, productCreateArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {productCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productCreateManyArgs>(args?: SelectSubset<T, productCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {productCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `productid`
     * const productWithProductidOnly = await prisma.product.createManyAndReturn({
     *   select: { productid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends productCreateManyAndReturnArgs>(args?: SelectSubset<T, productCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {productDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends productDeleteArgs>(args: SelectSubset<T, productDeleteArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {productUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productUpdateArgs>(args: SelectSubset<T, productUpdateArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {productDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productDeleteManyArgs>(args?: SelectSubset<T, productDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productUpdateManyArgs>(args: SelectSubset<T, productUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {productUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `productid`
     * const productWithProductidOnly = await prisma.product.updateManyAndReturn({
     *   select: { productid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends productUpdateManyAndReturnArgs>(args: SelectSubset<T, productUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {productUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends productUpsertArgs>(args: SelectSubset<T, productUpsertArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productCountArgs>(
      args?: Subset<T, productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productGroupByArgs['orderBy'] }
        : { orderBy?: productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product model
   */
  readonly fields: productFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderproduct<T extends product$orderproductArgs<ExtArgs> = {}>(args?: Subset<T, product$orderproductArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderproductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the product model
   */
  interface productFieldRefs {
    readonly productid: FieldRef<"product", 'String'>
    readonly productname: FieldRef<"product", 'String'>
    readonly packagelengthcm: FieldRef<"product", 'Int'>
    readonly packagewidthcm: FieldRef<"product", 'Int'>
    readonly packageheightcm: FieldRef<"product", 'Int'>
    readonly installerteamrequiredflag: FieldRef<"product", 'Boolean'>
    readonly dismantlerequiredflag: FieldRef<"product", 'Boolean'>
    readonly dismantleextratime: FieldRef<"product", 'Int'>
    readonly estimatedinstallationtimemin: FieldRef<"product", 'Int'>
    readonly estimatedinstallationtimemax: FieldRef<"product", 'Int'>
    readonly fragileflag: FieldRef<"product", 'Boolean'>
    readonly noliedownflag: FieldRef<"product", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * product findUnique
   */
  export type productFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }

  /**
   * product findUniqueOrThrow
   */
  export type productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }

  /**
   * product findFirst
   */
  export type productFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * product findFirstOrThrow
   */
  export type productFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * product findMany
   */
  export type productFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * product create
   */
  export type productCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to create a product.
     */
    data: XOR<productCreateInput, productUncheckedCreateInput>
  }

  /**
   * product createMany
   */
  export type productCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productCreateManyInput | productCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * product createManyAndReturn
   */
  export type productCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * The data used to create many products.
     */
    data: productCreateManyInput | productCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * product update
   */
  export type productUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to update a product.
     */
    data: XOR<productUpdateInput, productUncheckedUpdateInput>
    /**
     * Choose, which product to update.
     */
    where: productWhereUniqueInput
  }

  /**
   * product updateMany
   */
  export type productUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
  }

  /**
   * product updateManyAndReturn
   */
  export type productUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
  }

  /**
   * product upsert
   */
  export type productUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The filter to search for the product to update in case it exists.
     */
    where: productWhereUniqueInput
    /**
     * In case the product found by the `where` argument doesn't exist, create a new product with this data.
     */
    create: XOR<productCreateInput, productUncheckedCreateInput>
    /**
     * In case the product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productUpdateInput, productUncheckedUpdateInput>
  }

  /**
   * product delete
   */
  export type productDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter which product to delete.
     */
    where: productWhereUniqueInput
  }

  /**
   * product deleteMany
   */
  export type productDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productWhereInput
    /**
     * Limit how many products to delete.
     */
    limit?: number
  }

  /**
   * product.orderproduct
   */
  export type product$orderproductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orderproduct
     */
    select?: orderproductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orderproduct
     */
    omit?: orderproductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: orderproductInclude<ExtArgs> | null
    where?: orderproductWhereInput
    orderBy?: orderproductOrderByWithRelationInput | orderproductOrderByWithRelationInput[]
    cursor?: orderproductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderproductScalarFieldEnum | OrderproductScalarFieldEnum[]
  }

  /**
   * product without action
   */
  export type productDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Omit specific fields from the product
     */
    omit?: productOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productInclude<ExtArgs> | null
  }


  /**
   * Model team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    teamid: string | null
    teamtype: string | null
  }

  export type TeamMaxAggregateOutputType = {
    teamid: string | null
    teamtype: string | null
  }

  export type TeamCountAggregateOutputType = {
    teamid: number
    teamtype: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    teamid?: true
    teamtype?: true
  }

  export type TeamMaxAggregateInputType = {
    teamid?: true
    teamtype?: true
  }

  export type TeamCountAggregateInputType = {
    teamid?: true
    teamtype?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team to aggregate.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type teamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamWhereInput
    orderBy?: teamOrderByWithAggregationInput | teamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: teamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    teamid: string
    teamtype: string | null
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends teamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type teamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teamid?: boolean
    teamtype?: boolean
    employeeteamassignment?: boolean | team$employeeteamassignmentArgs<ExtArgs>
    lorrytrip_lorrytrip_deliveryteamidToteam?: boolean | team$lorrytrip_lorrytrip_deliveryteamidToteamArgs<ExtArgs>
    lorrytrip_lorrytrip_warehouseteamidToteam?: boolean | team$lorrytrip_lorrytrip_warehouseteamidToteamArgs<ExtArgs>
    orders?: boolean | team$ordersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type teamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teamid?: boolean
    teamtype?: boolean
  }, ExtArgs["result"]["team"]>

  export type teamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teamid?: boolean
    teamtype?: boolean
  }, ExtArgs["result"]["team"]>

  export type teamSelectScalar = {
    teamid?: boolean
    teamtype?: boolean
  }

  export type teamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"teamid" | "teamtype", ExtArgs["result"]["team"]>
  export type teamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeteamassignment?: boolean | team$employeeteamassignmentArgs<ExtArgs>
    lorrytrip_lorrytrip_deliveryteamidToteam?: boolean | team$lorrytrip_lorrytrip_deliveryteamidToteamArgs<ExtArgs>
    lorrytrip_lorrytrip_warehouseteamidToteam?: boolean | team$lorrytrip_lorrytrip_warehouseteamidToteamArgs<ExtArgs>
    orders?: boolean | team$ordersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type teamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type teamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $teamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "team"
    objects: {
      employeeteamassignment: Prisma.$employeeteamassignmentPayload<ExtArgs>[]
      lorrytrip_lorrytrip_deliveryteamidToteam: Prisma.$lorrytripPayload<ExtArgs>[]
      lorrytrip_lorrytrip_warehouseteamidToteam: Prisma.$lorrytripPayload<ExtArgs>[]
      orders: Prisma.$ordersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      teamid: string
      teamtype: string | null
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type teamGetPayload<S extends boolean | null | undefined | teamDefaultArgs> = $Result.GetResult<Prisma.$teamPayload, S>

  type teamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface teamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team'], meta: { name: 'team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {teamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teamFindUniqueArgs>(args: SelectSubset<T, teamFindUniqueArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teamFindUniqueOrThrowArgs>(args: SelectSubset<T, teamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teamFindFirstArgs>(args?: SelectSubset<T, teamFindFirstArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teamFindFirstOrThrowArgs>(args?: SelectSubset<T, teamFindFirstOrThrowArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `teamid`
     * const teamWithTeamidOnly = await prisma.team.findMany({ select: { teamid: true } })
     * 
     */
    findMany<T extends teamFindManyArgs>(args?: SelectSubset<T, teamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {teamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends teamCreateArgs>(args: SelectSubset<T, teamCreateArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {teamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teamCreateManyArgs>(args?: SelectSubset<T, teamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {teamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `teamid`
     * const teamWithTeamidOnly = await prisma.team.createManyAndReturn({
     *   select: { teamid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends teamCreateManyAndReturnArgs>(args?: SelectSubset<T, teamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {teamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends teamDeleteArgs>(args: SelectSubset<T, teamDeleteArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {teamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teamUpdateArgs>(args: SelectSubset<T, teamUpdateArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {teamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teamDeleteManyArgs>(args?: SelectSubset<T, teamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teamUpdateManyArgs>(args: SelectSubset<T, teamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {teamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `teamid`
     * const teamWithTeamidOnly = await prisma.team.updateManyAndReturn({
     *   select: { teamid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends teamUpdateManyAndReturnArgs>(args: SelectSubset<T, teamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {teamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends teamUpsertArgs>(args: SelectSubset<T, teamUpsertArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends teamCountArgs>(
      args?: Subset<T, teamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teamGroupByArgs['orderBy'] }
        : { orderBy?: teamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team model
   */
  readonly fields: teamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employeeteamassignment<T extends team$employeeteamassignmentArgs<ExtArgs> = {}>(args?: Subset<T, team$employeeteamassignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeeteamassignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lorrytrip_lorrytrip_deliveryteamidToteam<T extends team$lorrytrip_lorrytrip_deliveryteamidToteamArgs<ExtArgs> = {}>(args?: Subset<T, team$lorrytrip_lorrytrip_deliveryteamidToteamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lorrytripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lorrytrip_lorrytrip_warehouseteamidToteam<T extends team$lorrytrip_lorrytrip_warehouseteamidToteamArgs<ExtArgs> = {}>(args?: Subset<T, team$lorrytrip_lorrytrip_warehouseteamidToteamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lorrytripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends team$ordersArgs<ExtArgs> = {}>(args?: Subset<T, team$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the team model
   */
  interface teamFieldRefs {
    readonly teamid: FieldRef<"team", 'String'>
    readonly teamtype: FieldRef<"team", 'String'>
  }
    

  // Custom InputTypes
  /**
   * team findUnique
   */
  export type teamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }

  /**
   * team findUniqueOrThrow
   */
  export type teamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }

  /**
   * team findFirst
   */
  export type teamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * team findFirstOrThrow
   */
  export type teamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * team findMany
   */
  export type teamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which teams to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * team create
   */
  export type teamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The data needed to create a team.
     */
    data: XOR<teamCreateInput, teamUncheckedCreateInput>
  }

  /**
   * team createMany
   */
  export type teamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teams.
     */
    data: teamCreateManyInput | teamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * team createManyAndReturn
   */
  export type teamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * The data used to create many teams.
     */
    data: teamCreateManyInput | teamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * team update
   */
  export type teamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The data needed to update a team.
     */
    data: XOR<teamUpdateInput, teamUncheckedUpdateInput>
    /**
     * Choose, which team to update.
     */
    where: teamWhereUniqueInput
  }

  /**
   * team updateMany
   */
  export type teamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teams.
     */
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyInput>
    /**
     * Filter which teams to update
     */
    where?: teamWhereInput
    /**
     * Limit how many teams to update.
     */
    limit?: number
  }

  /**
   * team updateManyAndReturn
   */
  export type teamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * The data used to update teams.
     */
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyInput>
    /**
     * Filter which teams to update
     */
    where?: teamWhereInput
    /**
     * Limit how many teams to update.
     */
    limit?: number
  }

  /**
   * team upsert
   */
  export type teamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The filter to search for the team to update in case it exists.
     */
    where: teamWhereUniqueInput
    /**
     * In case the team found by the `where` argument doesn't exist, create a new team with this data.
     */
    create: XOR<teamCreateInput, teamUncheckedCreateInput>
    /**
     * In case the team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teamUpdateInput, teamUncheckedUpdateInput>
  }

  /**
   * team delete
   */
  export type teamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter which team to delete.
     */
    where: teamWhereUniqueInput
  }

  /**
   * team deleteMany
   */
  export type teamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teams to delete
     */
    where?: teamWhereInput
    /**
     * Limit how many teams to delete.
     */
    limit?: number
  }

  /**
   * team.employeeteamassignment
   */
  export type team$employeeteamassignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employeeteamassignment
     */
    select?: employeeteamassignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employeeteamassignment
     */
    omit?: employeeteamassignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeeteamassignmentInclude<ExtArgs> | null
    where?: employeeteamassignmentWhereInput
    orderBy?: employeeteamassignmentOrderByWithRelationInput | employeeteamassignmentOrderByWithRelationInput[]
    cursor?: employeeteamassignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeteamassignmentScalarFieldEnum | EmployeeteamassignmentScalarFieldEnum[]
  }

  /**
   * team.lorrytrip_lorrytrip_deliveryteamidToteam
   */
  export type team$lorrytrip_lorrytrip_deliveryteamidToteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripInclude<ExtArgs> | null
    where?: lorrytripWhereInput
    orderBy?: lorrytripOrderByWithRelationInput | lorrytripOrderByWithRelationInput[]
    cursor?: lorrytripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LorrytripScalarFieldEnum | LorrytripScalarFieldEnum[]
  }

  /**
   * team.lorrytrip_lorrytrip_warehouseteamidToteam
   */
  export type team$lorrytrip_lorrytrip_warehouseteamidToteamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripInclude<ExtArgs> | null
    where?: lorrytripWhereInput
    orderBy?: lorrytripOrderByWithRelationInput | lorrytripOrderByWithRelationInput[]
    cursor?: lorrytripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LorrytripScalarFieldEnum | LorrytripScalarFieldEnum[]
  }

  /**
   * team.orders
   */
  export type team$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    cursor?: ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * team without action
   */
  export type teamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the team
     */
    omit?: teamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
  }


  /**
   * Model timeslot
   */

  export type AggregateTimeslot = {
    _count: TimeslotCountAggregateOutputType | null
    _min: TimeslotMinAggregateOutputType | null
    _max: TimeslotMaxAggregateOutputType | null
  }

  export type TimeslotMinAggregateOutputType = {
    timeslotid: string | null
    lorrytripid: string | null
    date: Date | null
    timewindowstart: Date | null
    timewindowend: Date | null
    availableflag: boolean | null
  }

  export type TimeslotMaxAggregateOutputType = {
    timeslotid: string | null
    lorrytripid: string | null
    date: Date | null
    timewindowstart: Date | null
    timewindowend: Date | null
    availableflag: boolean | null
  }

  export type TimeslotCountAggregateOutputType = {
    timeslotid: number
    lorrytripid: number
    date: number
    timewindowstart: number
    timewindowend: number
    availableflag: number
    _all: number
  }


  export type TimeslotMinAggregateInputType = {
    timeslotid?: true
    lorrytripid?: true
    date?: true
    timewindowstart?: true
    timewindowend?: true
    availableflag?: true
  }

  export type TimeslotMaxAggregateInputType = {
    timeslotid?: true
    lorrytripid?: true
    date?: true
    timewindowstart?: true
    timewindowend?: true
    availableflag?: true
  }

  export type TimeslotCountAggregateInputType = {
    timeslotid?: true
    lorrytripid?: true
    date?: true
    timewindowstart?: true
    timewindowend?: true
    availableflag?: true
    _all?: true
  }

  export type TimeslotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which timeslot to aggregate.
     */
    where?: timeslotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of timeslots to fetch.
     */
    orderBy?: timeslotOrderByWithRelationInput | timeslotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: timeslotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` timeslots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` timeslots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned timeslots
    **/
    _count?: true | TimeslotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeslotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeslotMaxAggregateInputType
  }

  export type GetTimeslotAggregateType<T extends TimeslotAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeslot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeslot[P]>
      : GetScalarType<T[P], AggregateTimeslot[P]>
  }




  export type timeslotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: timeslotWhereInput
    orderBy?: timeslotOrderByWithAggregationInput | timeslotOrderByWithAggregationInput[]
    by: TimeslotScalarFieldEnum[] | TimeslotScalarFieldEnum
    having?: timeslotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeslotCountAggregateInputType | true
    _min?: TimeslotMinAggregateInputType
    _max?: TimeslotMaxAggregateInputType
  }

  export type TimeslotGroupByOutputType = {
    timeslotid: string
    lorrytripid: string | null
    date: Date | null
    timewindowstart: Date | null
    timewindowend: Date | null
    availableflag: boolean | null
    _count: TimeslotCountAggregateOutputType | null
    _min: TimeslotMinAggregateOutputType | null
    _max: TimeslotMaxAggregateOutputType | null
  }

  type GetTimeslotGroupByPayload<T extends timeslotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeslotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeslotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeslotGroupByOutputType[P]>
            : GetScalarType<T[P], TimeslotGroupByOutputType[P]>
        }
      >
    >


  export type timeslotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    timeslotid?: boolean
    lorrytripid?: boolean
    date?: boolean
    timewindowstart?: boolean
    timewindowend?: boolean
    availableflag?: boolean
    orders?: boolean | timeslot$ordersArgs<ExtArgs>
    lorrytrip?: boolean | timeslot$lorrytripArgs<ExtArgs>
    _count?: boolean | TimeslotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeslot"]>

  export type timeslotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    timeslotid?: boolean
    lorrytripid?: boolean
    date?: boolean
    timewindowstart?: boolean
    timewindowend?: boolean
    availableflag?: boolean
    lorrytrip?: boolean | timeslot$lorrytripArgs<ExtArgs>
  }, ExtArgs["result"]["timeslot"]>

  export type timeslotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    timeslotid?: boolean
    lorrytripid?: boolean
    date?: boolean
    timewindowstart?: boolean
    timewindowend?: boolean
    availableflag?: boolean
    lorrytrip?: boolean | timeslot$lorrytripArgs<ExtArgs>
  }, ExtArgs["result"]["timeslot"]>

  export type timeslotSelectScalar = {
    timeslotid?: boolean
    lorrytripid?: boolean
    date?: boolean
    timewindowstart?: boolean
    timewindowend?: boolean
    availableflag?: boolean
  }

  export type timeslotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"timeslotid" | "lorrytripid" | "date" | "timewindowstart" | "timewindowend" | "availableflag", ExtArgs["result"]["timeslot"]>
  export type timeslotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | timeslot$ordersArgs<ExtArgs>
    lorrytrip?: boolean | timeslot$lorrytripArgs<ExtArgs>
    _count?: boolean | TimeslotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type timeslotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lorrytrip?: boolean | timeslot$lorrytripArgs<ExtArgs>
  }
  export type timeslotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lorrytrip?: boolean | timeslot$lorrytripArgs<ExtArgs>
  }

  export type $timeslotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "timeslot"
    objects: {
      orders: Prisma.$ordersPayload<ExtArgs>[]
      lorrytrip: Prisma.$lorrytripPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      timeslotid: string
      lorrytripid: string | null
      date: Date | null
      timewindowstart: Date | null
      timewindowend: Date | null
      availableflag: boolean | null
    }, ExtArgs["result"]["timeslot"]>
    composites: {}
  }

  type timeslotGetPayload<S extends boolean | null | undefined | timeslotDefaultArgs> = $Result.GetResult<Prisma.$timeslotPayload, S>

  type timeslotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<timeslotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeslotCountAggregateInputType | true
    }

  export interface timeslotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['timeslot'], meta: { name: 'timeslot' } }
    /**
     * Find zero or one Timeslot that matches the filter.
     * @param {timeslotFindUniqueArgs} args - Arguments to find a Timeslot
     * @example
     * // Get one Timeslot
     * const timeslot = await prisma.timeslot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends timeslotFindUniqueArgs>(args: SelectSubset<T, timeslotFindUniqueArgs<ExtArgs>>): Prisma__timeslotClient<$Result.GetResult<Prisma.$timeslotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Timeslot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {timeslotFindUniqueOrThrowArgs} args - Arguments to find a Timeslot
     * @example
     * // Get one Timeslot
     * const timeslot = await prisma.timeslot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends timeslotFindUniqueOrThrowArgs>(args: SelectSubset<T, timeslotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__timeslotClient<$Result.GetResult<Prisma.$timeslotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Timeslot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeslotFindFirstArgs} args - Arguments to find a Timeslot
     * @example
     * // Get one Timeslot
     * const timeslot = await prisma.timeslot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends timeslotFindFirstArgs>(args?: SelectSubset<T, timeslotFindFirstArgs<ExtArgs>>): Prisma__timeslotClient<$Result.GetResult<Prisma.$timeslotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Timeslot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeslotFindFirstOrThrowArgs} args - Arguments to find a Timeslot
     * @example
     * // Get one Timeslot
     * const timeslot = await prisma.timeslot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends timeslotFindFirstOrThrowArgs>(args?: SelectSubset<T, timeslotFindFirstOrThrowArgs<ExtArgs>>): Prisma__timeslotClient<$Result.GetResult<Prisma.$timeslotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Timeslots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeslotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Timeslots
     * const timeslots = await prisma.timeslot.findMany()
     * 
     * // Get first 10 Timeslots
     * const timeslots = await prisma.timeslot.findMany({ take: 10 })
     * 
     * // Only select the `timeslotid`
     * const timeslotWithTimeslotidOnly = await prisma.timeslot.findMany({ select: { timeslotid: true } })
     * 
     */
    findMany<T extends timeslotFindManyArgs>(args?: SelectSubset<T, timeslotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$timeslotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Timeslot.
     * @param {timeslotCreateArgs} args - Arguments to create a Timeslot.
     * @example
     * // Create one Timeslot
     * const Timeslot = await prisma.timeslot.create({
     *   data: {
     *     // ... data to create a Timeslot
     *   }
     * })
     * 
     */
    create<T extends timeslotCreateArgs>(args: SelectSubset<T, timeslotCreateArgs<ExtArgs>>): Prisma__timeslotClient<$Result.GetResult<Prisma.$timeslotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Timeslots.
     * @param {timeslotCreateManyArgs} args - Arguments to create many Timeslots.
     * @example
     * // Create many Timeslots
     * const timeslot = await prisma.timeslot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends timeslotCreateManyArgs>(args?: SelectSubset<T, timeslotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Timeslots and returns the data saved in the database.
     * @param {timeslotCreateManyAndReturnArgs} args - Arguments to create many Timeslots.
     * @example
     * // Create many Timeslots
     * const timeslot = await prisma.timeslot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Timeslots and only return the `timeslotid`
     * const timeslotWithTimeslotidOnly = await prisma.timeslot.createManyAndReturn({
     *   select: { timeslotid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends timeslotCreateManyAndReturnArgs>(args?: SelectSubset<T, timeslotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$timeslotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Timeslot.
     * @param {timeslotDeleteArgs} args - Arguments to delete one Timeslot.
     * @example
     * // Delete one Timeslot
     * const Timeslot = await prisma.timeslot.delete({
     *   where: {
     *     // ... filter to delete one Timeslot
     *   }
     * })
     * 
     */
    delete<T extends timeslotDeleteArgs>(args: SelectSubset<T, timeslotDeleteArgs<ExtArgs>>): Prisma__timeslotClient<$Result.GetResult<Prisma.$timeslotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Timeslot.
     * @param {timeslotUpdateArgs} args - Arguments to update one Timeslot.
     * @example
     * // Update one Timeslot
     * const timeslot = await prisma.timeslot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends timeslotUpdateArgs>(args: SelectSubset<T, timeslotUpdateArgs<ExtArgs>>): Prisma__timeslotClient<$Result.GetResult<Prisma.$timeslotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Timeslots.
     * @param {timeslotDeleteManyArgs} args - Arguments to filter Timeslots to delete.
     * @example
     * // Delete a few Timeslots
     * const { count } = await prisma.timeslot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends timeslotDeleteManyArgs>(args?: SelectSubset<T, timeslotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Timeslots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeslotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Timeslots
     * const timeslot = await prisma.timeslot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends timeslotUpdateManyArgs>(args: SelectSubset<T, timeslotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Timeslots and returns the data updated in the database.
     * @param {timeslotUpdateManyAndReturnArgs} args - Arguments to update many Timeslots.
     * @example
     * // Update many Timeslots
     * const timeslot = await prisma.timeslot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Timeslots and only return the `timeslotid`
     * const timeslotWithTimeslotidOnly = await prisma.timeslot.updateManyAndReturn({
     *   select: { timeslotid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends timeslotUpdateManyAndReturnArgs>(args: SelectSubset<T, timeslotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$timeslotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Timeslot.
     * @param {timeslotUpsertArgs} args - Arguments to update or create a Timeslot.
     * @example
     * // Update or create a Timeslot
     * const timeslot = await prisma.timeslot.upsert({
     *   create: {
     *     // ... data to create a Timeslot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Timeslot we want to update
     *   }
     * })
     */
    upsert<T extends timeslotUpsertArgs>(args: SelectSubset<T, timeslotUpsertArgs<ExtArgs>>): Prisma__timeslotClient<$Result.GetResult<Prisma.$timeslotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Timeslots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeslotCountArgs} args - Arguments to filter Timeslots to count.
     * @example
     * // Count the number of Timeslots
     * const count = await prisma.timeslot.count({
     *   where: {
     *     // ... the filter for the Timeslots we want to count
     *   }
     * })
    **/
    count<T extends timeslotCountArgs>(
      args?: Subset<T, timeslotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeslotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Timeslot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeslotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeslotAggregateArgs>(args: Subset<T, TimeslotAggregateArgs>): Prisma.PrismaPromise<GetTimeslotAggregateType<T>>

    /**
     * Group by Timeslot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {timeslotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends timeslotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: timeslotGroupByArgs['orderBy'] }
        : { orderBy?: timeslotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, timeslotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeslotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the timeslot model
   */
  readonly fields: timeslotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for timeslot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__timeslotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends timeslot$ordersArgs<ExtArgs> = {}>(args?: Subset<T, timeslot$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lorrytrip<T extends timeslot$lorrytripArgs<ExtArgs> = {}>(args?: Subset<T, timeslot$lorrytripArgs<ExtArgs>>): Prisma__lorrytripClient<$Result.GetResult<Prisma.$lorrytripPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the timeslot model
   */
  interface timeslotFieldRefs {
    readonly timeslotid: FieldRef<"timeslot", 'String'>
    readonly lorrytripid: FieldRef<"timeslot", 'String'>
    readonly date: FieldRef<"timeslot", 'DateTime'>
    readonly timewindowstart: FieldRef<"timeslot", 'DateTime'>
    readonly timewindowend: FieldRef<"timeslot", 'DateTime'>
    readonly availableflag: FieldRef<"timeslot", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * timeslot findUnique
   */
  export type timeslotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeslot
     */
    select?: timeslotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeslot
     */
    omit?: timeslotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: timeslotInclude<ExtArgs> | null
    /**
     * Filter, which timeslot to fetch.
     */
    where: timeslotWhereUniqueInput
  }

  /**
   * timeslot findUniqueOrThrow
   */
  export type timeslotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeslot
     */
    select?: timeslotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeslot
     */
    omit?: timeslotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: timeslotInclude<ExtArgs> | null
    /**
     * Filter, which timeslot to fetch.
     */
    where: timeslotWhereUniqueInput
  }

  /**
   * timeslot findFirst
   */
  export type timeslotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeslot
     */
    select?: timeslotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeslot
     */
    omit?: timeslotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: timeslotInclude<ExtArgs> | null
    /**
     * Filter, which timeslot to fetch.
     */
    where?: timeslotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of timeslots to fetch.
     */
    orderBy?: timeslotOrderByWithRelationInput | timeslotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for timeslots.
     */
    cursor?: timeslotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` timeslots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` timeslots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of timeslots.
     */
    distinct?: TimeslotScalarFieldEnum | TimeslotScalarFieldEnum[]
  }

  /**
   * timeslot findFirstOrThrow
   */
  export type timeslotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeslot
     */
    select?: timeslotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeslot
     */
    omit?: timeslotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: timeslotInclude<ExtArgs> | null
    /**
     * Filter, which timeslot to fetch.
     */
    where?: timeslotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of timeslots to fetch.
     */
    orderBy?: timeslotOrderByWithRelationInput | timeslotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for timeslots.
     */
    cursor?: timeslotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` timeslots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` timeslots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of timeslots.
     */
    distinct?: TimeslotScalarFieldEnum | TimeslotScalarFieldEnum[]
  }

  /**
   * timeslot findMany
   */
  export type timeslotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeslot
     */
    select?: timeslotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeslot
     */
    omit?: timeslotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: timeslotInclude<ExtArgs> | null
    /**
     * Filter, which timeslots to fetch.
     */
    where?: timeslotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of timeslots to fetch.
     */
    orderBy?: timeslotOrderByWithRelationInput | timeslotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing timeslots.
     */
    cursor?: timeslotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` timeslots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` timeslots.
     */
    skip?: number
    distinct?: TimeslotScalarFieldEnum | TimeslotScalarFieldEnum[]
  }

  /**
   * timeslot create
   */
  export type timeslotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeslot
     */
    select?: timeslotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeslot
     */
    omit?: timeslotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: timeslotInclude<ExtArgs> | null
    /**
     * The data needed to create a timeslot.
     */
    data: XOR<timeslotCreateInput, timeslotUncheckedCreateInput>
  }

  /**
   * timeslot createMany
   */
  export type timeslotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many timeslots.
     */
    data: timeslotCreateManyInput | timeslotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * timeslot createManyAndReturn
   */
  export type timeslotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeslot
     */
    select?: timeslotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the timeslot
     */
    omit?: timeslotOmit<ExtArgs> | null
    /**
     * The data used to create many timeslots.
     */
    data: timeslotCreateManyInput | timeslotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: timeslotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * timeslot update
   */
  export type timeslotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeslot
     */
    select?: timeslotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeslot
     */
    omit?: timeslotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: timeslotInclude<ExtArgs> | null
    /**
     * The data needed to update a timeslot.
     */
    data: XOR<timeslotUpdateInput, timeslotUncheckedUpdateInput>
    /**
     * Choose, which timeslot to update.
     */
    where: timeslotWhereUniqueInput
  }

  /**
   * timeslot updateMany
   */
  export type timeslotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update timeslots.
     */
    data: XOR<timeslotUpdateManyMutationInput, timeslotUncheckedUpdateManyInput>
    /**
     * Filter which timeslots to update
     */
    where?: timeslotWhereInput
    /**
     * Limit how many timeslots to update.
     */
    limit?: number
  }

  /**
   * timeslot updateManyAndReturn
   */
  export type timeslotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeslot
     */
    select?: timeslotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the timeslot
     */
    omit?: timeslotOmit<ExtArgs> | null
    /**
     * The data used to update timeslots.
     */
    data: XOR<timeslotUpdateManyMutationInput, timeslotUncheckedUpdateManyInput>
    /**
     * Filter which timeslots to update
     */
    where?: timeslotWhereInput
    /**
     * Limit how many timeslots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: timeslotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * timeslot upsert
   */
  export type timeslotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeslot
     */
    select?: timeslotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeslot
     */
    omit?: timeslotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: timeslotInclude<ExtArgs> | null
    /**
     * The filter to search for the timeslot to update in case it exists.
     */
    where: timeslotWhereUniqueInput
    /**
     * In case the timeslot found by the `where` argument doesn't exist, create a new timeslot with this data.
     */
    create: XOR<timeslotCreateInput, timeslotUncheckedCreateInput>
    /**
     * In case the timeslot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<timeslotUpdateInput, timeslotUncheckedUpdateInput>
  }

  /**
   * timeslot delete
   */
  export type timeslotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeslot
     */
    select?: timeslotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeslot
     */
    omit?: timeslotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: timeslotInclude<ExtArgs> | null
    /**
     * Filter which timeslot to delete.
     */
    where: timeslotWhereUniqueInput
  }

  /**
   * timeslot deleteMany
   */
  export type timeslotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which timeslots to delete
     */
    where?: timeslotWhereInput
    /**
     * Limit how many timeslots to delete.
     */
    limit?: number
  }

  /**
   * timeslot.orders
   */
  export type timeslot$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the orders
     */
    select?: ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the orders
     */
    omit?: ordersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ordersInclude<ExtArgs> | null
    where?: ordersWhereInput
    orderBy?: ordersOrderByWithRelationInput | ordersOrderByWithRelationInput[]
    cursor?: ordersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * timeslot.lorrytrip
   */
  export type timeslot$lorrytripArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripInclude<ExtArgs> | null
    where?: lorrytripWhereInput
  }

  /**
   * timeslot without action
   */
  export type timeslotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the timeslot
     */
    select?: timeslotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the timeslot
     */
    omit?: timeslotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: timeslotInclude<ExtArgs> | null
  }


  /**
   * Model truck
   */

  export type AggregateTruck = {
    _count: TruckCountAggregateOutputType | null
    _avg: TruckAvgAggregateOutputType | null
    _sum: TruckSumAggregateOutputType | null
    _min: TruckMinAggregateOutputType | null
    _max: TruckMaxAggregateOutputType | null
  }

  export type TruckAvgAggregateOutputType = {
    tone: number | null
    lengthcm: number | null
    widthcm: number | null
    heightcm: number | null
  }

  export type TruckSumAggregateOutputType = {
    tone: number | null
    lengthcm: number | null
    widthcm: number | null
    heightcm: number | null
  }

  export type TruckMinAggregateOutputType = {
    truckid: string | null
    carplate: string | null
    tone: number | null
    lengthcm: number | null
    widthcm: number | null
    heightcm: number | null
  }

  export type TruckMaxAggregateOutputType = {
    truckid: string | null
    carplate: string | null
    tone: number | null
    lengthcm: number | null
    widthcm: number | null
    heightcm: number | null
  }

  export type TruckCountAggregateOutputType = {
    truckid: number
    carplate: number
    tone: number
    lengthcm: number
    widthcm: number
    heightcm: number
    _all: number
  }


  export type TruckAvgAggregateInputType = {
    tone?: true
    lengthcm?: true
    widthcm?: true
    heightcm?: true
  }

  export type TruckSumAggregateInputType = {
    tone?: true
    lengthcm?: true
    widthcm?: true
    heightcm?: true
  }

  export type TruckMinAggregateInputType = {
    truckid?: true
    carplate?: true
    tone?: true
    lengthcm?: true
    widthcm?: true
    heightcm?: true
  }

  export type TruckMaxAggregateInputType = {
    truckid?: true
    carplate?: true
    tone?: true
    lengthcm?: true
    widthcm?: true
    heightcm?: true
  }

  export type TruckCountAggregateInputType = {
    truckid?: true
    carplate?: true
    tone?: true
    lengthcm?: true
    widthcm?: true
    heightcm?: true
    _all?: true
  }

  export type TruckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which truck to aggregate.
     */
    where?: truckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trucks to fetch.
     */
    orderBy?: truckOrderByWithRelationInput | truckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: truckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trucks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trucks
    **/
    _count?: true | TruckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TruckAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TruckSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TruckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TruckMaxAggregateInputType
  }

  export type GetTruckAggregateType<T extends TruckAggregateArgs> = {
        [P in keyof T & keyof AggregateTruck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTruck[P]>
      : GetScalarType<T[P], AggregateTruck[P]>
  }




  export type truckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: truckWhereInput
    orderBy?: truckOrderByWithAggregationInput | truckOrderByWithAggregationInput[]
    by: TruckScalarFieldEnum[] | TruckScalarFieldEnum
    having?: truckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TruckCountAggregateInputType | true
    _avg?: TruckAvgAggregateInputType
    _sum?: TruckSumAggregateInputType
    _min?: TruckMinAggregateInputType
    _max?: TruckMaxAggregateInputType
  }

  export type TruckGroupByOutputType = {
    truckid: string
    carplate: string | null
    tone: number | null
    lengthcm: number | null
    widthcm: number | null
    heightcm: number | null
    _count: TruckCountAggregateOutputType | null
    _avg: TruckAvgAggregateOutputType | null
    _sum: TruckSumAggregateOutputType | null
    _min: TruckMinAggregateOutputType | null
    _max: TruckMaxAggregateOutputType | null
  }

  type GetTruckGroupByPayload<T extends truckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TruckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TruckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TruckGroupByOutputType[P]>
            : GetScalarType<T[P], TruckGroupByOutputType[P]>
        }
      >
    >


  export type truckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    truckid?: boolean
    carplate?: boolean
    tone?: boolean
    lengthcm?: boolean
    widthcm?: boolean
    heightcm?: boolean
    lorrytrip?: boolean | truck$lorrytripArgs<ExtArgs>
    truckzone?: boolean | truck$truckzoneArgs<ExtArgs>
    _count?: boolean | TruckCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["truck"]>

  export type truckSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    truckid?: boolean
    carplate?: boolean
    tone?: boolean
    lengthcm?: boolean
    widthcm?: boolean
    heightcm?: boolean
  }, ExtArgs["result"]["truck"]>

  export type truckSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    truckid?: boolean
    carplate?: boolean
    tone?: boolean
    lengthcm?: boolean
    widthcm?: boolean
    heightcm?: boolean
  }, ExtArgs["result"]["truck"]>

  export type truckSelectScalar = {
    truckid?: boolean
    carplate?: boolean
    tone?: boolean
    lengthcm?: boolean
    widthcm?: boolean
    heightcm?: boolean
  }

  export type truckOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"truckid" | "carplate" | "tone" | "lengthcm" | "widthcm" | "heightcm", ExtArgs["result"]["truck"]>
  export type truckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lorrytrip?: boolean | truck$lorrytripArgs<ExtArgs>
    truckzone?: boolean | truck$truckzoneArgs<ExtArgs>
    _count?: boolean | TruckCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type truckIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type truckIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $truckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "truck"
    objects: {
      lorrytrip: Prisma.$lorrytripPayload<ExtArgs>[]
      truckzone: Prisma.$truckzonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      truckid: string
      carplate: string | null
      tone: number | null
      lengthcm: number | null
      widthcm: number | null
      heightcm: number | null
    }, ExtArgs["result"]["truck"]>
    composites: {}
  }

  type truckGetPayload<S extends boolean | null | undefined | truckDefaultArgs> = $Result.GetResult<Prisma.$truckPayload, S>

  type truckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<truckFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TruckCountAggregateInputType | true
    }

  export interface truckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['truck'], meta: { name: 'truck' } }
    /**
     * Find zero or one Truck that matches the filter.
     * @param {truckFindUniqueArgs} args - Arguments to find a Truck
     * @example
     * // Get one Truck
     * const truck = await prisma.truck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends truckFindUniqueArgs>(args: SelectSubset<T, truckFindUniqueArgs<ExtArgs>>): Prisma__truckClient<$Result.GetResult<Prisma.$truckPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Truck that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {truckFindUniqueOrThrowArgs} args - Arguments to find a Truck
     * @example
     * // Get one Truck
     * const truck = await prisma.truck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends truckFindUniqueOrThrowArgs>(args: SelectSubset<T, truckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__truckClient<$Result.GetResult<Prisma.$truckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Truck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckFindFirstArgs} args - Arguments to find a Truck
     * @example
     * // Get one Truck
     * const truck = await prisma.truck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends truckFindFirstArgs>(args?: SelectSubset<T, truckFindFirstArgs<ExtArgs>>): Prisma__truckClient<$Result.GetResult<Prisma.$truckPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Truck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckFindFirstOrThrowArgs} args - Arguments to find a Truck
     * @example
     * // Get one Truck
     * const truck = await prisma.truck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends truckFindFirstOrThrowArgs>(args?: SelectSubset<T, truckFindFirstOrThrowArgs<ExtArgs>>): Prisma__truckClient<$Result.GetResult<Prisma.$truckPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trucks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trucks
     * const trucks = await prisma.truck.findMany()
     * 
     * // Get first 10 Trucks
     * const trucks = await prisma.truck.findMany({ take: 10 })
     * 
     * // Only select the `truckid`
     * const truckWithTruckidOnly = await prisma.truck.findMany({ select: { truckid: true } })
     * 
     */
    findMany<T extends truckFindManyArgs>(args?: SelectSubset<T, truckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$truckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Truck.
     * @param {truckCreateArgs} args - Arguments to create a Truck.
     * @example
     * // Create one Truck
     * const Truck = await prisma.truck.create({
     *   data: {
     *     // ... data to create a Truck
     *   }
     * })
     * 
     */
    create<T extends truckCreateArgs>(args: SelectSubset<T, truckCreateArgs<ExtArgs>>): Prisma__truckClient<$Result.GetResult<Prisma.$truckPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trucks.
     * @param {truckCreateManyArgs} args - Arguments to create many Trucks.
     * @example
     * // Create many Trucks
     * const truck = await prisma.truck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends truckCreateManyArgs>(args?: SelectSubset<T, truckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trucks and returns the data saved in the database.
     * @param {truckCreateManyAndReturnArgs} args - Arguments to create many Trucks.
     * @example
     * // Create many Trucks
     * const truck = await prisma.truck.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trucks and only return the `truckid`
     * const truckWithTruckidOnly = await prisma.truck.createManyAndReturn({
     *   select: { truckid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends truckCreateManyAndReturnArgs>(args?: SelectSubset<T, truckCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$truckPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Truck.
     * @param {truckDeleteArgs} args - Arguments to delete one Truck.
     * @example
     * // Delete one Truck
     * const Truck = await prisma.truck.delete({
     *   where: {
     *     // ... filter to delete one Truck
     *   }
     * })
     * 
     */
    delete<T extends truckDeleteArgs>(args: SelectSubset<T, truckDeleteArgs<ExtArgs>>): Prisma__truckClient<$Result.GetResult<Prisma.$truckPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Truck.
     * @param {truckUpdateArgs} args - Arguments to update one Truck.
     * @example
     * // Update one Truck
     * const truck = await prisma.truck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends truckUpdateArgs>(args: SelectSubset<T, truckUpdateArgs<ExtArgs>>): Prisma__truckClient<$Result.GetResult<Prisma.$truckPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trucks.
     * @param {truckDeleteManyArgs} args - Arguments to filter Trucks to delete.
     * @example
     * // Delete a few Trucks
     * const { count } = await prisma.truck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends truckDeleteManyArgs>(args?: SelectSubset<T, truckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trucks
     * const truck = await prisma.truck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends truckUpdateManyArgs>(args: SelectSubset<T, truckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trucks and returns the data updated in the database.
     * @param {truckUpdateManyAndReturnArgs} args - Arguments to update many Trucks.
     * @example
     * // Update many Trucks
     * const truck = await prisma.truck.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trucks and only return the `truckid`
     * const truckWithTruckidOnly = await prisma.truck.updateManyAndReturn({
     *   select: { truckid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends truckUpdateManyAndReturnArgs>(args: SelectSubset<T, truckUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$truckPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Truck.
     * @param {truckUpsertArgs} args - Arguments to update or create a Truck.
     * @example
     * // Update or create a Truck
     * const truck = await prisma.truck.upsert({
     *   create: {
     *     // ... data to create a Truck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Truck we want to update
     *   }
     * })
     */
    upsert<T extends truckUpsertArgs>(args: SelectSubset<T, truckUpsertArgs<ExtArgs>>): Prisma__truckClient<$Result.GetResult<Prisma.$truckPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trucks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckCountArgs} args - Arguments to filter Trucks to count.
     * @example
     * // Count the number of Trucks
     * const count = await prisma.truck.count({
     *   where: {
     *     // ... the filter for the Trucks we want to count
     *   }
     * })
    **/
    count<T extends truckCountArgs>(
      args?: Subset<T, truckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TruckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Truck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TruckAggregateArgs>(args: Subset<T, TruckAggregateArgs>): Prisma.PrismaPromise<GetTruckAggregateType<T>>

    /**
     * Group by Truck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends truckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: truckGroupByArgs['orderBy'] }
        : { orderBy?: truckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, truckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTruckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the truck model
   */
  readonly fields: truckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for truck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__truckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lorrytrip<T extends truck$lorrytripArgs<ExtArgs> = {}>(args?: Subset<T, truck$lorrytripArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lorrytripPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    truckzone<T extends truck$truckzoneArgs<ExtArgs> = {}>(args?: Subset<T, truck$truckzoneArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$truckzonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the truck model
   */
  interface truckFieldRefs {
    readonly truckid: FieldRef<"truck", 'String'>
    readonly carplate: FieldRef<"truck", 'String'>
    readonly tone: FieldRef<"truck", 'Int'>
    readonly lengthcm: FieldRef<"truck", 'Int'>
    readonly widthcm: FieldRef<"truck", 'Int'>
    readonly heightcm: FieldRef<"truck", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * truck findUnique
   */
  export type truckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truck
     */
    omit?: truckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckInclude<ExtArgs> | null
    /**
     * Filter, which truck to fetch.
     */
    where: truckWhereUniqueInput
  }

  /**
   * truck findUniqueOrThrow
   */
  export type truckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truck
     */
    omit?: truckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckInclude<ExtArgs> | null
    /**
     * Filter, which truck to fetch.
     */
    where: truckWhereUniqueInput
  }

  /**
   * truck findFirst
   */
  export type truckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truck
     */
    omit?: truckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckInclude<ExtArgs> | null
    /**
     * Filter, which truck to fetch.
     */
    where?: truckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trucks to fetch.
     */
    orderBy?: truckOrderByWithRelationInput | truckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trucks.
     */
    cursor?: truckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trucks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trucks.
     */
    distinct?: TruckScalarFieldEnum | TruckScalarFieldEnum[]
  }

  /**
   * truck findFirstOrThrow
   */
  export type truckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truck
     */
    omit?: truckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckInclude<ExtArgs> | null
    /**
     * Filter, which truck to fetch.
     */
    where?: truckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trucks to fetch.
     */
    orderBy?: truckOrderByWithRelationInput | truckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trucks.
     */
    cursor?: truckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trucks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trucks.
     */
    distinct?: TruckScalarFieldEnum | TruckScalarFieldEnum[]
  }

  /**
   * truck findMany
   */
  export type truckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truck
     */
    omit?: truckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckInclude<ExtArgs> | null
    /**
     * Filter, which trucks to fetch.
     */
    where?: truckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trucks to fetch.
     */
    orderBy?: truckOrderByWithRelationInput | truckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trucks.
     */
    cursor?: truckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trucks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trucks.
     */
    skip?: number
    distinct?: TruckScalarFieldEnum | TruckScalarFieldEnum[]
  }

  /**
   * truck create
   */
  export type truckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truck
     */
    omit?: truckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckInclude<ExtArgs> | null
    /**
     * The data needed to create a truck.
     */
    data: XOR<truckCreateInput, truckUncheckedCreateInput>
  }

  /**
   * truck createMany
   */
  export type truckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trucks.
     */
    data: truckCreateManyInput | truckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * truck createManyAndReturn
   */
  export type truckCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the truck
     */
    omit?: truckOmit<ExtArgs> | null
    /**
     * The data used to create many trucks.
     */
    data: truckCreateManyInput | truckCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * truck update
   */
  export type truckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truck
     */
    omit?: truckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckInclude<ExtArgs> | null
    /**
     * The data needed to update a truck.
     */
    data: XOR<truckUpdateInput, truckUncheckedUpdateInput>
    /**
     * Choose, which truck to update.
     */
    where: truckWhereUniqueInput
  }

  /**
   * truck updateMany
   */
  export type truckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trucks.
     */
    data: XOR<truckUpdateManyMutationInput, truckUncheckedUpdateManyInput>
    /**
     * Filter which trucks to update
     */
    where?: truckWhereInput
    /**
     * Limit how many trucks to update.
     */
    limit?: number
  }

  /**
   * truck updateManyAndReturn
   */
  export type truckUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the truck
     */
    omit?: truckOmit<ExtArgs> | null
    /**
     * The data used to update trucks.
     */
    data: XOR<truckUpdateManyMutationInput, truckUncheckedUpdateManyInput>
    /**
     * Filter which trucks to update
     */
    where?: truckWhereInput
    /**
     * Limit how many trucks to update.
     */
    limit?: number
  }

  /**
   * truck upsert
   */
  export type truckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truck
     */
    omit?: truckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckInclude<ExtArgs> | null
    /**
     * The filter to search for the truck to update in case it exists.
     */
    where: truckWhereUniqueInput
    /**
     * In case the truck found by the `where` argument doesn't exist, create a new truck with this data.
     */
    create: XOR<truckCreateInput, truckUncheckedCreateInput>
    /**
     * In case the truck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<truckUpdateInput, truckUncheckedUpdateInput>
  }

  /**
   * truck delete
   */
  export type truckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truck
     */
    omit?: truckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckInclude<ExtArgs> | null
    /**
     * Filter which truck to delete.
     */
    where: truckWhereUniqueInput
  }

  /**
   * truck deleteMany
   */
  export type truckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trucks to delete
     */
    where?: truckWhereInput
    /**
     * Limit how many trucks to delete.
     */
    limit?: number
  }

  /**
   * truck.lorrytrip
   */
  export type truck$lorrytripArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lorrytrip
     */
    select?: lorrytripSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lorrytrip
     */
    omit?: lorrytripOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lorrytripInclude<ExtArgs> | null
    where?: lorrytripWhereInput
    orderBy?: lorrytripOrderByWithRelationInput | lorrytripOrderByWithRelationInput[]
    cursor?: lorrytripWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LorrytripScalarFieldEnum | LorrytripScalarFieldEnum[]
  }

  /**
   * truck.truckzone
   */
  export type truck$truckzoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truckzone
     */
    select?: truckzoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truckzone
     */
    omit?: truckzoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckzoneInclude<ExtArgs> | null
    where?: truckzoneWhereInput
    orderBy?: truckzoneOrderByWithRelationInput | truckzoneOrderByWithRelationInput[]
    cursor?: truckzoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TruckzoneScalarFieldEnum | TruckzoneScalarFieldEnum[]
  }

  /**
   * truck without action
   */
  export type truckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truck
     */
    select?: truckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truck
     */
    omit?: truckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckInclude<ExtArgs> | null
  }


  /**
   * Model truckzone
   */

  export type AggregateTruckzone = {
    _count: TruckzoneCountAggregateOutputType | null
    _min: TruckzoneMinAggregateOutputType | null
    _max: TruckzoneMaxAggregateOutputType | null
  }

  export type TruckzoneMinAggregateOutputType = {
    truckid: string | null
    zoneid: string | null
    isprimaryzone: boolean | null
  }

  export type TruckzoneMaxAggregateOutputType = {
    truckid: string | null
    zoneid: string | null
    isprimaryzone: boolean | null
  }

  export type TruckzoneCountAggregateOutputType = {
    truckid: number
    zoneid: number
    isprimaryzone: number
    _all: number
  }


  export type TruckzoneMinAggregateInputType = {
    truckid?: true
    zoneid?: true
    isprimaryzone?: true
  }

  export type TruckzoneMaxAggregateInputType = {
    truckid?: true
    zoneid?: true
    isprimaryzone?: true
  }

  export type TruckzoneCountAggregateInputType = {
    truckid?: true
    zoneid?: true
    isprimaryzone?: true
    _all?: true
  }

  export type TruckzoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which truckzone to aggregate.
     */
    where?: truckzoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of truckzones to fetch.
     */
    orderBy?: truckzoneOrderByWithRelationInput | truckzoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: truckzoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` truckzones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` truckzones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned truckzones
    **/
    _count?: true | TruckzoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TruckzoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TruckzoneMaxAggregateInputType
  }

  export type GetTruckzoneAggregateType<T extends TruckzoneAggregateArgs> = {
        [P in keyof T & keyof AggregateTruckzone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTruckzone[P]>
      : GetScalarType<T[P], AggregateTruckzone[P]>
  }




  export type truckzoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: truckzoneWhereInput
    orderBy?: truckzoneOrderByWithAggregationInput | truckzoneOrderByWithAggregationInput[]
    by: TruckzoneScalarFieldEnum[] | TruckzoneScalarFieldEnum
    having?: truckzoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TruckzoneCountAggregateInputType | true
    _min?: TruckzoneMinAggregateInputType
    _max?: TruckzoneMaxAggregateInputType
  }

  export type TruckzoneGroupByOutputType = {
    truckid: string
    zoneid: string
    isprimaryzone: boolean | null
    _count: TruckzoneCountAggregateOutputType | null
    _min: TruckzoneMinAggregateOutputType | null
    _max: TruckzoneMaxAggregateOutputType | null
  }

  type GetTruckzoneGroupByPayload<T extends truckzoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TruckzoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TruckzoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TruckzoneGroupByOutputType[P]>
            : GetScalarType<T[P], TruckzoneGroupByOutputType[P]>
        }
      >
    >


  export type truckzoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    truckid?: boolean
    zoneid?: boolean
    isprimaryzone?: boolean
    truck?: boolean | truckDefaultArgs<ExtArgs>
    zone?: boolean | zoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["truckzone"]>

  export type truckzoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    truckid?: boolean
    zoneid?: boolean
    isprimaryzone?: boolean
    truck?: boolean | truckDefaultArgs<ExtArgs>
    zone?: boolean | zoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["truckzone"]>

  export type truckzoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    truckid?: boolean
    zoneid?: boolean
    isprimaryzone?: boolean
    truck?: boolean | truckDefaultArgs<ExtArgs>
    zone?: boolean | zoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["truckzone"]>

  export type truckzoneSelectScalar = {
    truckid?: boolean
    zoneid?: boolean
    isprimaryzone?: boolean
  }

  export type truckzoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"truckid" | "zoneid" | "isprimaryzone", ExtArgs["result"]["truckzone"]>
  export type truckzoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | truckDefaultArgs<ExtArgs>
    zone?: boolean | zoneDefaultArgs<ExtArgs>
  }
  export type truckzoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | truckDefaultArgs<ExtArgs>
    zone?: boolean | zoneDefaultArgs<ExtArgs>
  }
  export type truckzoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    truck?: boolean | truckDefaultArgs<ExtArgs>
    zone?: boolean | zoneDefaultArgs<ExtArgs>
  }

  export type $truckzonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "truckzone"
    objects: {
      truck: Prisma.$truckPayload<ExtArgs>
      zone: Prisma.$zonePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      truckid: string
      zoneid: string
      isprimaryzone: boolean | null
    }, ExtArgs["result"]["truckzone"]>
    composites: {}
  }

  type truckzoneGetPayload<S extends boolean | null | undefined | truckzoneDefaultArgs> = $Result.GetResult<Prisma.$truckzonePayload, S>

  type truckzoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<truckzoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TruckzoneCountAggregateInputType | true
    }

  export interface truckzoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['truckzone'], meta: { name: 'truckzone' } }
    /**
     * Find zero or one Truckzone that matches the filter.
     * @param {truckzoneFindUniqueArgs} args - Arguments to find a Truckzone
     * @example
     * // Get one Truckzone
     * const truckzone = await prisma.truckzone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends truckzoneFindUniqueArgs>(args: SelectSubset<T, truckzoneFindUniqueArgs<ExtArgs>>): Prisma__truckzoneClient<$Result.GetResult<Prisma.$truckzonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Truckzone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {truckzoneFindUniqueOrThrowArgs} args - Arguments to find a Truckzone
     * @example
     * // Get one Truckzone
     * const truckzone = await prisma.truckzone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends truckzoneFindUniqueOrThrowArgs>(args: SelectSubset<T, truckzoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__truckzoneClient<$Result.GetResult<Prisma.$truckzonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Truckzone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckzoneFindFirstArgs} args - Arguments to find a Truckzone
     * @example
     * // Get one Truckzone
     * const truckzone = await prisma.truckzone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends truckzoneFindFirstArgs>(args?: SelectSubset<T, truckzoneFindFirstArgs<ExtArgs>>): Prisma__truckzoneClient<$Result.GetResult<Prisma.$truckzonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Truckzone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckzoneFindFirstOrThrowArgs} args - Arguments to find a Truckzone
     * @example
     * // Get one Truckzone
     * const truckzone = await prisma.truckzone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends truckzoneFindFirstOrThrowArgs>(args?: SelectSubset<T, truckzoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__truckzoneClient<$Result.GetResult<Prisma.$truckzonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Truckzones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckzoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Truckzones
     * const truckzones = await prisma.truckzone.findMany()
     * 
     * // Get first 10 Truckzones
     * const truckzones = await prisma.truckzone.findMany({ take: 10 })
     * 
     * // Only select the `truckid`
     * const truckzoneWithTruckidOnly = await prisma.truckzone.findMany({ select: { truckid: true } })
     * 
     */
    findMany<T extends truckzoneFindManyArgs>(args?: SelectSubset<T, truckzoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$truckzonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Truckzone.
     * @param {truckzoneCreateArgs} args - Arguments to create a Truckzone.
     * @example
     * // Create one Truckzone
     * const Truckzone = await prisma.truckzone.create({
     *   data: {
     *     // ... data to create a Truckzone
     *   }
     * })
     * 
     */
    create<T extends truckzoneCreateArgs>(args: SelectSubset<T, truckzoneCreateArgs<ExtArgs>>): Prisma__truckzoneClient<$Result.GetResult<Prisma.$truckzonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Truckzones.
     * @param {truckzoneCreateManyArgs} args - Arguments to create many Truckzones.
     * @example
     * // Create many Truckzones
     * const truckzone = await prisma.truckzone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends truckzoneCreateManyArgs>(args?: SelectSubset<T, truckzoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Truckzones and returns the data saved in the database.
     * @param {truckzoneCreateManyAndReturnArgs} args - Arguments to create many Truckzones.
     * @example
     * // Create many Truckzones
     * const truckzone = await prisma.truckzone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Truckzones and only return the `truckid`
     * const truckzoneWithTruckidOnly = await prisma.truckzone.createManyAndReturn({
     *   select: { truckid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends truckzoneCreateManyAndReturnArgs>(args?: SelectSubset<T, truckzoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$truckzonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Truckzone.
     * @param {truckzoneDeleteArgs} args - Arguments to delete one Truckzone.
     * @example
     * // Delete one Truckzone
     * const Truckzone = await prisma.truckzone.delete({
     *   where: {
     *     // ... filter to delete one Truckzone
     *   }
     * })
     * 
     */
    delete<T extends truckzoneDeleteArgs>(args: SelectSubset<T, truckzoneDeleteArgs<ExtArgs>>): Prisma__truckzoneClient<$Result.GetResult<Prisma.$truckzonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Truckzone.
     * @param {truckzoneUpdateArgs} args - Arguments to update one Truckzone.
     * @example
     * // Update one Truckzone
     * const truckzone = await prisma.truckzone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends truckzoneUpdateArgs>(args: SelectSubset<T, truckzoneUpdateArgs<ExtArgs>>): Prisma__truckzoneClient<$Result.GetResult<Prisma.$truckzonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Truckzones.
     * @param {truckzoneDeleteManyArgs} args - Arguments to filter Truckzones to delete.
     * @example
     * // Delete a few Truckzones
     * const { count } = await prisma.truckzone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends truckzoneDeleteManyArgs>(args?: SelectSubset<T, truckzoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Truckzones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckzoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Truckzones
     * const truckzone = await prisma.truckzone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends truckzoneUpdateManyArgs>(args: SelectSubset<T, truckzoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Truckzones and returns the data updated in the database.
     * @param {truckzoneUpdateManyAndReturnArgs} args - Arguments to update many Truckzones.
     * @example
     * // Update many Truckzones
     * const truckzone = await prisma.truckzone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Truckzones and only return the `truckid`
     * const truckzoneWithTruckidOnly = await prisma.truckzone.updateManyAndReturn({
     *   select: { truckid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends truckzoneUpdateManyAndReturnArgs>(args: SelectSubset<T, truckzoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$truckzonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Truckzone.
     * @param {truckzoneUpsertArgs} args - Arguments to update or create a Truckzone.
     * @example
     * // Update or create a Truckzone
     * const truckzone = await prisma.truckzone.upsert({
     *   create: {
     *     // ... data to create a Truckzone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Truckzone we want to update
     *   }
     * })
     */
    upsert<T extends truckzoneUpsertArgs>(args: SelectSubset<T, truckzoneUpsertArgs<ExtArgs>>): Prisma__truckzoneClient<$Result.GetResult<Prisma.$truckzonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Truckzones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckzoneCountArgs} args - Arguments to filter Truckzones to count.
     * @example
     * // Count the number of Truckzones
     * const count = await prisma.truckzone.count({
     *   where: {
     *     // ... the filter for the Truckzones we want to count
     *   }
     * })
    **/
    count<T extends truckzoneCountArgs>(
      args?: Subset<T, truckzoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TruckzoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Truckzone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckzoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TruckzoneAggregateArgs>(args: Subset<T, TruckzoneAggregateArgs>): Prisma.PrismaPromise<GetTruckzoneAggregateType<T>>

    /**
     * Group by Truckzone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {truckzoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends truckzoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: truckzoneGroupByArgs['orderBy'] }
        : { orderBy?: truckzoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, truckzoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTruckzoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the truckzone model
   */
  readonly fields: truckzoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for truckzone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__truckzoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    truck<T extends truckDefaultArgs<ExtArgs> = {}>(args?: Subset<T, truckDefaultArgs<ExtArgs>>): Prisma__truckClient<$Result.GetResult<Prisma.$truckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    zone<T extends zoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, zoneDefaultArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the truckzone model
   */
  interface truckzoneFieldRefs {
    readonly truckid: FieldRef<"truckzone", 'String'>
    readonly zoneid: FieldRef<"truckzone", 'String'>
    readonly isprimaryzone: FieldRef<"truckzone", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * truckzone findUnique
   */
  export type truckzoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truckzone
     */
    select?: truckzoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truckzone
     */
    omit?: truckzoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckzoneInclude<ExtArgs> | null
    /**
     * Filter, which truckzone to fetch.
     */
    where: truckzoneWhereUniqueInput
  }

  /**
   * truckzone findUniqueOrThrow
   */
  export type truckzoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truckzone
     */
    select?: truckzoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truckzone
     */
    omit?: truckzoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckzoneInclude<ExtArgs> | null
    /**
     * Filter, which truckzone to fetch.
     */
    where: truckzoneWhereUniqueInput
  }

  /**
   * truckzone findFirst
   */
  export type truckzoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truckzone
     */
    select?: truckzoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truckzone
     */
    omit?: truckzoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckzoneInclude<ExtArgs> | null
    /**
     * Filter, which truckzone to fetch.
     */
    where?: truckzoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of truckzones to fetch.
     */
    orderBy?: truckzoneOrderByWithRelationInput | truckzoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for truckzones.
     */
    cursor?: truckzoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` truckzones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` truckzones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of truckzones.
     */
    distinct?: TruckzoneScalarFieldEnum | TruckzoneScalarFieldEnum[]
  }

  /**
   * truckzone findFirstOrThrow
   */
  export type truckzoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truckzone
     */
    select?: truckzoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truckzone
     */
    omit?: truckzoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckzoneInclude<ExtArgs> | null
    /**
     * Filter, which truckzone to fetch.
     */
    where?: truckzoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of truckzones to fetch.
     */
    orderBy?: truckzoneOrderByWithRelationInput | truckzoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for truckzones.
     */
    cursor?: truckzoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` truckzones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` truckzones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of truckzones.
     */
    distinct?: TruckzoneScalarFieldEnum | TruckzoneScalarFieldEnum[]
  }

  /**
   * truckzone findMany
   */
  export type truckzoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truckzone
     */
    select?: truckzoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truckzone
     */
    omit?: truckzoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckzoneInclude<ExtArgs> | null
    /**
     * Filter, which truckzones to fetch.
     */
    where?: truckzoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of truckzones to fetch.
     */
    orderBy?: truckzoneOrderByWithRelationInput | truckzoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing truckzones.
     */
    cursor?: truckzoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` truckzones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` truckzones.
     */
    skip?: number
    distinct?: TruckzoneScalarFieldEnum | TruckzoneScalarFieldEnum[]
  }

  /**
   * truckzone create
   */
  export type truckzoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truckzone
     */
    select?: truckzoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truckzone
     */
    omit?: truckzoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckzoneInclude<ExtArgs> | null
    /**
     * The data needed to create a truckzone.
     */
    data: XOR<truckzoneCreateInput, truckzoneUncheckedCreateInput>
  }

  /**
   * truckzone createMany
   */
  export type truckzoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many truckzones.
     */
    data: truckzoneCreateManyInput | truckzoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * truckzone createManyAndReturn
   */
  export type truckzoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truckzone
     */
    select?: truckzoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the truckzone
     */
    omit?: truckzoneOmit<ExtArgs> | null
    /**
     * The data used to create many truckzones.
     */
    data: truckzoneCreateManyInput | truckzoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckzoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * truckzone update
   */
  export type truckzoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truckzone
     */
    select?: truckzoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truckzone
     */
    omit?: truckzoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckzoneInclude<ExtArgs> | null
    /**
     * The data needed to update a truckzone.
     */
    data: XOR<truckzoneUpdateInput, truckzoneUncheckedUpdateInput>
    /**
     * Choose, which truckzone to update.
     */
    where: truckzoneWhereUniqueInput
  }

  /**
   * truckzone updateMany
   */
  export type truckzoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update truckzones.
     */
    data: XOR<truckzoneUpdateManyMutationInput, truckzoneUncheckedUpdateManyInput>
    /**
     * Filter which truckzones to update
     */
    where?: truckzoneWhereInput
    /**
     * Limit how many truckzones to update.
     */
    limit?: number
  }

  /**
   * truckzone updateManyAndReturn
   */
  export type truckzoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truckzone
     */
    select?: truckzoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the truckzone
     */
    omit?: truckzoneOmit<ExtArgs> | null
    /**
     * The data used to update truckzones.
     */
    data: XOR<truckzoneUpdateManyMutationInput, truckzoneUncheckedUpdateManyInput>
    /**
     * Filter which truckzones to update
     */
    where?: truckzoneWhereInput
    /**
     * Limit how many truckzones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckzoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * truckzone upsert
   */
  export type truckzoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truckzone
     */
    select?: truckzoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truckzone
     */
    omit?: truckzoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckzoneInclude<ExtArgs> | null
    /**
     * The filter to search for the truckzone to update in case it exists.
     */
    where: truckzoneWhereUniqueInput
    /**
     * In case the truckzone found by the `where` argument doesn't exist, create a new truckzone with this data.
     */
    create: XOR<truckzoneCreateInput, truckzoneUncheckedCreateInput>
    /**
     * In case the truckzone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<truckzoneUpdateInput, truckzoneUncheckedUpdateInput>
  }

  /**
   * truckzone delete
   */
  export type truckzoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truckzone
     */
    select?: truckzoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truckzone
     */
    omit?: truckzoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckzoneInclude<ExtArgs> | null
    /**
     * Filter which truckzone to delete.
     */
    where: truckzoneWhereUniqueInput
  }

  /**
   * truckzone deleteMany
   */
  export type truckzoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which truckzones to delete
     */
    where?: truckzoneWhereInput
    /**
     * Limit how many truckzones to delete.
     */
    limit?: number
  }

  /**
   * truckzone without action
   */
  export type truckzoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truckzone
     */
    select?: truckzoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truckzone
     */
    omit?: truckzoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckzoneInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    uid: string | null
    name: string | null
    displayname: string | null
    email: string | null
    bio: string | null
    createdat: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    uid: string | null
    name: string | null
    displayname: string | null
    email: string | null
    bio: string | null
    createdat: Date | null
  }

  export type UsersCountAggregateOutputType = {
    uid: number
    name: number
    displayname: number
    email: number
    bio: number
    createdat: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    uid?: true
    name?: true
    displayname?: true
    email?: true
    bio?: true
    createdat?: true
  }

  export type UsersMaxAggregateInputType = {
    uid?: true
    name?: true
    displayname?: true
    email?: true
    bio?: true
    createdat?: true
  }

  export type UsersCountAggregateInputType = {
    uid?: true
    name?: true
    displayname?: true
    email?: true
    bio?: true
    createdat?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    uid: string
    name: string | null
    displayname: string | null
    email: string | null
    bio: string | null
    createdat: Date | null
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    name?: boolean
    displayname?: boolean
    email?: boolean
    bio?: boolean
    createdat?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    name?: boolean
    displayname?: boolean
    email?: boolean
    bio?: boolean
    createdat?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    uid?: boolean
    name?: boolean
    displayname?: boolean
    email?: boolean
    bio?: boolean
    createdat?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    uid?: boolean
    name?: boolean
    displayname?: boolean
    email?: boolean
    bio?: boolean
    createdat?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"uid" | "name" | "displayname" | "email" | "bio" | "createdat", ExtArgs["result"]["users"]>

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      uid: string
      name: string | null
      displayname: string | null
      email: string | null
      bio: string | null
      createdat: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `uid`
     * const usersWithUidOnly = await prisma.users.findMany({ select: { uid: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `uid`
     * const usersWithUidOnly = await prisma.users.createManyAndReturn({
     *   select: { uid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `uid`
     * const usersWithUidOnly = await prisma.users.updateManyAndReturn({
     *   select: { uid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly uid: FieldRef<"users", 'String'>
    readonly name: FieldRef<"users", 'String'>
    readonly displayname: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly bio: FieldRef<"users", 'String'>
    readonly createdat: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
  }


  /**
   * Model zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneMinAggregateOutputType = {
    zoneid: string | null
    zonename: string | null
  }

  export type ZoneMaxAggregateOutputType = {
    zoneid: string | null
    zonename: string | null
  }

  export type ZoneCountAggregateOutputType = {
    zoneid: number
    zonename: number
    _all: number
  }


  export type ZoneMinAggregateInputType = {
    zoneid?: true
    zonename?: true
  }

  export type ZoneMaxAggregateInputType = {
    zoneid?: true
    zonename?: true
  }

  export type ZoneCountAggregateInputType = {
    zoneid?: true
    zonename?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zone to aggregate.
     */
    where?: zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type zoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: zoneWhereInput
    orderBy?: zoneOrderByWithAggregationInput | zoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: zoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    zoneid: string
    zonename: string | null
    _count: ZoneCountAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends zoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type zoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    zoneid?: boolean
    zonename?: boolean
    building?: boolean | zone$buildingArgs<ExtArgs>
    truckzone?: boolean | zone$truckzoneArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type zoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    zoneid?: boolean
    zonename?: boolean
  }, ExtArgs["result"]["zone"]>

  export type zoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    zoneid?: boolean
    zonename?: boolean
  }, ExtArgs["result"]["zone"]>

  export type zoneSelectScalar = {
    zoneid?: boolean
    zonename?: boolean
  }

  export type zoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"zoneid" | "zonename", ExtArgs["result"]["zone"]>
  export type zoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    building?: boolean | zone$buildingArgs<ExtArgs>
    truckzone?: boolean | zone$truckzoneArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type zoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type zoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $zonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "zone"
    objects: {
      building: Prisma.$buildingPayload<ExtArgs>[]
      truckzone: Prisma.$truckzonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      zoneid: string
      zonename: string | null
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }

  type zoneGetPayload<S extends boolean | null | undefined | zoneDefaultArgs> = $Result.GetResult<Prisma.$zonePayload, S>

  type zoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<zoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface zoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['zone'], meta: { name: 'zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {zoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends zoneFindUniqueArgs>(args: SelectSubset<T, zoneFindUniqueArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Zone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {zoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends zoneFindUniqueOrThrowArgs>(args: SelectSubset<T, zoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends zoneFindFirstArgs>(args?: SelectSubset<T, zoneFindFirstArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends zoneFindFirstOrThrowArgs>(args?: SelectSubset<T, zoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `zoneid`
     * const zoneWithZoneidOnly = await prisma.zone.findMany({ select: { zoneid: true } })
     * 
     */
    findMany<T extends zoneFindManyArgs>(args?: SelectSubset<T, zoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Zone.
     * @param {zoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
     */
    create<T extends zoneCreateArgs>(args: SelectSubset<T, zoneCreateArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Zones.
     * @param {zoneCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends zoneCreateManyArgs>(args?: SelectSubset<T, zoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {zoneCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `zoneid`
     * const zoneWithZoneidOnly = await prisma.zone.createManyAndReturn({
     *   select: { zoneid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends zoneCreateManyAndReturnArgs>(args?: SelectSubset<T, zoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Zone.
     * @param {zoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
     */
    delete<T extends zoneDeleteArgs>(args: SelectSubset<T, zoneDeleteArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Zone.
     * @param {zoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends zoneUpdateArgs>(args: SelectSubset<T, zoneUpdateArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Zones.
     * @param {zoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends zoneDeleteManyArgs>(args?: SelectSubset<T, zoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends zoneUpdateManyArgs>(args: SelectSubset<T, zoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones and returns the data updated in the database.
     * @param {zoneUpdateManyAndReturnArgs} args - Arguments to update many Zones.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Zones and only return the `zoneid`
     * const zoneWithZoneidOnly = await prisma.zone.updateManyAndReturn({
     *   select: { zoneid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends zoneUpdateManyAndReturnArgs>(args: SelectSubset<T, zoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Zone.
     * @param {zoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
     */
    upsert<T extends zoneUpsertArgs>(args: SelectSubset<T, zoneUpsertArgs<ExtArgs>>): Prisma__zoneClient<$Result.GetResult<Prisma.$zonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends zoneCountArgs>(
      args?: Subset<T, zoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends zoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: zoneGroupByArgs['orderBy'] }
        : { orderBy?: zoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, zoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the zone model
   */
  readonly fields: zoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__zoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    building<T extends zone$buildingArgs<ExtArgs> = {}>(args?: Subset<T, zone$buildingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$buildingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    truckzone<T extends zone$truckzoneArgs<ExtArgs> = {}>(args?: Subset<T, zone$truckzoneArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$truckzonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the zone model
   */
  interface zoneFieldRefs {
    readonly zoneid: FieldRef<"zone", 'String'>
    readonly zonename: FieldRef<"zone", 'String'>
  }
    

  // Custom InputTypes
  /**
   * zone findUnique
   */
  export type zoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter, which zone to fetch.
     */
    where: zoneWhereUniqueInput
  }

  /**
   * zone findUniqueOrThrow
   */
  export type zoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter, which zone to fetch.
     */
    where: zoneWhereUniqueInput
  }

  /**
   * zone findFirst
   */
  export type zoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter, which zone to fetch.
     */
    where?: zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zones.
     */
    cursor?: zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * zone findFirstOrThrow
   */
  export type zoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter, which zone to fetch.
     */
    where?: zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zones.
     */
    cursor?: zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * zone findMany
   */
  export type zoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter, which zones to fetch.
     */
    where?: zoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zones to fetch.
     */
    orderBy?: zoneOrderByWithRelationInput | zoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing zones.
     */
    cursor?: zoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * zone create
   */
  export type zoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * The data needed to create a zone.
     */
    data: XOR<zoneCreateInput, zoneUncheckedCreateInput>
  }

  /**
   * zone createMany
   */
  export type zoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many zones.
     */
    data: zoneCreateManyInput | zoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * zone createManyAndReturn
   */
  export type zoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * The data used to create many zones.
     */
    data: zoneCreateManyInput | zoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * zone update
   */
  export type zoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * The data needed to update a zone.
     */
    data: XOR<zoneUpdateInput, zoneUncheckedUpdateInput>
    /**
     * Choose, which zone to update.
     */
    where: zoneWhereUniqueInput
  }

  /**
   * zone updateMany
   */
  export type zoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update zones.
     */
    data: XOR<zoneUpdateManyMutationInput, zoneUncheckedUpdateManyInput>
    /**
     * Filter which zones to update
     */
    where?: zoneWhereInput
    /**
     * Limit how many zones to update.
     */
    limit?: number
  }

  /**
   * zone updateManyAndReturn
   */
  export type zoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * The data used to update zones.
     */
    data: XOR<zoneUpdateManyMutationInput, zoneUncheckedUpdateManyInput>
    /**
     * Filter which zones to update
     */
    where?: zoneWhereInput
    /**
     * Limit how many zones to update.
     */
    limit?: number
  }

  /**
   * zone upsert
   */
  export type zoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * The filter to search for the zone to update in case it exists.
     */
    where: zoneWhereUniqueInput
    /**
     * In case the zone found by the `where` argument doesn't exist, create a new zone with this data.
     */
    create: XOR<zoneCreateInput, zoneUncheckedCreateInput>
    /**
     * In case the zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<zoneUpdateInput, zoneUncheckedUpdateInput>
  }

  /**
   * zone delete
   */
  export type zoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
    /**
     * Filter which zone to delete.
     */
    where: zoneWhereUniqueInput
  }

  /**
   * zone deleteMany
   */
  export type zoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which zones to delete
     */
    where?: zoneWhereInput
    /**
     * Limit how many zones to delete.
     */
    limit?: number
  }

  /**
   * zone.building
   */
  export type zone$buildingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the building
     */
    select?: buildingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the building
     */
    omit?: buildingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: buildingInclude<ExtArgs> | null
    where?: buildingWhereInput
    orderBy?: buildingOrderByWithRelationInput | buildingOrderByWithRelationInput[]
    cursor?: buildingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * zone.truckzone
   */
  export type zone$truckzoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the truckzone
     */
    select?: truckzoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the truckzone
     */
    omit?: truckzoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: truckzoneInclude<ExtArgs> | null
    where?: truckzoneWhereInput
    orderBy?: truckzoneOrderByWithRelationInput | truckzoneOrderByWithRelationInput[]
    cursor?: truckzoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TruckzoneScalarFieldEnum | TruckzoneScalarFieldEnum[]
  }

  /**
   * zone without action
   */
  export type zoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the zone
     */
    select?: zoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the zone
     */
    omit?: zoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: zoneInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BuildingScalarFieldEnum: {
    buildingid: 'buildingid',
    buildingname: 'buildingname',
    housingtype: 'housingtype',
    postalcode: 'postalcode',
    zoneid: 'zoneid',
    vehiclesizelimit: 'vehiclesizelimit',
    vehiclelengthlimit: 'vehiclelengthlimit',
    vehiclewidthlimit: 'vehiclewidthlimit',
    loadingbayavailable: 'loadingbayavailable',
    liftavailable: 'liftavailable',
    stairsavailable: 'stairsavailable',
    narrowdoorways: 'narrowdoorways',
    parkingdistance: 'parkingdistance',
    preregistrationrequired: 'preregistrationrequired',
    accesstimewindowstart: 'accesstimewindowstart',
    accesstimewindowend: 'accesstimewindowend',
    notes: 'notes',
    specialequipmentneeded: 'specialequipmentneeded',
    liftdimensions: 'liftdimensions'
  };

  export type BuildingScalarFieldEnum = (typeof BuildingScalarFieldEnum)[keyof typeof BuildingScalarFieldEnum]


  export const ChatsScalarFieldEnum: {
    chatid: 'chatid',
    ordernumber: 'ordernumber',
    members: 'members',
    names: 'names',
    createdat: 'createdat',
    lastmessageat: 'lastmessageat'
  };

  export type ChatsScalarFieldEnum = (typeof ChatsScalarFieldEnum)[keyof typeof ChatsScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    customerid: 'customerid',
    name: 'name',
    displayname: 'displayname',
    email: 'email',
    phone: 'phone',
    address: 'address',
    city: 'city',
    state: 'state',
    postcode: 'postcode',
    bio: 'bio',
    notificationsenabled: 'notificationsenabled',
    createdat: 'createdat'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    employeeid: 'employeeid',
    name: 'name',
    email: 'email',
    contact_number: 'contact_number',
    role: 'role',
    active_flag: 'active_flag',
    displayname: 'displayname',
    createdat: 'createdat',
    bio: 'bio'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const EmployeeteamassignmentScalarFieldEnum: {
    employeeid: 'employeeid',
    teamid: 'teamid'
  };

  export type EmployeeteamassignmentScalarFieldEnum = (typeof EmployeeteamassignmentScalarFieldEnum)[keyof typeof EmployeeteamassignmentScalarFieldEnum]


  export const LorrytripScalarFieldEnum: {
    lorrytripid: 'lorrytripid',
    deliveryteamid: 'deliveryteamid',
    warehouseteamid: 'warehouseteamid',
    truckid: 'truckid'
  };

  export type LorrytripScalarFieldEnum = (typeof LorrytripScalarFieldEnum)[keyof typeof LorrytripScalarFieldEnum]


  export const OrderproductScalarFieldEnum: {
    orderid: 'orderid',
    productid: 'productid',
    quantity: 'quantity'
  };

  export type OrderproductScalarFieldEnum = (typeof OrderproductScalarFieldEnum)[keyof typeof OrderproductScalarFieldEnum]


  export const OrdersScalarFieldEnum: {
    orderid: 'orderid',
    customerid: 'customerid',
    employeeid: 'employeeid',
    deliveryteamid: 'deliveryteamid',
    buildingid: 'buildingid',
    timeslotid: 'timeslotid',
    numberofattempts: 'numberofattempts',
    scheduledstartdatetime: 'scheduledstartdatetime',
    scheduledenddatetime: 'scheduledenddatetime',
    actualstartdatetime: 'actualstartdatetime',
    actualenddatetime: 'actualenddatetime',
    actualarrivaldatetime: 'actualarrivaldatetime',
    customerrating: 'customerrating',
    delayreason: 'delayreason',
    customerfeedback: 'customerfeedback',
    proofofdeliveryurl: 'proofofdeliveryurl',
    orderstatus: 'orderstatus',
    updatedat: 'updatedat',
    createdat: 'createdat'
  };

  export type OrdersScalarFieldEnum = (typeof OrdersScalarFieldEnum)[keyof typeof OrdersScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    productid: 'productid',
    productname: 'productname',
    packagelengthcm: 'packagelengthcm',
    packagewidthcm: 'packagewidthcm',
    packageheightcm: 'packageheightcm',
    installerteamrequiredflag: 'installerteamrequiredflag',
    dismantlerequiredflag: 'dismantlerequiredflag',
    dismantleextratime: 'dismantleextratime',
    estimatedinstallationtimemin: 'estimatedinstallationtimemin',
    estimatedinstallationtimemax: 'estimatedinstallationtimemax',
    fragileflag: 'fragileflag',
    noliedownflag: 'noliedownflag'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    teamid: 'teamid',
    teamtype: 'teamtype'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TimeslotScalarFieldEnum: {
    timeslotid: 'timeslotid',
    lorrytripid: 'lorrytripid',
    date: 'date',
    timewindowstart: 'timewindowstart',
    timewindowend: 'timewindowend',
    availableflag: 'availableflag'
  };

  export type TimeslotScalarFieldEnum = (typeof TimeslotScalarFieldEnum)[keyof typeof TimeslotScalarFieldEnum]


  export const TruckScalarFieldEnum: {
    truckid: 'truckid',
    carplate: 'carplate',
    tone: 'tone',
    lengthcm: 'lengthcm',
    widthcm: 'widthcm',
    heightcm: 'heightcm'
  };

  export type TruckScalarFieldEnum = (typeof TruckScalarFieldEnum)[keyof typeof TruckScalarFieldEnum]


  export const TruckzoneScalarFieldEnum: {
    truckid: 'truckid',
    zoneid: 'zoneid',
    isprimaryzone: 'isprimaryzone'
  };

  export type TruckzoneScalarFieldEnum = (typeof TruckzoneScalarFieldEnum)[keyof typeof TruckzoneScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    uid: 'uid',
    name: 'name',
    displayname: 'displayname',
    email: 'email',
    bio: 'bio',
    createdat: 'createdat'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    zoneid: 'zoneid',
    zonename: 'zonename'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type buildingWhereInput = {
    AND?: buildingWhereInput | buildingWhereInput[]
    OR?: buildingWhereInput[]
    NOT?: buildingWhereInput | buildingWhereInput[]
    buildingid?: StringFilter<"building"> | string
    buildingname?: StringNullableFilter<"building"> | string | null
    housingtype?: StringNullableFilter<"building"> | string | null
    postalcode?: StringNullableFilter<"building"> | string | null
    zoneid?: StringNullableFilter<"building"> | string | null
    vehiclesizelimit?: StringNullableFilter<"building"> | string | null
    vehiclelengthlimit?: DecimalNullableFilter<"building"> | Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: DecimalNullableFilter<"building"> | Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: BoolNullableFilter<"building"> | boolean | null
    liftavailable?: BoolNullableFilter<"building"> | boolean | null
    stairsavailable?: BoolNullableFilter<"building"> | boolean | null
    narrowdoorways?: BoolNullableFilter<"building"> | boolean | null
    parkingdistance?: IntNullableFilter<"building"> | number | null
    preregistrationrequired?: BoolNullableFilter<"building"> | boolean | null
    accesstimewindowstart?: DateTimeNullableFilter<"building"> | Date | string | null
    accesstimewindowend?: DateTimeNullableFilter<"building"> | Date | string | null
    notes?: StringNullableFilter<"building"> | string | null
    specialequipmentneeded?: StringNullableFilter<"building"> | string | null
    liftdimensions?: StringNullableFilter<"building"> | string | null
    zone?: XOR<ZoneNullableScalarRelationFilter, zoneWhereInput> | null
    orders?: OrdersListRelationFilter
  }

  export type buildingOrderByWithRelationInput = {
    buildingid?: SortOrder
    buildingname?: SortOrderInput | SortOrder
    housingtype?: SortOrderInput | SortOrder
    postalcode?: SortOrderInput | SortOrder
    zoneid?: SortOrderInput | SortOrder
    vehiclesizelimit?: SortOrderInput | SortOrder
    vehiclelengthlimit?: SortOrderInput | SortOrder
    vehiclewidthlimit?: SortOrderInput | SortOrder
    loadingbayavailable?: SortOrderInput | SortOrder
    liftavailable?: SortOrderInput | SortOrder
    stairsavailable?: SortOrderInput | SortOrder
    narrowdoorways?: SortOrderInput | SortOrder
    parkingdistance?: SortOrderInput | SortOrder
    preregistrationrequired?: SortOrderInput | SortOrder
    accesstimewindowstart?: SortOrderInput | SortOrder
    accesstimewindowend?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    specialequipmentneeded?: SortOrderInput | SortOrder
    liftdimensions?: SortOrderInput | SortOrder
    zone?: zoneOrderByWithRelationInput
    orders?: ordersOrderByRelationAggregateInput
  }

  export type buildingWhereUniqueInput = Prisma.AtLeast<{
    buildingid?: string
    AND?: buildingWhereInput | buildingWhereInput[]
    OR?: buildingWhereInput[]
    NOT?: buildingWhereInput | buildingWhereInput[]
    buildingname?: StringNullableFilter<"building"> | string | null
    housingtype?: StringNullableFilter<"building"> | string | null
    postalcode?: StringNullableFilter<"building"> | string | null
    zoneid?: StringNullableFilter<"building"> | string | null
    vehiclesizelimit?: StringNullableFilter<"building"> | string | null
    vehiclelengthlimit?: DecimalNullableFilter<"building"> | Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: DecimalNullableFilter<"building"> | Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: BoolNullableFilter<"building"> | boolean | null
    liftavailable?: BoolNullableFilter<"building"> | boolean | null
    stairsavailable?: BoolNullableFilter<"building"> | boolean | null
    narrowdoorways?: BoolNullableFilter<"building"> | boolean | null
    parkingdistance?: IntNullableFilter<"building"> | number | null
    preregistrationrequired?: BoolNullableFilter<"building"> | boolean | null
    accesstimewindowstart?: DateTimeNullableFilter<"building"> | Date | string | null
    accesstimewindowend?: DateTimeNullableFilter<"building"> | Date | string | null
    notes?: StringNullableFilter<"building"> | string | null
    specialequipmentneeded?: StringNullableFilter<"building"> | string | null
    liftdimensions?: StringNullableFilter<"building"> | string | null
    zone?: XOR<ZoneNullableScalarRelationFilter, zoneWhereInput> | null
    orders?: OrdersListRelationFilter
  }, "buildingid">

  export type buildingOrderByWithAggregationInput = {
    buildingid?: SortOrder
    buildingname?: SortOrderInput | SortOrder
    housingtype?: SortOrderInput | SortOrder
    postalcode?: SortOrderInput | SortOrder
    zoneid?: SortOrderInput | SortOrder
    vehiclesizelimit?: SortOrderInput | SortOrder
    vehiclelengthlimit?: SortOrderInput | SortOrder
    vehiclewidthlimit?: SortOrderInput | SortOrder
    loadingbayavailable?: SortOrderInput | SortOrder
    liftavailable?: SortOrderInput | SortOrder
    stairsavailable?: SortOrderInput | SortOrder
    narrowdoorways?: SortOrderInput | SortOrder
    parkingdistance?: SortOrderInput | SortOrder
    preregistrationrequired?: SortOrderInput | SortOrder
    accesstimewindowstart?: SortOrderInput | SortOrder
    accesstimewindowend?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    specialequipmentneeded?: SortOrderInput | SortOrder
    liftdimensions?: SortOrderInput | SortOrder
    _count?: buildingCountOrderByAggregateInput
    _avg?: buildingAvgOrderByAggregateInput
    _max?: buildingMaxOrderByAggregateInput
    _min?: buildingMinOrderByAggregateInput
    _sum?: buildingSumOrderByAggregateInput
  }

  export type buildingScalarWhereWithAggregatesInput = {
    AND?: buildingScalarWhereWithAggregatesInput | buildingScalarWhereWithAggregatesInput[]
    OR?: buildingScalarWhereWithAggregatesInput[]
    NOT?: buildingScalarWhereWithAggregatesInput | buildingScalarWhereWithAggregatesInput[]
    buildingid?: StringWithAggregatesFilter<"building"> | string
    buildingname?: StringNullableWithAggregatesFilter<"building"> | string | null
    housingtype?: StringNullableWithAggregatesFilter<"building"> | string | null
    postalcode?: StringNullableWithAggregatesFilter<"building"> | string | null
    zoneid?: StringNullableWithAggregatesFilter<"building"> | string | null
    vehiclesizelimit?: StringNullableWithAggregatesFilter<"building"> | string | null
    vehiclelengthlimit?: DecimalNullableWithAggregatesFilter<"building"> | Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: DecimalNullableWithAggregatesFilter<"building"> | Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: BoolNullableWithAggregatesFilter<"building"> | boolean | null
    liftavailable?: BoolNullableWithAggregatesFilter<"building"> | boolean | null
    stairsavailable?: BoolNullableWithAggregatesFilter<"building"> | boolean | null
    narrowdoorways?: BoolNullableWithAggregatesFilter<"building"> | boolean | null
    parkingdistance?: IntNullableWithAggregatesFilter<"building"> | number | null
    preregistrationrequired?: BoolNullableWithAggregatesFilter<"building"> | boolean | null
    accesstimewindowstart?: DateTimeNullableWithAggregatesFilter<"building"> | Date | string | null
    accesstimewindowend?: DateTimeNullableWithAggregatesFilter<"building"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"building"> | string | null
    specialequipmentneeded?: StringNullableWithAggregatesFilter<"building"> | string | null
    liftdimensions?: StringNullableWithAggregatesFilter<"building"> | string | null
  }

  export type chatsWhereInput = {
    AND?: chatsWhereInput | chatsWhereInput[]
    OR?: chatsWhereInput[]
    NOT?: chatsWhereInput | chatsWhereInput[]
    chatid?: StringFilter<"chats"> | string
    ordernumber?: StringNullableFilter<"chats"> | string | null
    members?: StringNullableFilter<"chats"> | string | null
    names?: StringNullableFilter<"chats"> | string | null
    createdat?: DateTimeNullableFilter<"chats"> | Date | string | null
    lastmessageat?: DateTimeNullableFilter<"chats"> | Date | string | null
  }

  export type chatsOrderByWithRelationInput = {
    chatid?: SortOrder
    ordernumber?: SortOrderInput | SortOrder
    members?: SortOrderInput | SortOrder
    names?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
    lastmessageat?: SortOrderInput | SortOrder
  }

  export type chatsWhereUniqueInput = Prisma.AtLeast<{
    chatid?: string
    AND?: chatsWhereInput | chatsWhereInput[]
    OR?: chatsWhereInput[]
    NOT?: chatsWhereInput | chatsWhereInput[]
    ordernumber?: StringNullableFilter<"chats"> | string | null
    members?: StringNullableFilter<"chats"> | string | null
    names?: StringNullableFilter<"chats"> | string | null
    createdat?: DateTimeNullableFilter<"chats"> | Date | string | null
    lastmessageat?: DateTimeNullableFilter<"chats"> | Date | string | null
  }, "chatid">

  export type chatsOrderByWithAggregationInput = {
    chatid?: SortOrder
    ordernumber?: SortOrderInput | SortOrder
    members?: SortOrderInput | SortOrder
    names?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
    lastmessageat?: SortOrderInput | SortOrder
    _count?: chatsCountOrderByAggregateInput
    _max?: chatsMaxOrderByAggregateInput
    _min?: chatsMinOrderByAggregateInput
  }

  export type chatsScalarWhereWithAggregatesInput = {
    AND?: chatsScalarWhereWithAggregatesInput | chatsScalarWhereWithAggregatesInput[]
    OR?: chatsScalarWhereWithAggregatesInput[]
    NOT?: chatsScalarWhereWithAggregatesInput | chatsScalarWhereWithAggregatesInput[]
    chatid?: StringWithAggregatesFilter<"chats"> | string
    ordernumber?: StringNullableWithAggregatesFilter<"chats"> | string | null
    members?: StringNullableWithAggregatesFilter<"chats"> | string | null
    names?: StringNullableWithAggregatesFilter<"chats"> | string | null
    createdat?: DateTimeNullableWithAggregatesFilter<"chats"> | Date | string | null
    lastmessageat?: DateTimeNullableWithAggregatesFilter<"chats"> | Date | string | null
  }

  export type customerWhereInput = {
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    customerid?: StringFilter<"customer"> | string
    name?: StringNullableFilter<"customer"> | string | null
    displayname?: StringNullableFilter<"customer"> | string | null
    email?: StringNullableFilter<"customer"> | string | null
    phone?: StringNullableFilter<"customer"> | string | null
    address?: StringNullableFilter<"customer"> | string | null
    city?: StringNullableFilter<"customer"> | string | null
    state?: StringNullableFilter<"customer"> | string | null
    postcode?: StringNullableFilter<"customer"> | string | null
    bio?: StringNullableFilter<"customer"> | string | null
    notificationsenabled?: BoolNullableFilter<"customer"> | boolean | null
    createdat?: DateTimeNullableFilter<"customer"> | Date | string | null
    orders?: OrdersListRelationFilter
  }

  export type customerOrderByWithRelationInput = {
    customerid?: SortOrder
    name?: SortOrderInput | SortOrder
    displayname?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    notificationsenabled?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
    orders?: ordersOrderByRelationAggregateInput
  }

  export type customerWhereUniqueInput = Prisma.AtLeast<{
    customerid?: string
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    name?: StringNullableFilter<"customer"> | string | null
    displayname?: StringNullableFilter<"customer"> | string | null
    email?: StringNullableFilter<"customer"> | string | null
    phone?: StringNullableFilter<"customer"> | string | null
    address?: StringNullableFilter<"customer"> | string | null
    city?: StringNullableFilter<"customer"> | string | null
    state?: StringNullableFilter<"customer"> | string | null
    postcode?: StringNullableFilter<"customer"> | string | null
    bio?: StringNullableFilter<"customer"> | string | null
    notificationsenabled?: BoolNullableFilter<"customer"> | boolean | null
    createdat?: DateTimeNullableFilter<"customer"> | Date | string | null
    orders?: OrdersListRelationFilter
  }, "customerid">

  export type customerOrderByWithAggregationInput = {
    customerid?: SortOrder
    name?: SortOrderInput | SortOrder
    displayname?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    notificationsenabled?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
    _count?: customerCountOrderByAggregateInput
    _max?: customerMaxOrderByAggregateInput
    _min?: customerMinOrderByAggregateInput
  }

  export type customerScalarWhereWithAggregatesInput = {
    AND?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    OR?: customerScalarWhereWithAggregatesInput[]
    NOT?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    customerid?: StringWithAggregatesFilter<"customer"> | string
    name?: StringNullableWithAggregatesFilter<"customer"> | string | null
    displayname?: StringNullableWithAggregatesFilter<"customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"customer"> | string | null
    city?: StringNullableWithAggregatesFilter<"customer"> | string | null
    state?: StringNullableWithAggregatesFilter<"customer"> | string | null
    postcode?: StringNullableWithAggregatesFilter<"customer"> | string | null
    bio?: StringNullableWithAggregatesFilter<"customer"> | string | null
    notificationsenabled?: BoolNullableWithAggregatesFilter<"customer"> | boolean | null
    createdat?: DateTimeNullableWithAggregatesFilter<"customer"> | Date | string | null
  }

  export type employeeWhereInput = {
    AND?: employeeWhereInput | employeeWhereInput[]
    OR?: employeeWhereInput[]
    NOT?: employeeWhereInput | employeeWhereInput[]
    employeeid?: StringFilter<"employee"> | string
    name?: StringNullableFilter<"employee"> | string | null
    email?: StringNullableFilter<"employee"> | string | null
    contact_number?: StringNullableFilter<"employee"> | string | null
    role?: StringNullableFilter<"employee"> | string | null
    active_flag?: BoolNullableFilter<"employee"> | boolean | null
    displayname?: StringNullableFilter<"employee"> | string | null
    createdat?: DateTimeNullableFilter<"employee"> | Date | string | null
    bio?: StringNullableFilter<"employee"> | string | null
    employeeteamassignment?: EmployeeteamassignmentListRelationFilter
    orders?: OrdersListRelationFilter
  }

  export type employeeOrderByWithRelationInput = {
    employeeid?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    contact_number?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    active_flag?: SortOrderInput | SortOrder
    displayname?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    employeeteamassignment?: employeeteamassignmentOrderByRelationAggregateInput
    orders?: ordersOrderByRelationAggregateInput
  }

  export type employeeWhereUniqueInput = Prisma.AtLeast<{
    employeeid?: string
    AND?: employeeWhereInput | employeeWhereInput[]
    OR?: employeeWhereInput[]
    NOT?: employeeWhereInput | employeeWhereInput[]
    name?: StringNullableFilter<"employee"> | string | null
    email?: StringNullableFilter<"employee"> | string | null
    contact_number?: StringNullableFilter<"employee"> | string | null
    role?: StringNullableFilter<"employee"> | string | null
    active_flag?: BoolNullableFilter<"employee"> | boolean | null
    displayname?: StringNullableFilter<"employee"> | string | null
    createdat?: DateTimeNullableFilter<"employee"> | Date | string | null
    bio?: StringNullableFilter<"employee"> | string | null
    employeeteamassignment?: EmployeeteamassignmentListRelationFilter
    orders?: OrdersListRelationFilter
  }, "employeeid">

  export type employeeOrderByWithAggregationInput = {
    employeeid?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    contact_number?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    active_flag?: SortOrderInput | SortOrder
    displayname?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    _count?: employeeCountOrderByAggregateInput
    _max?: employeeMaxOrderByAggregateInput
    _min?: employeeMinOrderByAggregateInput
  }

  export type employeeScalarWhereWithAggregatesInput = {
    AND?: employeeScalarWhereWithAggregatesInput | employeeScalarWhereWithAggregatesInput[]
    OR?: employeeScalarWhereWithAggregatesInput[]
    NOT?: employeeScalarWhereWithAggregatesInput | employeeScalarWhereWithAggregatesInput[]
    employeeid?: StringWithAggregatesFilter<"employee"> | string
    name?: StringNullableWithAggregatesFilter<"employee"> | string | null
    email?: StringNullableWithAggregatesFilter<"employee"> | string | null
    contact_number?: StringNullableWithAggregatesFilter<"employee"> | string | null
    role?: StringNullableWithAggregatesFilter<"employee"> | string | null
    active_flag?: BoolNullableWithAggregatesFilter<"employee"> | boolean | null
    displayname?: StringNullableWithAggregatesFilter<"employee"> | string | null
    createdat?: DateTimeNullableWithAggregatesFilter<"employee"> | Date | string | null
    bio?: StringNullableWithAggregatesFilter<"employee"> | string | null
  }

  export type employeeteamassignmentWhereInput = {
    AND?: employeeteamassignmentWhereInput | employeeteamassignmentWhereInput[]
    OR?: employeeteamassignmentWhereInput[]
    NOT?: employeeteamassignmentWhereInput | employeeteamassignmentWhereInput[]
    employeeid?: StringFilter<"employeeteamassignment"> | string
    teamid?: StringFilter<"employeeteamassignment"> | string
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    team?: XOR<TeamScalarRelationFilter, teamWhereInput>
  }

  export type employeeteamassignmentOrderByWithRelationInput = {
    employeeid?: SortOrder
    teamid?: SortOrder
    employee?: employeeOrderByWithRelationInput
    team?: teamOrderByWithRelationInput
  }

  export type employeeteamassignmentWhereUniqueInput = Prisma.AtLeast<{
    employeeid_teamid?: employeeteamassignmentEmployeeidTeamidCompoundUniqueInput
    AND?: employeeteamassignmentWhereInput | employeeteamassignmentWhereInput[]
    OR?: employeeteamassignmentWhereInput[]
    NOT?: employeeteamassignmentWhereInput | employeeteamassignmentWhereInput[]
    employeeid?: StringFilter<"employeeteamassignment"> | string
    teamid?: StringFilter<"employeeteamassignment"> | string
    employee?: XOR<EmployeeScalarRelationFilter, employeeWhereInput>
    team?: XOR<TeamScalarRelationFilter, teamWhereInput>
  }, "employeeid_teamid">

  export type employeeteamassignmentOrderByWithAggregationInput = {
    employeeid?: SortOrder
    teamid?: SortOrder
    _count?: employeeteamassignmentCountOrderByAggregateInput
    _max?: employeeteamassignmentMaxOrderByAggregateInput
    _min?: employeeteamassignmentMinOrderByAggregateInput
  }

  export type employeeteamassignmentScalarWhereWithAggregatesInput = {
    AND?: employeeteamassignmentScalarWhereWithAggregatesInput | employeeteamassignmentScalarWhereWithAggregatesInput[]
    OR?: employeeteamassignmentScalarWhereWithAggregatesInput[]
    NOT?: employeeteamassignmentScalarWhereWithAggregatesInput | employeeteamassignmentScalarWhereWithAggregatesInput[]
    employeeid?: StringWithAggregatesFilter<"employeeteamassignment"> | string
    teamid?: StringWithAggregatesFilter<"employeeteamassignment"> | string
  }

  export type lorrytripWhereInput = {
    AND?: lorrytripWhereInput | lorrytripWhereInput[]
    OR?: lorrytripWhereInput[]
    NOT?: lorrytripWhereInput | lorrytripWhereInput[]
    lorrytripid?: StringFilter<"lorrytrip"> | string
    deliveryteamid?: StringNullableFilter<"lorrytrip"> | string | null
    warehouseteamid?: StringNullableFilter<"lorrytrip"> | string | null
    truckid?: StringNullableFilter<"lorrytrip"> | string | null
    team_lorrytrip_deliveryteamidToteam?: XOR<TeamNullableScalarRelationFilter, teamWhereInput> | null
    truck?: XOR<TruckNullableScalarRelationFilter, truckWhereInput> | null
    team_lorrytrip_warehouseteamidToteam?: XOR<TeamNullableScalarRelationFilter, teamWhereInput> | null
    timeslot?: TimeslotListRelationFilter
  }

  export type lorrytripOrderByWithRelationInput = {
    lorrytripid?: SortOrder
    deliveryteamid?: SortOrderInput | SortOrder
    warehouseteamid?: SortOrderInput | SortOrder
    truckid?: SortOrderInput | SortOrder
    team_lorrytrip_deliveryteamidToteam?: teamOrderByWithRelationInput
    truck?: truckOrderByWithRelationInput
    team_lorrytrip_warehouseteamidToteam?: teamOrderByWithRelationInput
    timeslot?: timeslotOrderByRelationAggregateInput
  }

  export type lorrytripWhereUniqueInput = Prisma.AtLeast<{
    lorrytripid?: string
    AND?: lorrytripWhereInput | lorrytripWhereInput[]
    OR?: lorrytripWhereInput[]
    NOT?: lorrytripWhereInput | lorrytripWhereInput[]
    deliveryteamid?: StringNullableFilter<"lorrytrip"> | string | null
    warehouseteamid?: StringNullableFilter<"lorrytrip"> | string | null
    truckid?: StringNullableFilter<"lorrytrip"> | string | null
    team_lorrytrip_deliveryteamidToteam?: XOR<TeamNullableScalarRelationFilter, teamWhereInput> | null
    truck?: XOR<TruckNullableScalarRelationFilter, truckWhereInput> | null
    team_lorrytrip_warehouseteamidToteam?: XOR<TeamNullableScalarRelationFilter, teamWhereInput> | null
    timeslot?: TimeslotListRelationFilter
  }, "lorrytripid">

  export type lorrytripOrderByWithAggregationInput = {
    lorrytripid?: SortOrder
    deliveryteamid?: SortOrderInput | SortOrder
    warehouseteamid?: SortOrderInput | SortOrder
    truckid?: SortOrderInput | SortOrder
    _count?: lorrytripCountOrderByAggregateInput
    _max?: lorrytripMaxOrderByAggregateInput
    _min?: lorrytripMinOrderByAggregateInput
  }

  export type lorrytripScalarWhereWithAggregatesInput = {
    AND?: lorrytripScalarWhereWithAggregatesInput | lorrytripScalarWhereWithAggregatesInput[]
    OR?: lorrytripScalarWhereWithAggregatesInput[]
    NOT?: lorrytripScalarWhereWithAggregatesInput | lorrytripScalarWhereWithAggregatesInput[]
    lorrytripid?: StringWithAggregatesFilter<"lorrytrip"> | string
    deliveryteamid?: StringNullableWithAggregatesFilter<"lorrytrip"> | string | null
    warehouseteamid?: StringNullableWithAggregatesFilter<"lorrytrip"> | string | null
    truckid?: StringNullableWithAggregatesFilter<"lorrytrip"> | string | null
  }

  export type orderproductWhereInput = {
    AND?: orderproductWhereInput | orderproductWhereInput[]
    OR?: orderproductWhereInput[]
    NOT?: orderproductWhereInput | orderproductWhereInput[]
    orderid?: StringFilter<"orderproduct"> | string
    productid?: StringFilter<"orderproduct"> | string
    quantity?: IntNullableFilter<"orderproduct"> | number | null
    orders?: XOR<OrdersScalarRelationFilter, ordersWhereInput>
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
  }

  export type orderproductOrderByWithRelationInput = {
    orderid?: SortOrder
    productid?: SortOrder
    quantity?: SortOrderInput | SortOrder
    orders?: ordersOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type orderproductWhereUniqueInput = Prisma.AtLeast<{
    orderid_productid?: orderproductOrderidProductidCompoundUniqueInput
    AND?: orderproductWhereInput | orderproductWhereInput[]
    OR?: orderproductWhereInput[]
    NOT?: orderproductWhereInput | orderproductWhereInput[]
    orderid?: StringFilter<"orderproduct"> | string
    productid?: StringFilter<"orderproduct"> | string
    quantity?: IntNullableFilter<"orderproduct"> | number | null
    orders?: XOR<OrdersScalarRelationFilter, ordersWhereInput>
    product?: XOR<ProductScalarRelationFilter, productWhereInput>
  }, "orderid_productid">

  export type orderproductOrderByWithAggregationInput = {
    orderid?: SortOrder
    productid?: SortOrder
    quantity?: SortOrderInput | SortOrder
    _count?: orderproductCountOrderByAggregateInput
    _avg?: orderproductAvgOrderByAggregateInput
    _max?: orderproductMaxOrderByAggregateInput
    _min?: orderproductMinOrderByAggregateInput
    _sum?: orderproductSumOrderByAggregateInput
  }

  export type orderproductScalarWhereWithAggregatesInput = {
    AND?: orderproductScalarWhereWithAggregatesInput | orderproductScalarWhereWithAggregatesInput[]
    OR?: orderproductScalarWhereWithAggregatesInput[]
    NOT?: orderproductScalarWhereWithAggregatesInput | orderproductScalarWhereWithAggregatesInput[]
    orderid?: StringWithAggregatesFilter<"orderproduct"> | string
    productid?: StringWithAggregatesFilter<"orderproduct"> | string
    quantity?: IntNullableWithAggregatesFilter<"orderproduct"> | number | null
  }

  export type ordersWhereInput = {
    AND?: ordersWhereInput | ordersWhereInput[]
    OR?: ordersWhereInput[]
    NOT?: ordersWhereInput | ordersWhereInput[]
    orderid?: StringFilter<"orders"> | string
    customerid?: StringNullableFilter<"orders"> | string | null
    employeeid?: StringNullableFilter<"orders"> | string | null
    deliveryteamid?: StringNullableFilter<"orders"> | string | null
    buildingid?: StringNullableFilter<"orders"> | string | null
    timeslotid?: StringNullableFilter<"orders"> | string | null
    numberofattempts?: IntNullableFilter<"orders"> | number | null
    scheduledstartdatetime?: DateTimeNullableFilter<"orders"> | Date | string | null
    scheduledenddatetime?: DateTimeNullableFilter<"orders"> | Date | string | null
    actualstartdatetime?: DateTimeNullableFilter<"orders"> | Date | string | null
    actualenddatetime?: DateTimeNullableFilter<"orders"> | Date | string | null
    actualarrivaldatetime?: DateTimeNullableFilter<"orders"> | Date | string | null
    customerrating?: DecimalNullableFilter<"orders"> | Decimal | DecimalJsLike | number | string | null
    delayreason?: StringNullableFilter<"orders"> | string | null
    customerfeedback?: StringNullableFilter<"orders"> | string | null
    proofofdeliveryurl?: StringNullableFilter<"orders"> | string | null
    orderstatus?: StringNullableFilter<"orders"> | string | null
    updatedat?: DateTimeNullableFilter<"orders"> | Date | string | null
    createdat?: DateTimeNullableFilter<"orders"> | Date | string | null
    orderproduct?: OrderproductListRelationFilter
    building?: XOR<BuildingNullableScalarRelationFilter, buildingWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, customerWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, teamWhereInput> | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, employeeWhereInput> | null
    timeslot?: XOR<TimeslotNullableScalarRelationFilter, timeslotWhereInput> | null
  }

  export type ordersOrderByWithRelationInput = {
    orderid?: SortOrder
    customerid?: SortOrderInput | SortOrder
    employeeid?: SortOrderInput | SortOrder
    deliveryteamid?: SortOrderInput | SortOrder
    buildingid?: SortOrderInput | SortOrder
    timeslotid?: SortOrderInput | SortOrder
    numberofattempts?: SortOrderInput | SortOrder
    scheduledstartdatetime?: SortOrderInput | SortOrder
    scheduledenddatetime?: SortOrderInput | SortOrder
    actualstartdatetime?: SortOrderInput | SortOrder
    actualenddatetime?: SortOrderInput | SortOrder
    actualarrivaldatetime?: SortOrderInput | SortOrder
    customerrating?: SortOrderInput | SortOrder
    delayreason?: SortOrderInput | SortOrder
    customerfeedback?: SortOrderInput | SortOrder
    proofofdeliveryurl?: SortOrderInput | SortOrder
    orderstatus?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
    orderproduct?: orderproductOrderByRelationAggregateInput
    building?: buildingOrderByWithRelationInput
    customer?: customerOrderByWithRelationInput
    team?: teamOrderByWithRelationInput
    employee?: employeeOrderByWithRelationInput
    timeslot?: timeslotOrderByWithRelationInput
  }

  export type ordersWhereUniqueInput = Prisma.AtLeast<{
    orderid?: string
    AND?: ordersWhereInput | ordersWhereInput[]
    OR?: ordersWhereInput[]
    NOT?: ordersWhereInput | ordersWhereInput[]
    customerid?: StringNullableFilter<"orders"> | string | null
    employeeid?: StringNullableFilter<"orders"> | string | null
    deliveryteamid?: StringNullableFilter<"orders"> | string | null
    buildingid?: StringNullableFilter<"orders"> | string | null
    timeslotid?: StringNullableFilter<"orders"> | string | null
    numberofattempts?: IntNullableFilter<"orders"> | number | null
    scheduledstartdatetime?: DateTimeNullableFilter<"orders"> | Date | string | null
    scheduledenddatetime?: DateTimeNullableFilter<"orders"> | Date | string | null
    actualstartdatetime?: DateTimeNullableFilter<"orders"> | Date | string | null
    actualenddatetime?: DateTimeNullableFilter<"orders"> | Date | string | null
    actualarrivaldatetime?: DateTimeNullableFilter<"orders"> | Date | string | null
    customerrating?: DecimalNullableFilter<"orders"> | Decimal | DecimalJsLike | number | string | null
    delayreason?: StringNullableFilter<"orders"> | string | null
    customerfeedback?: StringNullableFilter<"orders"> | string | null
    proofofdeliveryurl?: StringNullableFilter<"orders"> | string | null
    orderstatus?: StringNullableFilter<"orders"> | string | null
    updatedat?: DateTimeNullableFilter<"orders"> | Date | string | null
    createdat?: DateTimeNullableFilter<"orders"> | Date | string | null
    orderproduct?: OrderproductListRelationFilter
    building?: XOR<BuildingNullableScalarRelationFilter, buildingWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, customerWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, teamWhereInput> | null
    employee?: XOR<EmployeeNullableScalarRelationFilter, employeeWhereInput> | null
    timeslot?: XOR<TimeslotNullableScalarRelationFilter, timeslotWhereInput> | null
  }, "orderid">

  export type ordersOrderByWithAggregationInput = {
    orderid?: SortOrder
    customerid?: SortOrderInput | SortOrder
    employeeid?: SortOrderInput | SortOrder
    deliveryteamid?: SortOrderInput | SortOrder
    buildingid?: SortOrderInput | SortOrder
    timeslotid?: SortOrderInput | SortOrder
    numberofattempts?: SortOrderInput | SortOrder
    scheduledstartdatetime?: SortOrderInput | SortOrder
    scheduledenddatetime?: SortOrderInput | SortOrder
    actualstartdatetime?: SortOrderInput | SortOrder
    actualenddatetime?: SortOrderInput | SortOrder
    actualarrivaldatetime?: SortOrderInput | SortOrder
    customerrating?: SortOrderInput | SortOrder
    delayreason?: SortOrderInput | SortOrder
    customerfeedback?: SortOrderInput | SortOrder
    proofofdeliveryurl?: SortOrderInput | SortOrder
    orderstatus?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
    _count?: ordersCountOrderByAggregateInput
    _avg?: ordersAvgOrderByAggregateInput
    _max?: ordersMaxOrderByAggregateInput
    _min?: ordersMinOrderByAggregateInput
    _sum?: ordersSumOrderByAggregateInput
  }

  export type ordersScalarWhereWithAggregatesInput = {
    AND?: ordersScalarWhereWithAggregatesInput | ordersScalarWhereWithAggregatesInput[]
    OR?: ordersScalarWhereWithAggregatesInput[]
    NOT?: ordersScalarWhereWithAggregatesInput | ordersScalarWhereWithAggregatesInput[]
    orderid?: StringWithAggregatesFilter<"orders"> | string
    customerid?: StringNullableWithAggregatesFilter<"orders"> | string | null
    employeeid?: StringNullableWithAggregatesFilter<"orders"> | string | null
    deliveryteamid?: StringNullableWithAggregatesFilter<"orders"> | string | null
    buildingid?: StringNullableWithAggregatesFilter<"orders"> | string | null
    timeslotid?: StringNullableWithAggregatesFilter<"orders"> | string | null
    numberofattempts?: IntNullableWithAggregatesFilter<"orders"> | number | null
    scheduledstartdatetime?: DateTimeNullableWithAggregatesFilter<"orders"> | Date | string | null
    scheduledenddatetime?: DateTimeNullableWithAggregatesFilter<"orders"> | Date | string | null
    actualstartdatetime?: DateTimeNullableWithAggregatesFilter<"orders"> | Date | string | null
    actualenddatetime?: DateTimeNullableWithAggregatesFilter<"orders"> | Date | string | null
    actualarrivaldatetime?: DateTimeNullableWithAggregatesFilter<"orders"> | Date | string | null
    customerrating?: DecimalNullableWithAggregatesFilter<"orders"> | Decimal | DecimalJsLike | number | string | null
    delayreason?: StringNullableWithAggregatesFilter<"orders"> | string | null
    customerfeedback?: StringNullableWithAggregatesFilter<"orders"> | string | null
    proofofdeliveryurl?: StringNullableWithAggregatesFilter<"orders"> | string | null
    orderstatus?: StringNullableWithAggregatesFilter<"orders"> | string | null
    updatedat?: DateTimeNullableWithAggregatesFilter<"orders"> | Date | string | null
    createdat?: DateTimeNullableWithAggregatesFilter<"orders"> | Date | string | null
  }

  export type productWhereInput = {
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    productid?: StringFilter<"product"> | string
    productname?: StringNullableFilter<"product"> | string | null
    packagelengthcm?: IntNullableFilter<"product"> | number | null
    packagewidthcm?: IntNullableFilter<"product"> | number | null
    packageheightcm?: IntNullableFilter<"product"> | number | null
    installerteamrequiredflag?: BoolNullableFilter<"product"> | boolean | null
    dismantlerequiredflag?: BoolNullableFilter<"product"> | boolean | null
    dismantleextratime?: IntNullableFilter<"product"> | number | null
    estimatedinstallationtimemin?: IntNullableFilter<"product"> | number | null
    estimatedinstallationtimemax?: IntNullableFilter<"product"> | number | null
    fragileflag?: BoolNullableFilter<"product"> | boolean | null
    noliedownflag?: BoolNullableFilter<"product"> | boolean | null
    orderproduct?: OrderproductListRelationFilter
  }

  export type productOrderByWithRelationInput = {
    productid?: SortOrder
    productname?: SortOrderInput | SortOrder
    packagelengthcm?: SortOrderInput | SortOrder
    packagewidthcm?: SortOrderInput | SortOrder
    packageheightcm?: SortOrderInput | SortOrder
    installerteamrequiredflag?: SortOrderInput | SortOrder
    dismantlerequiredflag?: SortOrderInput | SortOrder
    dismantleextratime?: SortOrderInput | SortOrder
    estimatedinstallationtimemin?: SortOrderInput | SortOrder
    estimatedinstallationtimemax?: SortOrderInput | SortOrder
    fragileflag?: SortOrderInput | SortOrder
    noliedownflag?: SortOrderInput | SortOrder
    orderproduct?: orderproductOrderByRelationAggregateInput
  }

  export type productWhereUniqueInput = Prisma.AtLeast<{
    productid?: string
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    productname?: StringNullableFilter<"product"> | string | null
    packagelengthcm?: IntNullableFilter<"product"> | number | null
    packagewidthcm?: IntNullableFilter<"product"> | number | null
    packageheightcm?: IntNullableFilter<"product"> | number | null
    installerteamrequiredflag?: BoolNullableFilter<"product"> | boolean | null
    dismantlerequiredflag?: BoolNullableFilter<"product"> | boolean | null
    dismantleextratime?: IntNullableFilter<"product"> | number | null
    estimatedinstallationtimemin?: IntNullableFilter<"product"> | number | null
    estimatedinstallationtimemax?: IntNullableFilter<"product"> | number | null
    fragileflag?: BoolNullableFilter<"product"> | boolean | null
    noliedownflag?: BoolNullableFilter<"product"> | boolean | null
    orderproduct?: OrderproductListRelationFilter
  }, "productid">

  export type productOrderByWithAggregationInput = {
    productid?: SortOrder
    productname?: SortOrderInput | SortOrder
    packagelengthcm?: SortOrderInput | SortOrder
    packagewidthcm?: SortOrderInput | SortOrder
    packageheightcm?: SortOrderInput | SortOrder
    installerteamrequiredflag?: SortOrderInput | SortOrder
    dismantlerequiredflag?: SortOrderInput | SortOrder
    dismantleextratime?: SortOrderInput | SortOrder
    estimatedinstallationtimemin?: SortOrderInput | SortOrder
    estimatedinstallationtimemax?: SortOrderInput | SortOrder
    fragileflag?: SortOrderInput | SortOrder
    noliedownflag?: SortOrderInput | SortOrder
    _count?: productCountOrderByAggregateInput
    _avg?: productAvgOrderByAggregateInput
    _max?: productMaxOrderByAggregateInput
    _min?: productMinOrderByAggregateInput
    _sum?: productSumOrderByAggregateInput
  }

  export type productScalarWhereWithAggregatesInput = {
    AND?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    OR?: productScalarWhereWithAggregatesInput[]
    NOT?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    productid?: StringWithAggregatesFilter<"product"> | string
    productname?: StringNullableWithAggregatesFilter<"product"> | string | null
    packagelengthcm?: IntNullableWithAggregatesFilter<"product"> | number | null
    packagewidthcm?: IntNullableWithAggregatesFilter<"product"> | number | null
    packageheightcm?: IntNullableWithAggregatesFilter<"product"> | number | null
    installerteamrequiredflag?: BoolNullableWithAggregatesFilter<"product"> | boolean | null
    dismantlerequiredflag?: BoolNullableWithAggregatesFilter<"product"> | boolean | null
    dismantleextratime?: IntNullableWithAggregatesFilter<"product"> | number | null
    estimatedinstallationtimemin?: IntNullableWithAggregatesFilter<"product"> | number | null
    estimatedinstallationtimemax?: IntNullableWithAggregatesFilter<"product"> | number | null
    fragileflag?: BoolNullableWithAggregatesFilter<"product"> | boolean | null
    noliedownflag?: BoolNullableWithAggregatesFilter<"product"> | boolean | null
  }

  export type teamWhereInput = {
    AND?: teamWhereInput | teamWhereInput[]
    OR?: teamWhereInput[]
    NOT?: teamWhereInput | teamWhereInput[]
    teamid?: StringFilter<"team"> | string
    teamtype?: StringNullableFilter<"team"> | string | null
    employeeteamassignment?: EmployeeteamassignmentListRelationFilter
    lorrytrip_lorrytrip_deliveryteamidToteam?: LorrytripListRelationFilter
    lorrytrip_lorrytrip_warehouseteamidToteam?: LorrytripListRelationFilter
    orders?: OrdersListRelationFilter
  }

  export type teamOrderByWithRelationInput = {
    teamid?: SortOrder
    teamtype?: SortOrderInput | SortOrder
    employeeteamassignment?: employeeteamassignmentOrderByRelationAggregateInput
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripOrderByRelationAggregateInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripOrderByRelationAggregateInput
    orders?: ordersOrderByRelationAggregateInput
  }

  export type teamWhereUniqueInput = Prisma.AtLeast<{
    teamid?: string
    AND?: teamWhereInput | teamWhereInput[]
    OR?: teamWhereInput[]
    NOT?: teamWhereInput | teamWhereInput[]
    teamtype?: StringNullableFilter<"team"> | string | null
    employeeteamassignment?: EmployeeteamassignmentListRelationFilter
    lorrytrip_lorrytrip_deliveryteamidToteam?: LorrytripListRelationFilter
    lorrytrip_lorrytrip_warehouseteamidToteam?: LorrytripListRelationFilter
    orders?: OrdersListRelationFilter
  }, "teamid">

  export type teamOrderByWithAggregationInput = {
    teamid?: SortOrder
    teamtype?: SortOrderInput | SortOrder
    _count?: teamCountOrderByAggregateInput
    _max?: teamMaxOrderByAggregateInput
    _min?: teamMinOrderByAggregateInput
  }

  export type teamScalarWhereWithAggregatesInput = {
    AND?: teamScalarWhereWithAggregatesInput | teamScalarWhereWithAggregatesInput[]
    OR?: teamScalarWhereWithAggregatesInput[]
    NOT?: teamScalarWhereWithAggregatesInput | teamScalarWhereWithAggregatesInput[]
    teamid?: StringWithAggregatesFilter<"team"> | string
    teamtype?: StringNullableWithAggregatesFilter<"team"> | string | null
  }

  export type timeslotWhereInput = {
    AND?: timeslotWhereInput | timeslotWhereInput[]
    OR?: timeslotWhereInput[]
    NOT?: timeslotWhereInput | timeslotWhereInput[]
    timeslotid?: StringFilter<"timeslot"> | string
    lorrytripid?: StringNullableFilter<"timeslot"> | string | null
    date?: DateTimeNullableFilter<"timeslot"> | Date | string | null
    timewindowstart?: DateTimeNullableFilter<"timeslot"> | Date | string | null
    timewindowend?: DateTimeNullableFilter<"timeslot"> | Date | string | null
    availableflag?: BoolNullableFilter<"timeslot"> | boolean | null
    orders?: OrdersListRelationFilter
    lorrytrip?: XOR<LorrytripNullableScalarRelationFilter, lorrytripWhereInput> | null
  }

  export type timeslotOrderByWithRelationInput = {
    timeslotid?: SortOrder
    lorrytripid?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    timewindowstart?: SortOrderInput | SortOrder
    timewindowend?: SortOrderInput | SortOrder
    availableflag?: SortOrderInput | SortOrder
    orders?: ordersOrderByRelationAggregateInput
    lorrytrip?: lorrytripOrderByWithRelationInput
  }

  export type timeslotWhereUniqueInput = Prisma.AtLeast<{
    timeslotid?: string
    AND?: timeslotWhereInput | timeslotWhereInput[]
    OR?: timeslotWhereInput[]
    NOT?: timeslotWhereInput | timeslotWhereInput[]
    lorrytripid?: StringNullableFilter<"timeslot"> | string | null
    date?: DateTimeNullableFilter<"timeslot"> | Date | string | null
    timewindowstart?: DateTimeNullableFilter<"timeslot"> | Date | string | null
    timewindowend?: DateTimeNullableFilter<"timeslot"> | Date | string | null
    availableflag?: BoolNullableFilter<"timeslot"> | boolean | null
    orders?: OrdersListRelationFilter
    lorrytrip?: XOR<LorrytripNullableScalarRelationFilter, lorrytripWhereInput> | null
  }, "timeslotid">

  export type timeslotOrderByWithAggregationInput = {
    timeslotid?: SortOrder
    lorrytripid?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    timewindowstart?: SortOrderInput | SortOrder
    timewindowend?: SortOrderInput | SortOrder
    availableflag?: SortOrderInput | SortOrder
    _count?: timeslotCountOrderByAggregateInput
    _max?: timeslotMaxOrderByAggregateInput
    _min?: timeslotMinOrderByAggregateInput
  }

  export type timeslotScalarWhereWithAggregatesInput = {
    AND?: timeslotScalarWhereWithAggregatesInput | timeslotScalarWhereWithAggregatesInput[]
    OR?: timeslotScalarWhereWithAggregatesInput[]
    NOT?: timeslotScalarWhereWithAggregatesInput | timeslotScalarWhereWithAggregatesInput[]
    timeslotid?: StringWithAggregatesFilter<"timeslot"> | string
    lorrytripid?: StringNullableWithAggregatesFilter<"timeslot"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"timeslot"> | Date | string | null
    timewindowstart?: DateTimeNullableWithAggregatesFilter<"timeslot"> | Date | string | null
    timewindowend?: DateTimeNullableWithAggregatesFilter<"timeslot"> | Date | string | null
    availableflag?: BoolNullableWithAggregatesFilter<"timeslot"> | boolean | null
  }

  export type truckWhereInput = {
    AND?: truckWhereInput | truckWhereInput[]
    OR?: truckWhereInput[]
    NOT?: truckWhereInput | truckWhereInput[]
    truckid?: StringFilter<"truck"> | string
    carplate?: StringNullableFilter<"truck"> | string | null
    tone?: IntNullableFilter<"truck"> | number | null
    lengthcm?: IntNullableFilter<"truck"> | number | null
    widthcm?: IntNullableFilter<"truck"> | number | null
    heightcm?: IntNullableFilter<"truck"> | number | null
    lorrytrip?: LorrytripListRelationFilter
    truckzone?: TruckzoneListRelationFilter
  }

  export type truckOrderByWithRelationInput = {
    truckid?: SortOrder
    carplate?: SortOrderInput | SortOrder
    tone?: SortOrderInput | SortOrder
    lengthcm?: SortOrderInput | SortOrder
    widthcm?: SortOrderInput | SortOrder
    heightcm?: SortOrderInput | SortOrder
    lorrytrip?: lorrytripOrderByRelationAggregateInput
    truckzone?: truckzoneOrderByRelationAggregateInput
  }

  export type truckWhereUniqueInput = Prisma.AtLeast<{
    truckid?: string
    AND?: truckWhereInput | truckWhereInput[]
    OR?: truckWhereInput[]
    NOT?: truckWhereInput | truckWhereInput[]
    carplate?: StringNullableFilter<"truck"> | string | null
    tone?: IntNullableFilter<"truck"> | number | null
    lengthcm?: IntNullableFilter<"truck"> | number | null
    widthcm?: IntNullableFilter<"truck"> | number | null
    heightcm?: IntNullableFilter<"truck"> | number | null
    lorrytrip?: LorrytripListRelationFilter
    truckzone?: TruckzoneListRelationFilter
  }, "truckid">

  export type truckOrderByWithAggregationInput = {
    truckid?: SortOrder
    carplate?: SortOrderInput | SortOrder
    tone?: SortOrderInput | SortOrder
    lengthcm?: SortOrderInput | SortOrder
    widthcm?: SortOrderInput | SortOrder
    heightcm?: SortOrderInput | SortOrder
    _count?: truckCountOrderByAggregateInput
    _avg?: truckAvgOrderByAggregateInput
    _max?: truckMaxOrderByAggregateInput
    _min?: truckMinOrderByAggregateInput
    _sum?: truckSumOrderByAggregateInput
  }

  export type truckScalarWhereWithAggregatesInput = {
    AND?: truckScalarWhereWithAggregatesInput | truckScalarWhereWithAggregatesInput[]
    OR?: truckScalarWhereWithAggregatesInput[]
    NOT?: truckScalarWhereWithAggregatesInput | truckScalarWhereWithAggregatesInput[]
    truckid?: StringWithAggregatesFilter<"truck"> | string
    carplate?: StringNullableWithAggregatesFilter<"truck"> | string | null
    tone?: IntNullableWithAggregatesFilter<"truck"> | number | null
    lengthcm?: IntNullableWithAggregatesFilter<"truck"> | number | null
    widthcm?: IntNullableWithAggregatesFilter<"truck"> | number | null
    heightcm?: IntNullableWithAggregatesFilter<"truck"> | number | null
  }

  export type truckzoneWhereInput = {
    AND?: truckzoneWhereInput | truckzoneWhereInput[]
    OR?: truckzoneWhereInput[]
    NOT?: truckzoneWhereInput | truckzoneWhereInput[]
    truckid?: StringFilter<"truckzone"> | string
    zoneid?: StringFilter<"truckzone"> | string
    isprimaryzone?: BoolNullableFilter<"truckzone"> | boolean | null
    truck?: XOR<TruckScalarRelationFilter, truckWhereInput>
    zone?: XOR<ZoneScalarRelationFilter, zoneWhereInput>
  }

  export type truckzoneOrderByWithRelationInput = {
    truckid?: SortOrder
    zoneid?: SortOrder
    isprimaryzone?: SortOrderInput | SortOrder
    truck?: truckOrderByWithRelationInput
    zone?: zoneOrderByWithRelationInput
  }

  export type truckzoneWhereUniqueInput = Prisma.AtLeast<{
    truckid_zoneid?: truckzoneTruckidZoneidCompoundUniqueInput
    AND?: truckzoneWhereInput | truckzoneWhereInput[]
    OR?: truckzoneWhereInput[]
    NOT?: truckzoneWhereInput | truckzoneWhereInput[]
    truckid?: StringFilter<"truckzone"> | string
    zoneid?: StringFilter<"truckzone"> | string
    isprimaryzone?: BoolNullableFilter<"truckzone"> | boolean | null
    truck?: XOR<TruckScalarRelationFilter, truckWhereInput>
    zone?: XOR<ZoneScalarRelationFilter, zoneWhereInput>
  }, "truckid_zoneid">

  export type truckzoneOrderByWithAggregationInput = {
    truckid?: SortOrder
    zoneid?: SortOrder
    isprimaryzone?: SortOrderInput | SortOrder
    _count?: truckzoneCountOrderByAggregateInput
    _max?: truckzoneMaxOrderByAggregateInput
    _min?: truckzoneMinOrderByAggregateInput
  }

  export type truckzoneScalarWhereWithAggregatesInput = {
    AND?: truckzoneScalarWhereWithAggregatesInput | truckzoneScalarWhereWithAggregatesInput[]
    OR?: truckzoneScalarWhereWithAggregatesInput[]
    NOT?: truckzoneScalarWhereWithAggregatesInput | truckzoneScalarWhereWithAggregatesInput[]
    truckid?: StringWithAggregatesFilter<"truckzone"> | string
    zoneid?: StringWithAggregatesFilter<"truckzone"> | string
    isprimaryzone?: BoolNullableWithAggregatesFilter<"truckzone"> | boolean | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    uid?: StringFilter<"users"> | string
    name?: StringNullableFilter<"users"> | string | null
    displayname?: StringNullableFilter<"users"> | string | null
    email?: StringNullableFilter<"users"> | string | null
    bio?: StringNullableFilter<"users"> | string | null
    createdat?: DateTimeNullableFilter<"users"> | Date | string | null
  }

  export type usersOrderByWithRelationInput = {
    uid?: SortOrder
    name?: SortOrderInput | SortOrder
    displayname?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    uid?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringNullableFilter<"users"> | string | null
    displayname?: StringNullableFilter<"users"> | string | null
    email?: StringNullableFilter<"users"> | string | null
    bio?: StringNullableFilter<"users"> | string | null
    createdat?: DateTimeNullableFilter<"users"> | Date | string | null
  }, "uid">

  export type usersOrderByWithAggregationInput = {
    uid?: SortOrder
    name?: SortOrderInput | SortOrder
    displayname?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    createdat?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    uid?: StringWithAggregatesFilter<"users"> | string
    name?: StringNullableWithAggregatesFilter<"users"> | string | null
    displayname?: StringNullableWithAggregatesFilter<"users"> | string | null
    email?: StringNullableWithAggregatesFilter<"users"> | string | null
    bio?: StringNullableWithAggregatesFilter<"users"> | string | null
    createdat?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type zoneWhereInput = {
    AND?: zoneWhereInput | zoneWhereInput[]
    OR?: zoneWhereInput[]
    NOT?: zoneWhereInput | zoneWhereInput[]
    zoneid?: StringFilter<"zone"> | string
    zonename?: StringNullableFilter<"zone"> | string | null
    building?: BuildingListRelationFilter
    truckzone?: TruckzoneListRelationFilter
  }

  export type zoneOrderByWithRelationInput = {
    zoneid?: SortOrder
    zonename?: SortOrderInput | SortOrder
    building?: buildingOrderByRelationAggregateInput
    truckzone?: truckzoneOrderByRelationAggregateInput
  }

  export type zoneWhereUniqueInput = Prisma.AtLeast<{
    zoneid?: string
    AND?: zoneWhereInput | zoneWhereInput[]
    OR?: zoneWhereInput[]
    NOT?: zoneWhereInput | zoneWhereInput[]
    zonename?: StringNullableFilter<"zone"> | string | null
    building?: BuildingListRelationFilter
    truckzone?: TruckzoneListRelationFilter
  }, "zoneid">

  export type zoneOrderByWithAggregationInput = {
    zoneid?: SortOrder
    zonename?: SortOrderInput | SortOrder
    _count?: zoneCountOrderByAggregateInput
    _max?: zoneMaxOrderByAggregateInput
    _min?: zoneMinOrderByAggregateInput
  }

  export type zoneScalarWhereWithAggregatesInput = {
    AND?: zoneScalarWhereWithAggregatesInput | zoneScalarWhereWithAggregatesInput[]
    OR?: zoneScalarWhereWithAggregatesInput[]
    NOT?: zoneScalarWhereWithAggregatesInput | zoneScalarWhereWithAggregatesInput[]
    zoneid?: StringWithAggregatesFilter<"zone"> | string
    zonename?: StringNullableWithAggregatesFilter<"zone"> | string | null
  }

  export type buildingCreateInput = {
    buildingid: string
    buildingname?: string | null
    housingtype?: string | null
    postalcode?: string | null
    vehiclesizelimit?: string | null
    vehiclelengthlimit?: Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: boolean | null
    liftavailable?: boolean | null
    stairsavailable?: boolean | null
    narrowdoorways?: boolean | null
    parkingdistance?: number | null
    preregistrationrequired?: boolean | null
    accesstimewindowstart?: Date | string | null
    accesstimewindowend?: Date | string | null
    notes?: string | null
    specialequipmentneeded?: string | null
    liftdimensions?: string | null
    zone?: zoneCreateNestedOneWithoutBuildingInput
    orders?: ordersCreateNestedManyWithoutBuildingInput
  }

  export type buildingUncheckedCreateInput = {
    buildingid: string
    buildingname?: string | null
    housingtype?: string | null
    postalcode?: string | null
    zoneid?: string | null
    vehiclesizelimit?: string | null
    vehiclelengthlimit?: Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: boolean | null
    liftavailable?: boolean | null
    stairsavailable?: boolean | null
    narrowdoorways?: boolean | null
    parkingdistance?: number | null
    preregistrationrequired?: boolean | null
    accesstimewindowstart?: Date | string | null
    accesstimewindowend?: Date | string | null
    notes?: string | null
    specialequipmentneeded?: string | null
    liftdimensions?: string | null
    orders?: ordersUncheckedCreateNestedManyWithoutBuildingInput
  }

  export type buildingUpdateInput = {
    buildingid?: StringFieldUpdateOperationsInput | string
    buildingname?: NullableStringFieldUpdateOperationsInput | string | null
    housingtype?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclesizelimit?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclelengthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liftavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stairsavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    narrowdoorways?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parkingdistance?: NullableIntFieldUpdateOperationsInput | number | null
    preregistrationrequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accesstimewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesstimewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specialequipmentneeded?: NullableStringFieldUpdateOperationsInput | string | null
    liftdimensions?: NullableStringFieldUpdateOperationsInput | string | null
    zone?: zoneUpdateOneWithoutBuildingNestedInput
    orders?: ordersUpdateManyWithoutBuildingNestedInput
  }

  export type buildingUncheckedUpdateInput = {
    buildingid?: StringFieldUpdateOperationsInput | string
    buildingname?: NullableStringFieldUpdateOperationsInput | string | null
    housingtype?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    zoneid?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclesizelimit?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclelengthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liftavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stairsavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    narrowdoorways?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parkingdistance?: NullableIntFieldUpdateOperationsInput | number | null
    preregistrationrequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accesstimewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesstimewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specialequipmentneeded?: NullableStringFieldUpdateOperationsInput | string | null
    liftdimensions?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUncheckedUpdateManyWithoutBuildingNestedInput
  }

  export type buildingCreateManyInput = {
    buildingid: string
    buildingname?: string | null
    housingtype?: string | null
    postalcode?: string | null
    zoneid?: string | null
    vehiclesizelimit?: string | null
    vehiclelengthlimit?: Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: boolean | null
    liftavailable?: boolean | null
    stairsavailable?: boolean | null
    narrowdoorways?: boolean | null
    parkingdistance?: number | null
    preregistrationrequired?: boolean | null
    accesstimewindowstart?: Date | string | null
    accesstimewindowend?: Date | string | null
    notes?: string | null
    specialequipmentneeded?: string | null
    liftdimensions?: string | null
  }

  export type buildingUpdateManyMutationInput = {
    buildingid?: StringFieldUpdateOperationsInput | string
    buildingname?: NullableStringFieldUpdateOperationsInput | string | null
    housingtype?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclesizelimit?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclelengthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liftavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stairsavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    narrowdoorways?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parkingdistance?: NullableIntFieldUpdateOperationsInput | number | null
    preregistrationrequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accesstimewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesstimewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specialequipmentneeded?: NullableStringFieldUpdateOperationsInput | string | null
    liftdimensions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type buildingUncheckedUpdateManyInput = {
    buildingid?: StringFieldUpdateOperationsInput | string
    buildingname?: NullableStringFieldUpdateOperationsInput | string | null
    housingtype?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    zoneid?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclesizelimit?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclelengthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liftavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stairsavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    narrowdoorways?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parkingdistance?: NullableIntFieldUpdateOperationsInput | number | null
    preregistrationrequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accesstimewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesstimewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specialequipmentneeded?: NullableStringFieldUpdateOperationsInput | string | null
    liftdimensions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatsCreateInput = {
    chatid: string
    ordernumber?: string | null
    members?: string | null
    names?: string | null
    createdat?: Date | string | null
    lastmessageat?: Date | string | null
  }

  export type chatsUncheckedCreateInput = {
    chatid: string
    ordernumber?: string | null
    members?: string | null
    names?: string | null
    createdat?: Date | string | null
    lastmessageat?: Date | string | null
  }

  export type chatsUpdateInput = {
    chatid?: StringFieldUpdateOperationsInput | string
    ordernumber?: NullableStringFieldUpdateOperationsInput | string | null
    members?: NullableStringFieldUpdateOperationsInput | string | null
    names?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastmessageat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chatsUncheckedUpdateInput = {
    chatid?: StringFieldUpdateOperationsInput | string
    ordernumber?: NullableStringFieldUpdateOperationsInput | string | null
    members?: NullableStringFieldUpdateOperationsInput | string | null
    names?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastmessageat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chatsCreateManyInput = {
    chatid: string
    ordernumber?: string | null
    members?: string | null
    names?: string | null
    createdat?: Date | string | null
    lastmessageat?: Date | string | null
  }

  export type chatsUpdateManyMutationInput = {
    chatid?: StringFieldUpdateOperationsInput | string
    ordernumber?: NullableStringFieldUpdateOperationsInput | string | null
    members?: NullableStringFieldUpdateOperationsInput | string | null
    names?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastmessageat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chatsUncheckedUpdateManyInput = {
    chatid?: StringFieldUpdateOperationsInput | string
    ordernumber?: NullableStringFieldUpdateOperationsInput | string | null
    members?: NullableStringFieldUpdateOperationsInput | string | null
    names?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastmessageat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customerCreateInput = {
    customerid: string
    name?: string | null
    displayname?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    bio?: string | null
    notificationsenabled?: boolean | null
    createdat?: Date | string | null
    orders?: ordersCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateInput = {
    customerid: string
    name?: string | null
    displayname?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    bio?: string | null
    notificationsenabled?: boolean | null
    createdat?: Date | string | null
    orders?: ordersUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerUpdateInput = {
    customerid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsenabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: ordersUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateInput = {
    customerid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsenabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orders?: ordersUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerCreateManyInput = {
    customerid: string
    name?: string | null
    displayname?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    bio?: string | null
    notificationsenabled?: boolean | null
    createdat?: Date | string | null
  }

  export type customerUpdateManyMutationInput = {
    customerid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsenabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customerUncheckedUpdateManyInput = {
    customerid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsenabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employeeCreateInput = {
    employeeid: string
    name?: string | null
    email?: string | null
    contact_number?: string | null
    role?: string | null
    active_flag?: boolean | null
    displayname?: string | null
    createdat?: Date | string | null
    bio?: string | null
    employeeteamassignment?: employeeteamassignmentCreateNestedManyWithoutEmployeeInput
    orders?: ordersCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateInput = {
    employeeid: string
    name?: string | null
    email?: string | null
    contact_number?: string | null
    role?: string | null
    active_flag?: boolean | null
    displayname?: string | null
    createdat?: Date | string | null
    bio?: string | null
    employeeteamassignment?: employeeteamassignmentUncheckedCreateNestedManyWithoutEmployeeInput
    orders?: ordersUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUpdateInput = {
    employeeid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    active_flag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    employeeteamassignment?: employeeteamassignmentUpdateManyWithoutEmployeeNestedInput
    orders?: ordersUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateInput = {
    employeeid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    active_flag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    employeeteamassignment?: employeeteamassignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    orders?: ordersUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeCreateManyInput = {
    employeeid: string
    name?: string | null
    email?: string | null
    contact_number?: string | null
    role?: string | null
    active_flag?: boolean | null
    displayname?: string | null
    createdat?: Date | string | null
    bio?: string | null
  }

  export type employeeUpdateManyMutationInput = {
    employeeid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    active_flag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type employeeUncheckedUpdateManyInput = {
    employeeid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    active_flag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type employeeteamassignmentCreateInput = {
    employee: employeeCreateNestedOneWithoutEmployeeteamassignmentInput
    team: teamCreateNestedOneWithoutEmployeeteamassignmentInput
  }

  export type employeeteamassignmentUncheckedCreateInput = {
    employeeid: string
    teamid: string
  }

  export type employeeteamassignmentUpdateInput = {
    employee?: employeeUpdateOneRequiredWithoutEmployeeteamassignmentNestedInput
    team?: teamUpdateOneRequiredWithoutEmployeeteamassignmentNestedInput
  }

  export type employeeteamassignmentUncheckedUpdateInput = {
    employeeid?: StringFieldUpdateOperationsInput | string
    teamid?: StringFieldUpdateOperationsInput | string
  }

  export type employeeteamassignmentCreateManyInput = {
    employeeid: string
    teamid: string
  }

  export type employeeteamassignmentUpdateManyMutationInput = {

  }

  export type employeeteamassignmentUncheckedUpdateManyInput = {
    employeeid?: StringFieldUpdateOperationsInput | string
    teamid?: StringFieldUpdateOperationsInput | string
  }

  export type lorrytripCreateInput = {
    lorrytripid: string
    team_lorrytrip_deliveryteamidToteam?: teamCreateNestedOneWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput
    truck?: truckCreateNestedOneWithoutLorrytripInput
    team_lorrytrip_warehouseteamidToteam?: teamCreateNestedOneWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput
    timeslot?: timeslotCreateNestedManyWithoutLorrytripInput
  }

  export type lorrytripUncheckedCreateInput = {
    lorrytripid: string
    deliveryteamid?: string | null
    warehouseteamid?: string | null
    truckid?: string | null
    timeslot?: timeslotUncheckedCreateNestedManyWithoutLorrytripInput
  }

  export type lorrytripUpdateInput = {
    lorrytripid?: StringFieldUpdateOperationsInput | string
    team_lorrytrip_deliveryteamidToteam?: teamUpdateOneWithoutLorrytrip_lorrytrip_deliveryteamidToteamNestedInput
    truck?: truckUpdateOneWithoutLorrytripNestedInput
    team_lorrytrip_warehouseteamidToteam?: teamUpdateOneWithoutLorrytrip_lorrytrip_warehouseteamidToteamNestedInput
    timeslot?: timeslotUpdateManyWithoutLorrytripNestedInput
  }

  export type lorrytripUncheckedUpdateInput = {
    lorrytripid?: StringFieldUpdateOperationsInput | string
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseteamid?: NullableStringFieldUpdateOperationsInput | string | null
    truckid?: NullableStringFieldUpdateOperationsInput | string | null
    timeslot?: timeslotUncheckedUpdateManyWithoutLorrytripNestedInput
  }

  export type lorrytripCreateManyInput = {
    lorrytripid: string
    deliveryteamid?: string | null
    warehouseteamid?: string | null
    truckid?: string | null
  }

  export type lorrytripUpdateManyMutationInput = {
    lorrytripid?: StringFieldUpdateOperationsInput | string
  }

  export type lorrytripUncheckedUpdateManyInput = {
    lorrytripid?: StringFieldUpdateOperationsInput | string
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseteamid?: NullableStringFieldUpdateOperationsInput | string | null
    truckid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type orderproductCreateInput = {
    quantity?: number | null
    orders: ordersCreateNestedOneWithoutOrderproductInput
    product: productCreateNestedOneWithoutOrderproductInput
  }

  export type orderproductUncheckedCreateInput = {
    orderid: string
    productid: string
    quantity?: number | null
  }

  export type orderproductUpdateInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    orders?: ordersUpdateOneRequiredWithoutOrderproductNestedInput
    product?: productUpdateOneRequiredWithoutOrderproductNestedInput
  }

  export type orderproductUncheckedUpdateInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    productid?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type orderproductCreateManyInput = {
    orderid: string
    productid: string
    quantity?: number | null
  }

  export type orderproductUpdateManyMutationInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type orderproductUncheckedUpdateManyInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    productid?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ordersCreateInput = {
    orderid: string
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
    orderproduct?: orderproductCreateNestedManyWithoutOrdersInput
    building?: buildingCreateNestedOneWithoutOrdersInput
    customer?: customerCreateNestedOneWithoutOrdersInput
    team?: teamCreateNestedOneWithoutOrdersInput
    employee?: employeeCreateNestedOneWithoutOrdersInput
    timeslot?: timeslotCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateInput = {
    orderid: string
    customerid?: string | null
    employeeid?: string | null
    deliveryteamid?: string | null
    buildingid?: string | null
    timeslotid?: string | null
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
    orderproduct?: orderproductUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type ordersUpdateInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderproduct?: orderproductUpdateManyWithoutOrdersNestedInput
    building?: buildingUpdateOneWithoutOrdersNestedInput
    customer?: customerUpdateOneWithoutOrdersNestedInput
    team?: teamUpdateOneWithoutOrdersNestedInput
    employee?: employeeUpdateOneWithoutOrdersNestedInput
    timeslot?: timeslotUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    employeeid?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    buildingid?: NullableStringFieldUpdateOperationsInput | string | null
    timeslotid?: NullableStringFieldUpdateOperationsInput | string | null
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderproduct?: orderproductUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type ordersCreateManyInput = {
    orderid: string
    customerid?: string | null
    employeeid?: string | null
    deliveryteamid?: string | null
    buildingid?: string | null
    timeslotid?: string | null
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
  }

  export type ordersUpdateManyMutationInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ordersUncheckedUpdateManyInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    employeeid?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    buildingid?: NullableStringFieldUpdateOperationsInput | string | null
    timeslotid?: NullableStringFieldUpdateOperationsInput | string | null
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type productCreateInput = {
    productid: string
    productname?: string | null
    packagelengthcm?: number | null
    packagewidthcm?: number | null
    packageheightcm?: number | null
    installerteamrequiredflag?: boolean | null
    dismantlerequiredflag?: boolean | null
    dismantleextratime?: number | null
    estimatedinstallationtimemin?: number | null
    estimatedinstallationtimemax?: number | null
    fragileflag?: boolean | null
    noliedownflag?: boolean | null
    orderproduct?: orderproductCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateInput = {
    productid: string
    productname?: string | null
    packagelengthcm?: number | null
    packagewidthcm?: number | null
    packageheightcm?: number | null
    installerteamrequiredflag?: boolean | null
    dismantlerequiredflag?: boolean | null
    dismantleextratime?: number | null
    estimatedinstallationtimemin?: number | null
    estimatedinstallationtimemax?: number | null
    fragileflag?: boolean | null
    noliedownflag?: boolean | null
    orderproduct?: orderproductUncheckedCreateNestedManyWithoutProductInput
  }

  export type productUpdateInput = {
    productid?: StringFieldUpdateOperationsInput | string
    productname?: NullableStringFieldUpdateOperationsInput | string | null
    packagelengthcm?: NullableIntFieldUpdateOperationsInput | number | null
    packagewidthcm?: NullableIntFieldUpdateOperationsInput | number | null
    packageheightcm?: NullableIntFieldUpdateOperationsInput | number | null
    installerteamrequiredflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismantlerequiredflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismantleextratime?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedinstallationtimemin?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedinstallationtimemax?: NullableIntFieldUpdateOperationsInput | number | null
    fragileflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    noliedownflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orderproduct?: orderproductUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateInput = {
    productid?: StringFieldUpdateOperationsInput | string
    productname?: NullableStringFieldUpdateOperationsInput | string | null
    packagelengthcm?: NullableIntFieldUpdateOperationsInput | number | null
    packagewidthcm?: NullableIntFieldUpdateOperationsInput | number | null
    packageheightcm?: NullableIntFieldUpdateOperationsInput | number | null
    installerteamrequiredflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismantlerequiredflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismantleextratime?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedinstallationtimemin?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedinstallationtimemax?: NullableIntFieldUpdateOperationsInput | number | null
    fragileflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    noliedownflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orderproduct?: orderproductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productCreateManyInput = {
    productid: string
    productname?: string | null
    packagelengthcm?: number | null
    packagewidthcm?: number | null
    packageheightcm?: number | null
    installerteamrequiredflag?: boolean | null
    dismantlerequiredflag?: boolean | null
    dismantleextratime?: number | null
    estimatedinstallationtimemin?: number | null
    estimatedinstallationtimemax?: number | null
    fragileflag?: boolean | null
    noliedownflag?: boolean | null
  }

  export type productUpdateManyMutationInput = {
    productid?: StringFieldUpdateOperationsInput | string
    productname?: NullableStringFieldUpdateOperationsInput | string | null
    packagelengthcm?: NullableIntFieldUpdateOperationsInput | number | null
    packagewidthcm?: NullableIntFieldUpdateOperationsInput | number | null
    packageheightcm?: NullableIntFieldUpdateOperationsInput | number | null
    installerteamrequiredflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismantlerequiredflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismantleextratime?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedinstallationtimemin?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedinstallationtimemax?: NullableIntFieldUpdateOperationsInput | number | null
    fragileflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    noliedownflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type productUncheckedUpdateManyInput = {
    productid?: StringFieldUpdateOperationsInput | string
    productname?: NullableStringFieldUpdateOperationsInput | string | null
    packagelengthcm?: NullableIntFieldUpdateOperationsInput | number | null
    packagewidthcm?: NullableIntFieldUpdateOperationsInput | number | null
    packageheightcm?: NullableIntFieldUpdateOperationsInput | number | null
    installerteamrequiredflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismantlerequiredflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismantleextratime?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedinstallationtimemin?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedinstallationtimemax?: NullableIntFieldUpdateOperationsInput | number | null
    fragileflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    noliedownflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type teamCreateInput = {
    teamid: string
    teamtype?: string | null
    employeeteamassignment?: employeeteamassignmentCreateNestedManyWithoutTeamInput
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripCreateNestedManyWithoutTeam_lorrytrip_deliveryteamidToteamInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripCreateNestedManyWithoutTeam_lorrytrip_warehouseteamidToteamInput
    orders?: ordersCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateInput = {
    teamid: string
    teamtype?: string | null
    employeeteamassignment?: employeeteamassignmentUncheckedCreateNestedManyWithoutTeamInput
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripUncheckedCreateNestedManyWithoutTeam_lorrytrip_deliveryteamidToteamInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripUncheckedCreateNestedManyWithoutTeam_lorrytrip_warehouseteamidToteamInput
    orders?: ordersUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamUpdateInput = {
    teamid?: StringFieldUpdateOperationsInput | string
    teamtype?: NullableStringFieldUpdateOperationsInput | string | null
    employeeteamassignment?: employeeteamassignmentUpdateManyWithoutTeamNestedInput
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripUpdateManyWithoutTeam_lorrytrip_deliveryteamidToteamNestedInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripUpdateManyWithoutTeam_lorrytrip_warehouseteamidToteamNestedInput
    orders?: ordersUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateInput = {
    teamid?: StringFieldUpdateOperationsInput | string
    teamtype?: NullableStringFieldUpdateOperationsInput | string | null
    employeeteamassignment?: employeeteamassignmentUncheckedUpdateManyWithoutTeamNestedInput
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripUncheckedUpdateManyWithoutTeam_lorrytrip_deliveryteamidToteamNestedInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripUncheckedUpdateManyWithoutTeam_lorrytrip_warehouseteamidToteamNestedInput
    orders?: ordersUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamCreateManyInput = {
    teamid: string
    teamtype?: string | null
  }

  export type teamUpdateManyMutationInput = {
    teamid?: StringFieldUpdateOperationsInput | string
    teamtype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type teamUncheckedUpdateManyInput = {
    teamid?: StringFieldUpdateOperationsInput | string
    teamtype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type timeslotCreateInput = {
    timeslotid: string
    date?: Date | string | null
    timewindowstart?: Date | string | null
    timewindowend?: Date | string | null
    availableflag?: boolean | null
    orders?: ordersCreateNestedManyWithoutTimeslotInput
    lorrytrip?: lorrytripCreateNestedOneWithoutTimeslotInput
  }

  export type timeslotUncheckedCreateInput = {
    timeslotid: string
    lorrytripid?: string | null
    date?: Date | string | null
    timewindowstart?: Date | string | null
    timewindowend?: Date | string | null
    availableflag?: boolean | null
    orders?: ordersUncheckedCreateNestedManyWithoutTimeslotInput
  }

  export type timeslotUpdateInput = {
    timeslotid?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orders?: ordersUpdateManyWithoutTimeslotNestedInput
    lorrytrip?: lorrytripUpdateOneWithoutTimeslotNestedInput
  }

  export type timeslotUncheckedUpdateInput = {
    timeslotid?: StringFieldUpdateOperationsInput | string
    lorrytripid?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orders?: ordersUncheckedUpdateManyWithoutTimeslotNestedInput
  }

  export type timeslotCreateManyInput = {
    timeslotid: string
    lorrytripid?: string | null
    date?: Date | string | null
    timewindowstart?: Date | string | null
    timewindowend?: Date | string | null
    availableflag?: boolean | null
  }

  export type timeslotUpdateManyMutationInput = {
    timeslotid?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type timeslotUncheckedUpdateManyInput = {
    timeslotid?: StringFieldUpdateOperationsInput | string
    lorrytripid?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type truckCreateInput = {
    truckid: string
    carplate?: string | null
    tone?: number | null
    lengthcm?: number | null
    widthcm?: number | null
    heightcm?: number | null
    lorrytrip?: lorrytripCreateNestedManyWithoutTruckInput
    truckzone?: truckzoneCreateNestedManyWithoutTruckInput
  }

  export type truckUncheckedCreateInput = {
    truckid: string
    carplate?: string | null
    tone?: number | null
    lengthcm?: number | null
    widthcm?: number | null
    heightcm?: number | null
    lorrytrip?: lorrytripUncheckedCreateNestedManyWithoutTruckInput
    truckzone?: truckzoneUncheckedCreateNestedManyWithoutTruckInput
  }

  export type truckUpdateInput = {
    truckid?: StringFieldUpdateOperationsInput | string
    carplate?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: NullableIntFieldUpdateOperationsInput | number | null
    lengthcm?: NullableIntFieldUpdateOperationsInput | number | null
    widthcm?: NullableIntFieldUpdateOperationsInput | number | null
    heightcm?: NullableIntFieldUpdateOperationsInput | number | null
    lorrytrip?: lorrytripUpdateManyWithoutTruckNestedInput
    truckzone?: truckzoneUpdateManyWithoutTruckNestedInput
  }

  export type truckUncheckedUpdateInput = {
    truckid?: StringFieldUpdateOperationsInput | string
    carplate?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: NullableIntFieldUpdateOperationsInput | number | null
    lengthcm?: NullableIntFieldUpdateOperationsInput | number | null
    widthcm?: NullableIntFieldUpdateOperationsInput | number | null
    heightcm?: NullableIntFieldUpdateOperationsInput | number | null
    lorrytrip?: lorrytripUncheckedUpdateManyWithoutTruckNestedInput
    truckzone?: truckzoneUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type truckCreateManyInput = {
    truckid: string
    carplate?: string | null
    tone?: number | null
    lengthcm?: number | null
    widthcm?: number | null
    heightcm?: number | null
  }

  export type truckUpdateManyMutationInput = {
    truckid?: StringFieldUpdateOperationsInput | string
    carplate?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: NullableIntFieldUpdateOperationsInput | number | null
    lengthcm?: NullableIntFieldUpdateOperationsInput | number | null
    widthcm?: NullableIntFieldUpdateOperationsInput | number | null
    heightcm?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type truckUncheckedUpdateManyInput = {
    truckid?: StringFieldUpdateOperationsInput | string
    carplate?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: NullableIntFieldUpdateOperationsInput | number | null
    lengthcm?: NullableIntFieldUpdateOperationsInput | number | null
    widthcm?: NullableIntFieldUpdateOperationsInput | number | null
    heightcm?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type truckzoneCreateInput = {
    isprimaryzone?: boolean | null
    truck: truckCreateNestedOneWithoutTruckzoneInput
    zone: zoneCreateNestedOneWithoutTruckzoneInput
  }

  export type truckzoneUncheckedCreateInput = {
    truckid: string
    zoneid: string
    isprimaryzone?: boolean | null
  }

  export type truckzoneUpdateInput = {
    isprimaryzone?: NullableBoolFieldUpdateOperationsInput | boolean | null
    truck?: truckUpdateOneRequiredWithoutTruckzoneNestedInput
    zone?: zoneUpdateOneRequiredWithoutTruckzoneNestedInput
  }

  export type truckzoneUncheckedUpdateInput = {
    truckid?: StringFieldUpdateOperationsInput | string
    zoneid?: StringFieldUpdateOperationsInput | string
    isprimaryzone?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type truckzoneCreateManyInput = {
    truckid: string
    zoneid: string
    isprimaryzone?: boolean | null
  }

  export type truckzoneUpdateManyMutationInput = {
    isprimaryzone?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type truckzoneUncheckedUpdateManyInput = {
    truckid?: StringFieldUpdateOperationsInput | string
    zoneid?: StringFieldUpdateOperationsInput | string
    isprimaryzone?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usersCreateInput = {
    uid: string
    name?: string | null
    displayname?: string | null
    email?: string | null
    bio?: string | null
    createdat?: Date | string | null
  }

  export type usersUncheckedCreateInput = {
    uid: string
    name?: string | null
    displayname?: string | null
    email?: string | null
    bio?: string | null
    createdat?: Date | string | null
  }

  export type usersUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateManyInput = {
    uid: string
    name?: string | null
    displayname?: string | null
    email?: string | null
    bio?: string | null
    createdat?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    uid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type zoneCreateInput = {
    zoneid: string
    zonename?: string | null
    building?: buildingCreateNestedManyWithoutZoneInput
    truckzone?: truckzoneCreateNestedManyWithoutZoneInput
  }

  export type zoneUncheckedCreateInput = {
    zoneid: string
    zonename?: string | null
    building?: buildingUncheckedCreateNestedManyWithoutZoneInput
    truckzone?: truckzoneUncheckedCreateNestedManyWithoutZoneInput
  }

  export type zoneUpdateInput = {
    zoneid?: StringFieldUpdateOperationsInput | string
    zonename?: NullableStringFieldUpdateOperationsInput | string | null
    building?: buildingUpdateManyWithoutZoneNestedInput
    truckzone?: truckzoneUpdateManyWithoutZoneNestedInput
  }

  export type zoneUncheckedUpdateInput = {
    zoneid?: StringFieldUpdateOperationsInput | string
    zonename?: NullableStringFieldUpdateOperationsInput | string | null
    building?: buildingUncheckedUpdateManyWithoutZoneNestedInput
    truckzone?: truckzoneUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type zoneCreateManyInput = {
    zoneid: string
    zonename?: string | null
  }

  export type zoneUpdateManyMutationInput = {
    zoneid?: StringFieldUpdateOperationsInput | string
    zonename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type zoneUncheckedUpdateManyInput = {
    zoneid?: StringFieldUpdateOperationsInput | string
    zonename?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ZoneNullableScalarRelationFilter = {
    is?: zoneWhereInput | null
    isNot?: zoneWhereInput | null
  }

  export type OrdersListRelationFilter = {
    every?: ordersWhereInput
    some?: ordersWhereInput
    none?: ordersWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ordersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type buildingCountOrderByAggregateInput = {
    buildingid?: SortOrder
    buildingname?: SortOrder
    housingtype?: SortOrder
    postalcode?: SortOrder
    zoneid?: SortOrder
    vehiclesizelimit?: SortOrder
    vehiclelengthlimit?: SortOrder
    vehiclewidthlimit?: SortOrder
    loadingbayavailable?: SortOrder
    liftavailable?: SortOrder
    stairsavailable?: SortOrder
    narrowdoorways?: SortOrder
    parkingdistance?: SortOrder
    preregistrationrequired?: SortOrder
    accesstimewindowstart?: SortOrder
    accesstimewindowend?: SortOrder
    notes?: SortOrder
    specialequipmentneeded?: SortOrder
    liftdimensions?: SortOrder
  }

  export type buildingAvgOrderByAggregateInput = {
    vehiclelengthlimit?: SortOrder
    vehiclewidthlimit?: SortOrder
    parkingdistance?: SortOrder
  }

  export type buildingMaxOrderByAggregateInput = {
    buildingid?: SortOrder
    buildingname?: SortOrder
    housingtype?: SortOrder
    postalcode?: SortOrder
    zoneid?: SortOrder
    vehiclesizelimit?: SortOrder
    vehiclelengthlimit?: SortOrder
    vehiclewidthlimit?: SortOrder
    loadingbayavailable?: SortOrder
    liftavailable?: SortOrder
    stairsavailable?: SortOrder
    narrowdoorways?: SortOrder
    parkingdistance?: SortOrder
    preregistrationrequired?: SortOrder
    accesstimewindowstart?: SortOrder
    accesstimewindowend?: SortOrder
    notes?: SortOrder
    specialequipmentneeded?: SortOrder
    liftdimensions?: SortOrder
  }

  export type buildingMinOrderByAggregateInput = {
    buildingid?: SortOrder
    buildingname?: SortOrder
    housingtype?: SortOrder
    postalcode?: SortOrder
    zoneid?: SortOrder
    vehiclesizelimit?: SortOrder
    vehiclelengthlimit?: SortOrder
    vehiclewidthlimit?: SortOrder
    loadingbayavailable?: SortOrder
    liftavailable?: SortOrder
    stairsavailable?: SortOrder
    narrowdoorways?: SortOrder
    parkingdistance?: SortOrder
    preregistrationrequired?: SortOrder
    accesstimewindowstart?: SortOrder
    accesstimewindowend?: SortOrder
    notes?: SortOrder
    specialequipmentneeded?: SortOrder
    liftdimensions?: SortOrder
  }

  export type buildingSumOrderByAggregateInput = {
    vehiclelengthlimit?: SortOrder
    vehiclewidthlimit?: SortOrder
    parkingdistance?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type chatsCountOrderByAggregateInput = {
    chatid?: SortOrder
    ordernumber?: SortOrder
    members?: SortOrder
    names?: SortOrder
    createdat?: SortOrder
    lastmessageat?: SortOrder
  }

  export type chatsMaxOrderByAggregateInput = {
    chatid?: SortOrder
    ordernumber?: SortOrder
    members?: SortOrder
    names?: SortOrder
    createdat?: SortOrder
    lastmessageat?: SortOrder
  }

  export type chatsMinOrderByAggregateInput = {
    chatid?: SortOrder
    ordernumber?: SortOrder
    members?: SortOrder
    names?: SortOrder
    createdat?: SortOrder
    lastmessageat?: SortOrder
  }

  export type customerCountOrderByAggregateInput = {
    customerid?: SortOrder
    name?: SortOrder
    displayname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    bio?: SortOrder
    notificationsenabled?: SortOrder
    createdat?: SortOrder
  }

  export type customerMaxOrderByAggregateInput = {
    customerid?: SortOrder
    name?: SortOrder
    displayname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    bio?: SortOrder
    notificationsenabled?: SortOrder
    createdat?: SortOrder
  }

  export type customerMinOrderByAggregateInput = {
    customerid?: SortOrder
    name?: SortOrder
    displayname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postcode?: SortOrder
    bio?: SortOrder
    notificationsenabled?: SortOrder
    createdat?: SortOrder
  }

  export type EmployeeteamassignmentListRelationFilter = {
    every?: employeeteamassignmentWhereInput
    some?: employeeteamassignmentWhereInput
    none?: employeeteamassignmentWhereInput
  }

  export type employeeteamassignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type employeeCountOrderByAggregateInput = {
    employeeid?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact_number?: SortOrder
    role?: SortOrder
    active_flag?: SortOrder
    displayname?: SortOrder
    createdat?: SortOrder
    bio?: SortOrder
  }

  export type employeeMaxOrderByAggregateInput = {
    employeeid?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact_number?: SortOrder
    role?: SortOrder
    active_flag?: SortOrder
    displayname?: SortOrder
    createdat?: SortOrder
    bio?: SortOrder
  }

  export type employeeMinOrderByAggregateInput = {
    employeeid?: SortOrder
    name?: SortOrder
    email?: SortOrder
    contact_number?: SortOrder
    role?: SortOrder
    active_flag?: SortOrder
    displayname?: SortOrder
    createdat?: SortOrder
    bio?: SortOrder
  }

  export type EmployeeScalarRelationFilter = {
    is?: employeeWhereInput
    isNot?: employeeWhereInput
  }

  export type TeamScalarRelationFilter = {
    is?: teamWhereInput
    isNot?: teamWhereInput
  }

  export type employeeteamassignmentEmployeeidTeamidCompoundUniqueInput = {
    employeeid: string
    teamid: string
  }

  export type employeeteamassignmentCountOrderByAggregateInput = {
    employeeid?: SortOrder
    teamid?: SortOrder
  }

  export type employeeteamassignmentMaxOrderByAggregateInput = {
    employeeid?: SortOrder
    teamid?: SortOrder
  }

  export type employeeteamassignmentMinOrderByAggregateInput = {
    employeeid?: SortOrder
    teamid?: SortOrder
  }

  export type TeamNullableScalarRelationFilter = {
    is?: teamWhereInput | null
    isNot?: teamWhereInput | null
  }

  export type TruckNullableScalarRelationFilter = {
    is?: truckWhereInput | null
    isNot?: truckWhereInput | null
  }

  export type TimeslotListRelationFilter = {
    every?: timeslotWhereInput
    some?: timeslotWhereInput
    none?: timeslotWhereInput
  }

  export type timeslotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type lorrytripCountOrderByAggregateInput = {
    lorrytripid?: SortOrder
    deliveryteamid?: SortOrder
    warehouseteamid?: SortOrder
    truckid?: SortOrder
  }

  export type lorrytripMaxOrderByAggregateInput = {
    lorrytripid?: SortOrder
    deliveryteamid?: SortOrder
    warehouseteamid?: SortOrder
    truckid?: SortOrder
  }

  export type lorrytripMinOrderByAggregateInput = {
    lorrytripid?: SortOrder
    deliveryteamid?: SortOrder
    warehouseteamid?: SortOrder
    truckid?: SortOrder
  }

  export type OrdersScalarRelationFilter = {
    is?: ordersWhereInput
    isNot?: ordersWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: productWhereInput
    isNot?: productWhereInput
  }

  export type orderproductOrderidProductidCompoundUniqueInput = {
    orderid: string
    productid: string
  }

  export type orderproductCountOrderByAggregateInput = {
    orderid?: SortOrder
    productid?: SortOrder
    quantity?: SortOrder
  }

  export type orderproductAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type orderproductMaxOrderByAggregateInput = {
    orderid?: SortOrder
    productid?: SortOrder
    quantity?: SortOrder
  }

  export type orderproductMinOrderByAggregateInput = {
    orderid?: SortOrder
    productid?: SortOrder
    quantity?: SortOrder
  }

  export type orderproductSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type OrderproductListRelationFilter = {
    every?: orderproductWhereInput
    some?: orderproductWhereInput
    none?: orderproductWhereInput
  }

  export type BuildingNullableScalarRelationFilter = {
    is?: buildingWhereInput | null
    isNot?: buildingWhereInput | null
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: customerWhereInput | null
    isNot?: customerWhereInput | null
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: employeeWhereInput | null
    isNot?: employeeWhereInput | null
  }

  export type TimeslotNullableScalarRelationFilter = {
    is?: timeslotWhereInput | null
    isNot?: timeslotWhereInput | null
  }

  export type orderproductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ordersCountOrderByAggregateInput = {
    orderid?: SortOrder
    customerid?: SortOrder
    employeeid?: SortOrder
    deliveryteamid?: SortOrder
    buildingid?: SortOrder
    timeslotid?: SortOrder
    numberofattempts?: SortOrder
    scheduledstartdatetime?: SortOrder
    scheduledenddatetime?: SortOrder
    actualstartdatetime?: SortOrder
    actualenddatetime?: SortOrder
    actualarrivaldatetime?: SortOrder
    customerrating?: SortOrder
    delayreason?: SortOrder
    customerfeedback?: SortOrder
    proofofdeliveryurl?: SortOrder
    orderstatus?: SortOrder
    updatedat?: SortOrder
    createdat?: SortOrder
  }

  export type ordersAvgOrderByAggregateInput = {
    numberofattempts?: SortOrder
    customerrating?: SortOrder
  }

  export type ordersMaxOrderByAggregateInput = {
    orderid?: SortOrder
    customerid?: SortOrder
    employeeid?: SortOrder
    deliveryteamid?: SortOrder
    buildingid?: SortOrder
    timeslotid?: SortOrder
    numberofattempts?: SortOrder
    scheduledstartdatetime?: SortOrder
    scheduledenddatetime?: SortOrder
    actualstartdatetime?: SortOrder
    actualenddatetime?: SortOrder
    actualarrivaldatetime?: SortOrder
    customerrating?: SortOrder
    delayreason?: SortOrder
    customerfeedback?: SortOrder
    proofofdeliveryurl?: SortOrder
    orderstatus?: SortOrder
    updatedat?: SortOrder
    createdat?: SortOrder
  }

  export type ordersMinOrderByAggregateInput = {
    orderid?: SortOrder
    customerid?: SortOrder
    employeeid?: SortOrder
    deliveryteamid?: SortOrder
    buildingid?: SortOrder
    timeslotid?: SortOrder
    numberofattempts?: SortOrder
    scheduledstartdatetime?: SortOrder
    scheduledenddatetime?: SortOrder
    actualstartdatetime?: SortOrder
    actualenddatetime?: SortOrder
    actualarrivaldatetime?: SortOrder
    customerrating?: SortOrder
    delayreason?: SortOrder
    customerfeedback?: SortOrder
    proofofdeliveryurl?: SortOrder
    orderstatus?: SortOrder
    updatedat?: SortOrder
    createdat?: SortOrder
  }

  export type ordersSumOrderByAggregateInput = {
    numberofattempts?: SortOrder
    customerrating?: SortOrder
  }

  export type productCountOrderByAggregateInput = {
    productid?: SortOrder
    productname?: SortOrder
    packagelengthcm?: SortOrder
    packagewidthcm?: SortOrder
    packageheightcm?: SortOrder
    installerteamrequiredflag?: SortOrder
    dismantlerequiredflag?: SortOrder
    dismantleextratime?: SortOrder
    estimatedinstallationtimemin?: SortOrder
    estimatedinstallationtimemax?: SortOrder
    fragileflag?: SortOrder
    noliedownflag?: SortOrder
  }

  export type productAvgOrderByAggregateInput = {
    packagelengthcm?: SortOrder
    packagewidthcm?: SortOrder
    packageheightcm?: SortOrder
    dismantleextratime?: SortOrder
    estimatedinstallationtimemin?: SortOrder
    estimatedinstallationtimemax?: SortOrder
  }

  export type productMaxOrderByAggregateInput = {
    productid?: SortOrder
    productname?: SortOrder
    packagelengthcm?: SortOrder
    packagewidthcm?: SortOrder
    packageheightcm?: SortOrder
    installerteamrequiredflag?: SortOrder
    dismantlerequiredflag?: SortOrder
    dismantleextratime?: SortOrder
    estimatedinstallationtimemin?: SortOrder
    estimatedinstallationtimemax?: SortOrder
    fragileflag?: SortOrder
    noliedownflag?: SortOrder
  }

  export type productMinOrderByAggregateInput = {
    productid?: SortOrder
    productname?: SortOrder
    packagelengthcm?: SortOrder
    packagewidthcm?: SortOrder
    packageheightcm?: SortOrder
    installerteamrequiredflag?: SortOrder
    dismantlerequiredflag?: SortOrder
    dismantleextratime?: SortOrder
    estimatedinstallationtimemin?: SortOrder
    estimatedinstallationtimemax?: SortOrder
    fragileflag?: SortOrder
    noliedownflag?: SortOrder
  }

  export type productSumOrderByAggregateInput = {
    packagelengthcm?: SortOrder
    packagewidthcm?: SortOrder
    packageheightcm?: SortOrder
    dismantleextratime?: SortOrder
    estimatedinstallationtimemin?: SortOrder
    estimatedinstallationtimemax?: SortOrder
  }

  export type LorrytripListRelationFilter = {
    every?: lorrytripWhereInput
    some?: lorrytripWhereInput
    none?: lorrytripWhereInput
  }

  export type lorrytripOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teamCountOrderByAggregateInput = {
    teamid?: SortOrder
    teamtype?: SortOrder
  }

  export type teamMaxOrderByAggregateInput = {
    teamid?: SortOrder
    teamtype?: SortOrder
  }

  export type teamMinOrderByAggregateInput = {
    teamid?: SortOrder
    teamtype?: SortOrder
  }

  export type LorrytripNullableScalarRelationFilter = {
    is?: lorrytripWhereInput | null
    isNot?: lorrytripWhereInput | null
  }

  export type timeslotCountOrderByAggregateInput = {
    timeslotid?: SortOrder
    lorrytripid?: SortOrder
    date?: SortOrder
    timewindowstart?: SortOrder
    timewindowend?: SortOrder
    availableflag?: SortOrder
  }

  export type timeslotMaxOrderByAggregateInput = {
    timeslotid?: SortOrder
    lorrytripid?: SortOrder
    date?: SortOrder
    timewindowstart?: SortOrder
    timewindowend?: SortOrder
    availableflag?: SortOrder
  }

  export type timeslotMinOrderByAggregateInput = {
    timeslotid?: SortOrder
    lorrytripid?: SortOrder
    date?: SortOrder
    timewindowstart?: SortOrder
    timewindowend?: SortOrder
    availableflag?: SortOrder
  }

  export type TruckzoneListRelationFilter = {
    every?: truckzoneWhereInput
    some?: truckzoneWhereInput
    none?: truckzoneWhereInput
  }

  export type truckzoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type truckCountOrderByAggregateInput = {
    truckid?: SortOrder
    carplate?: SortOrder
    tone?: SortOrder
    lengthcm?: SortOrder
    widthcm?: SortOrder
    heightcm?: SortOrder
  }

  export type truckAvgOrderByAggregateInput = {
    tone?: SortOrder
    lengthcm?: SortOrder
    widthcm?: SortOrder
    heightcm?: SortOrder
  }

  export type truckMaxOrderByAggregateInput = {
    truckid?: SortOrder
    carplate?: SortOrder
    tone?: SortOrder
    lengthcm?: SortOrder
    widthcm?: SortOrder
    heightcm?: SortOrder
  }

  export type truckMinOrderByAggregateInput = {
    truckid?: SortOrder
    carplate?: SortOrder
    tone?: SortOrder
    lengthcm?: SortOrder
    widthcm?: SortOrder
    heightcm?: SortOrder
  }

  export type truckSumOrderByAggregateInput = {
    tone?: SortOrder
    lengthcm?: SortOrder
    widthcm?: SortOrder
    heightcm?: SortOrder
  }

  export type TruckScalarRelationFilter = {
    is?: truckWhereInput
    isNot?: truckWhereInput
  }

  export type ZoneScalarRelationFilter = {
    is?: zoneWhereInput
    isNot?: zoneWhereInput
  }

  export type truckzoneTruckidZoneidCompoundUniqueInput = {
    truckid: string
    zoneid: string
  }

  export type truckzoneCountOrderByAggregateInput = {
    truckid?: SortOrder
    zoneid?: SortOrder
    isprimaryzone?: SortOrder
  }

  export type truckzoneMaxOrderByAggregateInput = {
    truckid?: SortOrder
    zoneid?: SortOrder
    isprimaryzone?: SortOrder
  }

  export type truckzoneMinOrderByAggregateInput = {
    truckid?: SortOrder
    zoneid?: SortOrder
    isprimaryzone?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    uid?: SortOrder
    name?: SortOrder
    displayname?: SortOrder
    email?: SortOrder
    bio?: SortOrder
    createdat?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    uid?: SortOrder
    name?: SortOrder
    displayname?: SortOrder
    email?: SortOrder
    bio?: SortOrder
    createdat?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    uid?: SortOrder
    name?: SortOrder
    displayname?: SortOrder
    email?: SortOrder
    bio?: SortOrder
    createdat?: SortOrder
  }

  export type BuildingListRelationFilter = {
    every?: buildingWhereInput
    some?: buildingWhereInput
    none?: buildingWhereInput
  }

  export type buildingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type zoneCountOrderByAggregateInput = {
    zoneid?: SortOrder
    zonename?: SortOrder
  }

  export type zoneMaxOrderByAggregateInput = {
    zoneid?: SortOrder
    zonename?: SortOrder
  }

  export type zoneMinOrderByAggregateInput = {
    zoneid?: SortOrder
    zonename?: SortOrder
  }

  export type zoneCreateNestedOneWithoutBuildingInput = {
    create?: XOR<zoneCreateWithoutBuildingInput, zoneUncheckedCreateWithoutBuildingInput>
    connectOrCreate?: zoneCreateOrConnectWithoutBuildingInput
    connect?: zoneWhereUniqueInput
  }

  export type ordersCreateNestedManyWithoutBuildingInput = {
    create?: XOR<ordersCreateWithoutBuildingInput, ordersUncheckedCreateWithoutBuildingInput> | ordersCreateWithoutBuildingInput[] | ordersUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutBuildingInput | ordersCreateOrConnectWithoutBuildingInput[]
    createMany?: ordersCreateManyBuildingInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type ordersUncheckedCreateNestedManyWithoutBuildingInput = {
    create?: XOR<ordersCreateWithoutBuildingInput, ordersUncheckedCreateWithoutBuildingInput> | ordersCreateWithoutBuildingInput[] | ordersUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutBuildingInput | ordersCreateOrConnectWithoutBuildingInput[]
    createMany?: ordersCreateManyBuildingInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type zoneUpdateOneWithoutBuildingNestedInput = {
    create?: XOR<zoneCreateWithoutBuildingInput, zoneUncheckedCreateWithoutBuildingInput>
    connectOrCreate?: zoneCreateOrConnectWithoutBuildingInput
    upsert?: zoneUpsertWithoutBuildingInput
    disconnect?: zoneWhereInput | boolean
    delete?: zoneWhereInput | boolean
    connect?: zoneWhereUniqueInput
    update?: XOR<XOR<zoneUpdateToOneWithWhereWithoutBuildingInput, zoneUpdateWithoutBuildingInput>, zoneUncheckedUpdateWithoutBuildingInput>
  }

  export type ordersUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<ordersCreateWithoutBuildingInput, ordersUncheckedCreateWithoutBuildingInput> | ordersCreateWithoutBuildingInput[] | ordersUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutBuildingInput | ordersCreateOrConnectWithoutBuildingInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutBuildingInput | ordersUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: ordersCreateManyBuildingInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutBuildingInput | ordersUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutBuildingInput | ordersUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type ordersUncheckedUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<ordersCreateWithoutBuildingInput, ordersUncheckedCreateWithoutBuildingInput> | ordersCreateWithoutBuildingInput[] | ordersUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutBuildingInput | ordersCreateOrConnectWithoutBuildingInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutBuildingInput | ordersUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: ordersCreateManyBuildingInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutBuildingInput | ordersUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutBuildingInput | ordersUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type ordersCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ordersCreateWithoutCustomerInput, ordersUncheckedCreateWithoutCustomerInput> | ordersCreateWithoutCustomerInput[] | ordersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutCustomerInput | ordersCreateOrConnectWithoutCustomerInput[]
    createMany?: ordersCreateManyCustomerInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type ordersUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ordersCreateWithoutCustomerInput, ordersUncheckedCreateWithoutCustomerInput> | ordersCreateWithoutCustomerInput[] | ordersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutCustomerInput | ordersCreateOrConnectWithoutCustomerInput[]
    createMany?: ordersCreateManyCustomerInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type ordersUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ordersCreateWithoutCustomerInput, ordersUncheckedCreateWithoutCustomerInput> | ordersCreateWithoutCustomerInput[] | ordersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutCustomerInput | ordersCreateOrConnectWithoutCustomerInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutCustomerInput | ordersUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ordersCreateManyCustomerInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutCustomerInput | ordersUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutCustomerInput | ordersUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type ordersUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ordersCreateWithoutCustomerInput, ordersUncheckedCreateWithoutCustomerInput> | ordersCreateWithoutCustomerInput[] | ordersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutCustomerInput | ordersCreateOrConnectWithoutCustomerInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutCustomerInput | ordersUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ordersCreateManyCustomerInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutCustomerInput | ordersUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutCustomerInput | ordersUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type employeeteamassignmentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<employeeteamassignmentCreateWithoutEmployeeInput, employeeteamassignmentUncheckedCreateWithoutEmployeeInput> | employeeteamassignmentCreateWithoutEmployeeInput[] | employeeteamassignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: employeeteamassignmentCreateOrConnectWithoutEmployeeInput | employeeteamassignmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: employeeteamassignmentCreateManyEmployeeInputEnvelope
    connect?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
  }

  export type ordersCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ordersCreateWithoutEmployeeInput, ordersUncheckedCreateWithoutEmployeeInput> | ordersCreateWithoutEmployeeInput[] | ordersUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutEmployeeInput | ordersCreateOrConnectWithoutEmployeeInput[]
    createMany?: ordersCreateManyEmployeeInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type employeeteamassignmentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<employeeteamassignmentCreateWithoutEmployeeInput, employeeteamassignmentUncheckedCreateWithoutEmployeeInput> | employeeteamassignmentCreateWithoutEmployeeInput[] | employeeteamassignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: employeeteamassignmentCreateOrConnectWithoutEmployeeInput | employeeteamassignmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: employeeteamassignmentCreateManyEmployeeInputEnvelope
    connect?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
  }

  export type ordersUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ordersCreateWithoutEmployeeInput, ordersUncheckedCreateWithoutEmployeeInput> | ordersCreateWithoutEmployeeInput[] | ordersUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutEmployeeInput | ordersCreateOrConnectWithoutEmployeeInput[]
    createMany?: ordersCreateManyEmployeeInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type employeeteamassignmentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<employeeteamassignmentCreateWithoutEmployeeInput, employeeteamassignmentUncheckedCreateWithoutEmployeeInput> | employeeteamassignmentCreateWithoutEmployeeInput[] | employeeteamassignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: employeeteamassignmentCreateOrConnectWithoutEmployeeInput | employeeteamassignmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: employeeteamassignmentUpsertWithWhereUniqueWithoutEmployeeInput | employeeteamassignmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: employeeteamassignmentCreateManyEmployeeInputEnvelope
    set?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    disconnect?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    delete?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    connect?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    update?: employeeteamassignmentUpdateWithWhereUniqueWithoutEmployeeInput | employeeteamassignmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: employeeteamassignmentUpdateManyWithWhereWithoutEmployeeInput | employeeteamassignmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: employeeteamassignmentScalarWhereInput | employeeteamassignmentScalarWhereInput[]
  }

  export type ordersUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ordersCreateWithoutEmployeeInput, ordersUncheckedCreateWithoutEmployeeInput> | ordersCreateWithoutEmployeeInput[] | ordersUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutEmployeeInput | ordersCreateOrConnectWithoutEmployeeInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutEmployeeInput | ordersUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ordersCreateManyEmployeeInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutEmployeeInput | ordersUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutEmployeeInput | ordersUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type employeeteamassignmentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<employeeteamassignmentCreateWithoutEmployeeInput, employeeteamassignmentUncheckedCreateWithoutEmployeeInput> | employeeteamassignmentCreateWithoutEmployeeInput[] | employeeteamassignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: employeeteamassignmentCreateOrConnectWithoutEmployeeInput | employeeteamassignmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: employeeteamassignmentUpsertWithWhereUniqueWithoutEmployeeInput | employeeteamassignmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: employeeteamassignmentCreateManyEmployeeInputEnvelope
    set?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    disconnect?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    delete?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    connect?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    update?: employeeteamassignmentUpdateWithWhereUniqueWithoutEmployeeInput | employeeteamassignmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: employeeteamassignmentUpdateManyWithWhereWithoutEmployeeInput | employeeteamassignmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: employeeteamassignmentScalarWhereInput | employeeteamassignmentScalarWhereInput[]
  }

  export type ordersUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ordersCreateWithoutEmployeeInput, ordersUncheckedCreateWithoutEmployeeInput> | ordersCreateWithoutEmployeeInput[] | ordersUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutEmployeeInput | ordersCreateOrConnectWithoutEmployeeInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutEmployeeInput | ordersUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ordersCreateManyEmployeeInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutEmployeeInput | ordersUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutEmployeeInput | ordersUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type employeeCreateNestedOneWithoutEmployeeteamassignmentInput = {
    create?: XOR<employeeCreateWithoutEmployeeteamassignmentInput, employeeUncheckedCreateWithoutEmployeeteamassignmentInput>
    connectOrCreate?: employeeCreateOrConnectWithoutEmployeeteamassignmentInput
    connect?: employeeWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutEmployeeteamassignmentInput = {
    create?: XOR<teamCreateWithoutEmployeeteamassignmentInput, teamUncheckedCreateWithoutEmployeeteamassignmentInput>
    connectOrCreate?: teamCreateOrConnectWithoutEmployeeteamassignmentInput
    connect?: teamWhereUniqueInput
  }

  export type employeeUpdateOneRequiredWithoutEmployeeteamassignmentNestedInput = {
    create?: XOR<employeeCreateWithoutEmployeeteamassignmentInput, employeeUncheckedCreateWithoutEmployeeteamassignmentInput>
    connectOrCreate?: employeeCreateOrConnectWithoutEmployeeteamassignmentInput
    upsert?: employeeUpsertWithoutEmployeeteamassignmentInput
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutEmployeeteamassignmentInput, employeeUpdateWithoutEmployeeteamassignmentInput>, employeeUncheckedUpdateWithoutEmployeeteamassignmentInput>
  }

  export type teamUpdateOneRequiredWithoutEmployeeteamassignmentNestedInput = {
    create?: XOR<teamCreateWithoutEmployeeteamassignmentInput, teamUncheckedCreateWithoutEmployeeteamassignmentInput>
    connectOrCreate?: teamCreateOrConnectWithoutEmployeeteamassignmentInput
    upsert?: teamUpsertWithoutEmployeeteamassignmentInput
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutEmployeeteamassignmentInput, teamUpdateWithoutEmployeeteamassignmentInput>, teamUncheckedUpdateWithoutEmployeeteamassignmentInput>
  }

  export type teamCreateNestedOneWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput = {
    create?: XOR<teamCreateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput, teamUncheckedCreateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput>
    connectOrCreate?: teamCreateOrConnectWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput
    connect?: teamWhereUniqueInput
  }

  export type truckCreateNestedOneWithoutLorrytripInput = {
    create?: XOR<truckCreateWithoutLorrytripInput, truckUncheckedCreateWithoutLorrytripInput>
    connectOrCreate?: truckCreateOrConnectWithoutLorrytripInput
    connect?: truckWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput = {
    create?: XOR<teamCreateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput, teamUncheckedCreateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput>
    connectOrCreate?: teamCreateOrConnectWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput
    connect?: teamWhereUniqueInput
  }

  export type timeslotCreateNestedManyWithoutLorrytripInput = {
    create?: XOR<timeslotCreateWithoutLorrytripInput, timeslotUncheckedCreateWithoutLorrytripInput> | timeslotCreateWithoutLorrytripInput[] | timeslotUncheckedCreateWithoutLorrytripInput[]
    connectOrCreate?: timeslotCreateOrConnectWithoutLorrytripInput | timeslotCreateOrConnectWithoutLorrytripInput[]
    createMany?: timeslotCreateManyLorrytripInputEnvelope
    connect?: timeslotWhereUniqueInput | timeslotWhereUniqueInput[]
  }

  export type timeslotUncheckedCreateNestedManyWithoutLorrytripInput = {
    create?: XOR<timeslotCreateWithoutLorrytripInput, timeslotUncheckedCreateWithoutLorrytripInput> | timeslotCreateWithoutLorrytripInput[] | timeslotUncheckedCreateWithoutLorrytripInput[]
    connectOrCreate?: timeslotCreateOrConnectWithoutLorrytripInput | timeslotCreateOrConnectWithoutLorrytripInput[]
    createMany?: timeslotCreateManyLorrytripInputEnvelope
    connect?: timeslotWhereUniqueInput | timeslotWhereUniqueInput[]
  }

  export type teamUpdateOneWithoutLorrytrip_lorrytrip_deliveryteamidToteamNestedInput = {
    create?: XOR<teamCreateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput, teamUncheckedCreateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput>
    connectOrCreate?: teamCreateOrConnectWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput
    upsert?: teamUpsertWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput
    disconnect?: teamWhereInput | boolean
    delete?: teamWhereInput | boolean
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput, teamUpdateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput>, teamUncheckedUpdateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput>
  }

  export type truckUpdateOneWithoutLorrytripNestedInput = {
    create?: XOR<truckCreateWithoutLorrytripInput, truckUncheckedCreateWithoutLorrytripInput>
    connectOrCreate?: truckCreateOrConnectWithoutLorrytripInput
    upsert?: truckUpsertWithoutLorrytripInput
    disconnect?: truckWhereInput | boolean
    delete?: truckWhereInput | boolean
    connect?: truckWhereUniqueInput
    update?: XOR<XOR<truckUpdateToOneWithWhereWithoutLorrytripInput, truckUpdateWithoutLorrytripInput>, truckUncheckedUpdateWithoutLorrytripInput>
  }

  export type teamUpdateOneWithoutLorrytrip_lorrytrip_warehouseteamidToteamNestedInput = {
    create?: XOR<teamCreateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput, teamUncheckedCreateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput>
    connectOrCreate?: teamCreateOrConnectWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput
    upsert?: teamUpsertWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput
    disconnect?: teamWhereInput | boolean
    delete?: teamWhereInput | boolean
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput, teamUpdateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput>, teamUncheckedUpdateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput>
  }

  export type timeslotUpdateManyWithoutLorrytripNestedInput = {
    create?: XOR<timeslotCreateWithoutLorrytripInput, timeslotUncheckedCreateWithoutLorrytripInput> | timeslotCreateWithoutLorrytripInput[] | timeslotUncheckedCreateWithoutLorrytripInput[]
    connectOrCreate?: timeslotCreateOrConnectWithoutLorrytripInput | timeslotCreateOrConnectWithoutLorrytripInput[]
    upsert?: timeslotUpsertWithWhereUniqueWithoutLorrytripInput | timeslotUpsertWithWhereUniqueWithoutLorrytripInput[]
    createMany?: timeslotCreateManyLorrytripInputEnvelope
    set?: timeslotWhereUniqueInput | timeslotWhereUniqueInput[]
    disconnect?: timeslotWhereUniqueInput | timeslotWhereUniqueInput[]
    delete?: timeslotWhereUniqueInput | timeslotWhereUniqueInput[]
    connect?: timeslotWhereUniqueInput | timeslotWhereUniqueInput[]
    update?: timeslotUpdateWithWhereUniqueWithoutLorrytripInput | timeslotUpdateWithWhereUniqueWithoutLorrytripInput[]
    updateMany?: timeslotUpdateManyWithWhereWithoutLorrytripInput | timeslotUpdateManyWithWhereWithoutLorrytripInput[]
    deleteMany?: timeslotScalarWhereInput | timeslotScalarWhereInput[]
  }

  export type timeslotUncheckedUpdateManyWithoutLorrytripNestedInput = {
    create?: XOR<timeslotCreateWithoutLorrytripInput, timeslotUncheckedCreateWithoutLorrytripInput> | timeslotCreateWithoutLorrytripInput[] | timeslotUncheckedCreateWithoutLorrytripInput[]
    connectOrCreate?: timeslotCreateOrConnectWithoutLorrytripInput | timeslotCreateOrConnectWithoutLorrytripInput[]
    upsert?: timeslotUpsertWithWhereUniqueWithoutLorrytripInput | timeslotUpsertWithWhereUniqueWithoutLorrytripInput[]
    createMany?: timeslotCreateManyLorrytripInputEnvelope
    set?: timeslotWhereUniqueInput | timeslotWhereUniqueInput[]
    disconnect?: timeslotWhereUniqueInput | timeslotWhereUniqueInput[]
    delete?: timeslotWhereUniqueInput | timeslotWhereUniqueInput[]
    connect?: timeslotWhereUniqueInput | timeslotWhereUniqueInput[]
    update?: timeslotUpdateWithWhereUniqueWithoutLorrytripInput | timeslotUpdateWithWhereUniqueWithoutLorrytripInput[]
    updateMany?: timeslotUpdateManyWithWhereWithoutLorrytripInput | timeslotUpdateManyWithWhereWithoutLorrytripInput[]
    deleteMany?: timeslotScalarWhereInput | timeslotScalarWhereInput[]
  }

  export type ordersCreateNestedOneWithoutOrderproductInput = {
    create?: XOR<ordersCreateWithoutOrderproductInput, ordersUncheckedCreateWithoutOrderproductInput>
    connectOrCreate?: ordersCreateOrConnectWithoutOrderproductInput
    connect?: ordersWhereUniqueInput
  }

  export type productCreateNestedOneWithoutOrderproductInput = {
    create?: XOR<productCreateWithoutOrderproductInput, productUncheckedCreateWithoutOrderproductInput>
    connectOrCreate?: productCreateOrConnectWithoutOrderproductInput
    connect?: productWhereUniqueInput
  }

  export type ordersUpdateOneRequiredWithoutOrderproductNestedInput = {
    create?: XOR<ordersCreateWithoutOrderproductInput, ordersUncheckedCreateWithoutOrderproductInput>
    connectOrCreate?: ordersCreateOrConnectWithoutOrderproductInput
    upsert?: ordersUpsertWithoutOrderproductInput
    connect?: ordersWhereUniqueInput
    update?: XOR<XOR<ordersUpdateToOneWithWhereWithoutOrderproductInput, ordersUpdateWithoutOrderproductInput>, ordersUncheckedUpdateWithoutOrderproductInput>
  }

  export type productUpdateOneRequiredWithoutOrderproductNestedInput = {
    create?: XOR<productCreateWithoutOrderproductInput, productUncheckedCreateWithoutOrderproductInput>
    connectOrCreate?: productCreateOrConnectWithoutOrderproductInput
    upsert?: productUpsertWithoutOrderproductInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutOrderproductInput, productUpdateWithoutOrderproductInput>, productUncheckedUpdateWithoutOrderproductInput>
  }

  export type orderproductCreateNestedManyWithoutOrdersInput = {
    create?: XOR<orderproductCreateWithoutOrdersInput, orderproductUncheckedCreateWithoutOrdersInput> | orderproductCreateWithoutOrdersInput[] | orderproductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: orderproductCreateOrConnectWithoutOrdersInput | orderproductCreateOrConnectWithoutOrdersInput[]
    createMany?: orderproductCreateManyOrdersInputEnvelope
    connect?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
  }

  export type buildingCreateNestedOneWithoutOrdersInput = {
    create?: XOR<buildingCreateWithoutOrdersInput, buildingUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: buildingCreateOrConnectWithoutOrdersInput
    connect?: buildingWhereUniqueInput
  }

  export type customerCreateNestedOneWithoutOrdersInput = {
    create?: XOR<customerCreateWithoutOrdersInput, customerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: customerCreateOrConnectWithoutOrdersInput
    connect?: customerWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutOrdersInput = {
    create?: XOR<teamCreateWithoutOrdersInput, teamUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: teamCreateOrConnectWithoutOrdersInput
    connect?: teamWhereUniqueInput
  }

  export type employeeCreateNestedOneWithoutOrdersInput = {
    create?: XOR<employeeCreateWithoutOrdersInput, employeeUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: employeeCreateOrConnectWithoutOrdersInput
    connect?: employeeWhereUniqueInput
  }

  export type timeslotCreateNestedOneWithoutOrdersInput = {
    create?: XOR<timeslotCreateWithoutOrdersInput, timeslotUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: timeslotCreateOrConnectWithoutOrdersInput
    connect?: timeslotWhereUniqueInput
  }

  export type orderproductUncheckedCreateNestedManyWithoutOrdersInput = {
    create?: XOR<orderproductCreateWithoutOrdersInput, orderproductUncheckedCreateWithoutOrdersInput> | orderproductCreateWithoutOrdersInput[] | orderproductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: orderproductCreateOrConnectWithoutOrdersInput | orderproductCreateOrConnectWithoutOrdersInput[]
    createMany?: orderproductCreateManyOrdersInputEnvelope
    connect?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
  }

  export type orderproductUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<orderproductCreateWithoutOrdersInput, orderproductUncheckedCreateWithoutOrdersInput> | orderproductCreateWithoutOrdersInput[] | orderproductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: orderproductCreateOrConnectWithoutOrdersInput | orderproductCreateOrConnectWithoutOrdersInput[]
    upsert?: orderproductUpsertWithWhereUniqueWithoutOrdersInput | orderproductUpsertWithWhereUniqueWithoutOrdersInput[]
    createMany?: orderproductCreateManyOrdersInputEnvelope
    set?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    disconnect?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    delete?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    connect?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    update?: orderproductUpdateWithWhereUniqueWithoutOrdersInput | orderproductUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: orderproductUpdateManyWithWhereWithoutOrdersInput | orderproductUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: orderproductScalarWhereInput | orderproductScalarWhereInput[]
  }

  export type buildingUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<buildingCreateWithoutOrdersInput, buildingUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: buildingCreateOrConnectWithoutOrdersInput
    upsert?: buildingUpsertWithoutOrdersInput
    disconnect?: buildingWhereInput | boolean
    delete?: buildingWhereInput | boolean
    connect?: buildingWhereUniqueInput
    update?: XOR<XOR<buildingUpdateToOneWithWhereWithoutOrdersInput, buildingUpdateWithoutOrdersInput>, buildingUncheckedUpdateWithoutOrdersInput>
  }

  export type customerUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<customerCreateWithoutOrdersInput, customerUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: customerCreateOrConnectWithoutOrdersInput
    upsert?: customerUpsertWithoutOrdersInput
    disconnect?: customerWhereInput | boolean
    delete?: customerWhereInput | boolean
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutOrdersInput, customerUpdateWithoutOrdersInput>, customerUncheckedUpdateWithoutOrdersInput>
  }

  export type teamUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<teamCreateWithoutOrdersInput, teamUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: teamCreateOrConnectWithoutOrdersInput
    upsert?: teamUpsertWithoutOrdersInput
    disconnect?: teamWhereInput | boolean
    delete?: teamWhereInput | boolean
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutOrdersInput, teamUpdateWithoutOrdersInput>, teamUncheckedUpdateWithoutOrdersInput>
  }

  export type employeeUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<employeeCreateWithoutOrdersInput, employeeUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: employeeCreateOrConnectWithoutOrdersInput
    upsert?: employeeUpsertWithoutOrdersInput
    disconnect?: employeeWhereInput | boolean
    delete?: employeeWhereInput | boolean
    connect?: employeeWhereUniqueInput
    update?: XOR<XOR<employeeUpdateToOneWithWhereWithoutOrdersInput, employeeUpdateWithoutOrdersInput>, employeeUncheckedUpdateWithoutOrdersInput>
  }

  export type timeslotUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<timeslotCreateWithoutOrdersInput, timeslotUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: timeslotCreateOrConnectWithoutOrdersInput
    upsert?: timeslotUpsertWithoutOrdersInput
    disconnect?: timeslotWhereInput | boolean
    delete?: timeslotWhereInput | boolean
    connect?: timeslotWhereUniqueInput
    update?: XOR<XOR<timeslotUpdateToOneWithWhereWithoutOrdersInput, timeslotUpdateWithoutOrdersInput>, timeslotUncheckedUpdateWithoutOrdersInput>
  }

  export type orderproductUncheckedUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<orderproductCreateWithoutOrdersInput, orderproductUncheckedCreateWithoutOrdersInput> | orderproductCreateWithoutOrdersInput[] | orderproductUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: orderproductCreateOrConnectWithoutOrdersInput | orderproductCreateOrConnectWithoutOrdersInput[]
    upsert?: orderproductUpsertWithWhereUniqueWithoutOrdersInput | orderproductUpsertWithWhereUniqueWithoutOrdersInput[]
    createMany?: orderproductCreateManyOrdersInputEnvelope
    set?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    disconnect?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    delete?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    connect?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    update?: orderproductUpdateWithWhereUniqueWithoutOrdersInput | orderproductUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: orderproductUpdateManyWithWhereWithoutOrdersInput | orderproductUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: orderproductScalarWhereInput | orderproductScalarWhereInput[]
  }

  export type orderproductCreateNestedManyWithoutProductInput = {
    create?: XOR<orderproductCreateWithoutProductInput, orderproductUncheckedCreateWithoutProductInput> | orderproductCreateWithoutProductInput[] | orderproductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: orderproductCreateOrConnectWithoutProductInput | orderproductCreateOrConnectWithoutProductInput[]
    createMany?: orderproductCreateManyProductInputEnvelope
    connect?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
  }

  export type orderproductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<orderproductCreateWithoutProductInput, orderproductUncheckedCreateWithoutProductInput> | orderproductCreateWithoutProductInput[] | orderproductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: orderproductCreateOrConnectWithoutProductInput | orderproductCreateOrConnectWithoutProductInput[]
    createMany?: orderproductCreateManyProductInputEnvelope
    connect?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
  }

  export type orderproductUpdateManyWithoutProductNestedInput = {
    create?: XOR<orderproductCreateWithoutProductInput, orderproductUncheckedCreateWithoutProductInput> | orderproductCreateWithoutProductInput[] | orderproductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: orderproductCreateOrConnectWithoutProductInput | orderproductCreateOrConnectWithoutProductInput[]
    upsert?: orderproductUpsertWithWhereUniqueWithoutProductInput | orderproductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: orderproductCreateManyProductInputEnvelope
    set?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    disconnect?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    delete?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    connect?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    update?: orderproductUpdateWithWhereUniqueWithoutProductInput | orderproductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: orderproductUpdateManyWithWhereWithoutProductInput | orderproductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: orderproductScalarWhereInput | orderproductScalarWhereInput[]
  }

  export type orderproductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<orderproductCreateWithoutProductInput, orderproductUncheckedCreateWithoutProductInput> | orderproductCreateWithoutProductInput[] | orderproductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: orderproductCreateOrConnectWithoutProductInput | orderproductCreateOrConnectWithoutProductInput[]
    upsert?: orderproductUpsertWithWhereUniqueWithoutProductInput | orderproductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: orderproductCreateManyProductInputEnvelope
    set?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    disconnect?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    delete?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    connect?: orderproductWhereUniqueInput | orderproductWhereUniqueInput[]
    update?: orderproductUpdateWithWhereUniqueWithoutProductInput | orderproductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: orderproductUpdateManyWithWhereWithoutProductInput | orderproductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: orderproductScalarWhereInput | orderproductScalarWhereInput[]
  }

  export type employeeteamassignmentCreateNestedManyWithoutTeamInput = {
    create?: XOR<employeeteamassignmentCreateWithoutTeamInput, employeeteamassignmentUncheckedCreateWithoutTeamInput> | employeeteamassignmentCreateWithoutTeamInput[] | employeeteamassignmentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: employeeteamassignmentCreateOrConnectWithoutTeamInput | employeeteamassignmentCreateOrConnectWithoutTeamInput[]
    createMany?: employeeteamassignmentCreateManyTeamInputEnvelope
    connect?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
  }

  export type lorrytripCreateNestedManyWithoutTeam_lorrytrip_deliveryteamidToteamInput = {
    create?: XOR<lorrytripCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput, lorrytripUncheckedCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput> | lorrytripCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput[] | lorrytripUncheckedCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput[]
    connectOrCreate?: lorrytripCreateOrConnectWithoutTeam_lorrytrip_deliveryteamidToteamInput | lorrytripCreateOrConnectWithoutTeam_lorrytrip_deliveryteamidToteamInput[]
    createMany?: lorrytripCreateManyTeam_lorrytrip_deliveryteamidToteamInputEnvelope
    connect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
  }

  export type lorrytripCreateNestedManyWithoutTeam_lorrytrip_warehouseteamidToteamInput = {
    create?: XOR<lorrytripCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput, lorrytripUncheckedCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput> | lorrytripCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput[] | lorrytripUncheckedCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput[]
    connectOrCreate?: lorrytripCreateOrConnectWithoutTeam_lorrytrip_warehouseteamidToteamInput | lorrytripCreateOrConnectWithoutTeam_lorrytrip_warehouseteamidToteamInput[]
    createMany?: lorrytripCreateManyTeam_lorrytrip_warehouseteamidToteamInputEnvelope
    connect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
  }

  export type ordersCreateNestedManyWithoutTeamInput = {
    create?: XOR<ordersCreateWithoutTeamInput, ordersUncheckedCreateWithoutTeamInput> | ordersCreateWithoutTeamInput[] | ordersUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutTeamInput | ordersCreateOrConnectWithoutTeamInput[]
    createMany?: ordersCreateManyTeamInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type employeeteamassignmentUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<employeeteamassignmentCreateWithoutTeamInput, employeeteamassignmentUncheckedCreateWithoutTeamInput> | employeeteamassignmentCreateWithoutTeamInput[] | employeeteamassignmentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: employeeteamassignmentCreateOrConnectWithoutTeamInput | employeeteamassignmentCreateOrConnectWithoutTeamInput[]
    createMany?: employeeteamassignmentCreateManyTeamInputEnvelope
    connect?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
  }

  export type lorrytripUncheckedCreateNestedManyWithoutTeam_lorrytrip_deliveryteamidToteamInput = {
    create?: XOR<lorrytripCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput, lorrytripUncheckedCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput> | lorrytripCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput[] | lorrytripUncheckedCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput[]
    connectOrCreate?: lorrytripCreateOrConnectWithoutTeam_lorrytrip_deliveryteamidToteamInput | lorrytripCreateOrConnectWithoutTeam_lorrytrip_deliveryteamidToteamInput[]
    createMany?: lorrytripCreateManyTeam_lorrytrip_deliveryteamidToteamInputEnvelope
    connect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
  }

  export type lorrytripUncheckedCreateNestedManyWithoutTeam_lorrytrip_warehouseteamidToteamInput = {
    create?: XOR<lorrytripCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput, lorrytripUncheckedCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput> | lorrytripCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput[] | lorrytripUncheckedCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput[]
    connectOrCreate?: lorrytripCreateOrConnectWithoutTeam_lorrytrip_warehouseteamidToteamInput | lorrytripCreateOrConnectWithoutTeam_lorrytrip_warehouseteamidToteamInput[]
    createMany?: lorrytripCreateManyTeam_lorrytrip_warehouseteamidToteamInputEnvelope
    connect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
  }

  export type ordersUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<ordersCreateWithoutTeamInput, ordersUncheckedCreateWithoutTeamInput> | ordersCreateWithoutTeamInput[] | ordersUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutTeamInput | ordersCreateOrConnectWithoutTeamInput[]
    createMany?: ordersCreateManyTeamInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type employeeteamassignmentUpdateManyWithoutTeamNestedInput = {
    create?: XOR<employeeteamassignmentCreateWithoutTeamInput, employeeteamassignmentUncheckedCreateWithoutTeamInput> | employeeteamassignmentCreateWithoutTeamInput[] | employeeteamassignmentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: employeeteamassignmentCreateOrConnectWithoutTeamInput | employeeteamassignmentCreateOrConnectWithoutTeamInput[]
    upsert?: employeeteamassignmentUpsertWithWhereUniqueWithoutTeamInput | employeeteamassignmentUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: employeeteamassignmentCreateManyTeamInputEnvelope
    set?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    disconnect?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    delete?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    connect?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    update?: employeeteamassignmentUpdateWithWhereUniqueWithoutTeamInput | employeeteamassignmentUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: employeeteamassignmentUpdateManyWithWhereWithoutTeamInput | employeeteamassignmentUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: employeeteamassignmentScalarWhereInput | employeeteamassignmentScalarWhereInput[]
  }

  export type lorrytripUpdateManyWithoutTeam_lorrytrip_deliveryteamidToteamNestedInput = {
    create?: XOR<lorrytripCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput, lorrytripUncheckedCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput> | lorrytripCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput[] | lorrytripUncheckedCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput[]
    connectOrCreate?: lorrytripCreateOrConnectWithoutTeam_lorrytrip_deliveryteamidToteamInput | lorrytripCreateOrConnectWithoutTeam_lorrytrip_deliveryteamidToteamInput[]
    upsert?: lorrytripUpsertWithWhereUniqueWithoutTeam_lorrytrip_deliveryteamidToteamInput | lorrytripUpsertWithWhereUniqueWithoutTeam_lorrytrip_deliveryteamidToteamInput[]
    createMany?: lorrytripCreateManyTeam_lorrytrip_deliveryteamidToteamInputEnvelope
    set?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    disconnect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    delete?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    connect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    update?: lorrytripUpdateWithWhereUniqueWithoutTeam_lorrytrip_deliveryteamidToteamInput | lorrytripUpdateWithWhereUniqueWithoutTeam_lorrytrip_deliveryteamidToteamInput[]
    updateMany?: lorrytripUpdateManyWithWhereWithoutTeam_lorrytrip_deliveryteamidToteamInput | lorrytripUpdateManyWithWhereWithoutTeam_lorrytrip_deliveryteamidToteamInput[]
    deleteMany?: lorrytripScalarWhereInput | lorrytripScalarWhereInput[]
  }

  export type lorrytripUpdateManyWithoutTeam_lorrytrip_warehouseteamidToteamNestedInput = {
    create?: XOR<lorrytripCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput, lorrytripUncheckedCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput> | lorrytripCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput[] | lorrytripUncheckedCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput[]
    connectOrCreate?: lorrytripCreateOrConnectWithoutTeam_lorrytrip_warehouseteamidToteamInput | lorrytripCreateOrConnectWithoutTeam_lorrytrip_warehouseteamidToteamInput[]
    upsert?: lorrytripUpsertWithWhereUniqueWithoutTeam_lorrytrip_warehouseteamidToteamInput | lorrytripUpsertWithWhereUniqueWithoutTeam_lorrytrip_warehouseteamidToteamInput[]
    createMany?: lorrytripCreateManyTeam_lorrytrip_warehouseteamidToteamInputEnvelope
    set?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    disconnect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    delete?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    connect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    update?: lorrytripUpdateWithWhereUniqueWithoutTeam_lorrytrip_warehouseteamidToteamInput | lorrytripUpdateWithWhereUniqueWithoutTeam_lorrytrip_warehouseteamidToteamInput[]
    updateMany?: lorrytripUpdateManyWithWhereWithoutTeam_lorrytrip_warehouseteamidToteamInput | lorrytripUpdateManyWithWhereWithoutTeam_lorrytrip_warehouseteamidToteamInput[]
    deleteMany?: lorrytripScalarWhereInput | lorrytripScalarWhereInput[]
  }

  export type ordersUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ordersCreateWithoutTeamInput, ordersUncheckedCreateWithoutTeamInput> | ordersCreateWithoutTeamInput[] | ordersUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutTeamInput | ordersCreateOrConnectWithoutTeamInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutTeamInput | ordersUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ordersCreateManyTeamInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutTeamInput | ordersUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutTeamInput | ordersUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type employeeteamassignmentUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<employeeteamassignmentCreateWithoutTeamInput, employeeteamassignmentUncheckedCreateWithoutTeamInput> | employeeteamassignmentCreateWithoutTeamInput[] | employeeteamassignmentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: employeeteamassignmentCreateOrConnectWithoutTeamInput | employeeteamassignmentCreateOrConnectWithoutTeamInput[]
    upsert?: employeeteamassignmentUpsertWithWhereUniqueWithoutTeamInput | employeeteamassignmentUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: employeeteamassignmentCreateManyTeamInputEnvelope
    set?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    disconnect?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    delete?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    connect?: employeeteamassignmentWhereUniqueInput | employeeteamassignmentWhereUniqueInput[]
    update?: employeeteamassignmentUpdateWithWhereUniqueWithoutTeamInput | employeeteamassignmentUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: employeeteamassignmentUpdateManyWithWhereWithoutTeamInput | employeeteamassignmentUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: employeeteamassignmentScalarWhereInput | employeeteamassignmentScalarWhereInput[]
  }

  export type lorrytripUncheckedUpdateManyWithoutTeam_lorrytrip_deliveryteamidToteamNestedInput = {
    create?: XOR<lorrytripCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput, lorrytripUncheckedCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput> | lorrytripCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput[] | lorrytripUncheckedCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput[]
    connectOrCreate?: lorrytripCreateOrConnectWithoutTeam_lorrytrip_deliveryteamidToteamInput | lorrytripCreateOrConnectWithoutTeam_lorrytrip_deliveryteamidToteamInput[]
    upsert?: lorrytripUpsertWithWhereUniqueWithoutTeam_lorrytrip_deliveryteamidToteamInput | lorrytripUpsertWithWhereUniqueWithoutTeam_lorrytrip_deliveryteamidToteamInput[]
    createMany?: lorrytripCreateManyTeam_lorrytrip_deliveryteamidToteamInputEnvelope
    set?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    disconnect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    delete?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    connect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    update?: lorrytripUpdateWithWhereUniqueWithoutTeam_lorrytrip_deliveryteamidToteamInput | lorrytripUpdateWithWhereUniqueWithoutTeam_lorrytrip_deliveryteamidToteamInput[]
    updateMany?: lorrytripUpdateManyWithWhereWithoutTeam_lorrytrip_deliveryteamidToteamInput | lorrytripUpdateManyWithWhereWithoutTeam_lorrytrip_deliveryteamidToteamInput[]
    deleteMany?: lorrytripScalarWhereInput | lorrytripScalarWhereInput[]
  }

  export type lorrytripUncheckedUpdateManyWithoutTeam_lorrytrip_warehouseteamidToteamNestedInput = {
    create?: XOR<lorrytripCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput, lorrytripUncheckedCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput> | lorrytripCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput[] | lorrytripUncheckedCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput[]
    connectOrCreate?: lorrytripCreateOrConnectWithoutTeam_lorrytrip_warehouseteamidToteamInput | lorrytripCreateOrConnectWithoutTeam_lorrytrip_warehouseteamidToteamInput[]
    upsert?: lorrytripUpsertWithWhereUniqueWithoutTeam_lorrytrip_warehouseteamidToteamInput | lorrytripUpsertWithWhereUniqueWithoutTeam_lorrytrip_warehouseteamidToteamInput[]
    createMany?: lorrytripCreateManyTeam_lorrytrip_warehouseteamidToteamInputEnvelope
    set?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    disconnect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    delete?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    connect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    update?: lorrytripUpdateWithWhereUniqueWithoutTeam_lorrytrip_warehouseteamidToteamInput | lorrytripUpdateWithWhereUniqueWithoutTeam_lorrytrip_warehouseteamidToteamInput[]
    updateMany?: lorrytripUpdateManyWithWhereWithoutTeam_lorrytrip_warehouseteamidToteamInput | lorrytripUpdateManyWithWhereWithoutTeam_lorrytrip_warehouseteamidToteamInput[]
    deleteMany?: lorrytripScalarWhereInput | lorrytripScalarWhereInput[]
  }

  export type ordersUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<ordersCreateWithoutTeamInput, ordersUncheckedCreateWithoutTeamInput> | ordersCreateWithoutTeamInput[] | ordersUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutTeamInput | ordersCreateOrConnectWithoutTeamInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutTeamInput | ordersUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: ordersCreateManyTeamInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutTeamInput | ordersUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutTeamInput | ordersUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type ordersCreateNestedManyWithoutTimeslotInput = {
    create?: XOR<ordersCreateWithoutTimeslotInput, ordersUncheckedCreateWithoutTimeslotInput> | ordersCreateWithoutTimeslotInput[] | ordersUncheckedCreateWithoutTimeslotInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutTimeslotInput | ordersCreateOrConnectWithoutTimeslotInput[]
    createMany?: ordersCreateManyTimeslotInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type lorrytripCreateNestedOneWithoutTimeslotInput = {
    create?: XOR<lorrytripCreateWithoutTimeslotInput, lorrytripUncheckedCreateWithoutTimeslotInput>
    connectOrCreate?: lorrytripCreateOrConnectWithoutTimeslotInput
    connect?: lorrytripWhereUniqueInput
  }

  export type ordersUncheckedCreateNestedManyWithoutTimeslotInput = {
    create?: XOR<ordersCreateWithoutTimeslotInput, ordersUncheckedCreateWithoutTimeslotInput> | ordersCreateWithoutTimeslotInput[] | ordersUncheckedCreateWithoutTimeslotInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutTimeslotInput | ordersCreateOrConnectWithoutTimeslotInput[]
    createMany?: ordersCreateManyTimeslotInputEnvelope
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
  }

  export type ordersUpdateManyWithoutTimeslotNestedInput = {
    create?: XOR<ordersCreateWithoutTimeslotInput, ordersUncheckedCreateWithoutTimeslotInput> | ordersCreateWithoutTimeslotInput[] | ordersUncheckedCreateWithoutTimeslotInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutTimeslotInput | ordersCreateOrConnectWithoutTimeslotInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutTimeslotInput | ordersUpsertWithWhereUniqueWithoutTimeslotInput[]
    createMany?: ordersCreateManyTimeslotInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutTimeslotInput | ordersUpdateWithWhereUniqueWithoutTimeslotInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutTimeslotInput | ordersUpdateManyWithWhereWithoutTimeslotInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type lorrytripUpdateOneWithoutTimeslotNestedInput = {
    create?: XOR<lorrytripCreateWithoutTimeslotInput, lorrytripUncheckedCreateWithoutTimeslotInput>
    connectOrCreate?: lorrytripCreateOrConnectWithoutTimeslotInput
    upsert?: lorrytripUpsertWithoutTimeslotInput
    disconnect?: lorrytripWhereInput | boolean
    delete?: lorrytripWhereInput | boolean
    connect?: lorrytripWhereUniqueInput
    update?: XOR<XOR<lorrytripUpdateToOneWithWhereWithoutTimeslotInput, lorrytripUpdateWithoutTimeslotInput>, lorrytripUncheckedUpdateWithoutTimeslotInput>
  }

  export type ordersUncheckedUpdateManyWithoutTimeslotNestedInput = {
    create?: XOR<ordersCreateWithoutTimeslotInput, ordersUncheckedCreateWithoutTimeslotInput> | ordersCreateWithoutTimeslotInput[] | ordersUncheckedCreateWithoutTimeslotInput[]
    connectOrCreate?: ordersCreateOrConnectWithoutTimeslotInput | ordersCreateOrConnectWithoutTimeslotInput[]
    upsert?: ordersUpsertWithWhereUniqueWithoutTimeslotInput | ordersUpsertWithWhereUniqueWithoutTimeslotInput[]
    createMany?: ordersCreateManyTimeslotInputEnvelope
    set?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    disconnect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    delete?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    connect?: ordersWhereUniqueInput | ordersWhereUniqueInput[]
    update?: ordersUpdateWithWhereUniqueWithoutTimeslotInput | ordersUpdateWithWhereUniqueWithoutTimeslotInput[]
    updateMany?: ordersUpdateManyWithWhereWithoutTimeslotInput | ordersUpdateManyWithWhereWithoutTimeslotInput[]
    deleteMany?: ordersScalarWhereInput | ordersScalarWhereInput[]
  }

  export type lorrytripCreateNestedManyWithoutTruckInput = {
    create?: XOR<lorrytripCreateWithoutTruckInput, lorrytripUncheckedCreateWithoutTruckInput> | lorrytripCreateWithoutTruckInput[] | lorrytripUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: lorrytripCreateOrConnectWithoutTruckInput | lorrytripCreateOrConnectWithoutTruckInput[]
    createMany?: lorrytripCreateManyTruckInputEnvelope
    connect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
  }

  export type truckzoneCreateNestedManyWithoutTruckInput = {
    create?: XOR<truckzoneCreateWithoutTruckInput, truckzoneUncheckedCreateWithoutTruckInput> | truckzoneCreateWithoutTruckInput[] | truckzoneUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: truckzoneCreateOrConnectWithoutTruckInput | truckzoneCreateOrConnectWithoutTruckInput[]
    createMany?: truckzoneCreateManyTruckInputEnvelope
    connect?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
  }

  export type lorrytripUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<lorrytripCreateWithoutTruckInput, lorrytripUncheckedCreateWithoutTruckInput> | lorrytripCreateWithoutTruckInput[] | lorrytripUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: lorrytripCreateOrConnectWithoutTruckInput | lorrytripCreateOrConnectWithoutTruckInput[]
    createMany?: lorrytripCreateManyTruckInputEnvelope
    connect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
  }

  export type truckzoneUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<truckzoneCreateWithoutTruckInput, truckzoneUncheckedCreateWithoutTruckInput> | truckzoneCreateWithoutTruckInput[] | truckzoneUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: truckzoneCreateOrConnectWithoutTruckInput | truckzoneCreateOrConnectWithoutTruckInput[]
    createMany?: truckzoneCreateManyTruckInputEnvelope
    connect?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
  }

  export type lorrytripUpdateManyWithoutTruckNestedInput = {
    create?: XOR<lorrytripCreateWithoutTruckInput, lorrytripUncheckedCreateWithoutTruckInput> | lorrytripCreateWithoutTruckInput[] | lorrytripUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: lorrytripCreateOrConnectWithoutTruckInput | lorrytripCreateOrConnectWithoutTruckInput[]
    upsert?: lorrytripUpsertWithWhereUniqueWithoutTruckInput | lorrytripUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: lorrytripCreateManyTruckInputEnvelope
    set?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    disconnect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    delete?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    connect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    update?: lorrytripUpdateWithWhereUniqueWithoutTruckInput | lorrytripUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: lorrytripUpdateManyWithWhereWithoutTruckInput | lorrytripUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: lorrytripScalarWhereInput | lorrytripScalarWhereInput[]
  }

  export type truckzoneUpdateManyWithoutTruckNestedInput = {
    create?: XOR<truckzoneCreateWithoutTruckInput, truckzoneUncheckedCreateWithoutTruckInput> | truckzoneCreateWithoutTruckInput[] | truckzoneUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: truckzoneCreateOrConnectWithoutTruckInput | truckzoneCreateOrConnectWithoutTruckInput[]
    upsert?: truckzoneUpsertWithWhereUniqueWithoutTruckInput | truckzoneUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: truckzoneCreateManyTruckInputEnvelope
    set?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    disconnect?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    delete?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    connect?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    update?: truckzoneUpdateWithWhereUniqueWithoutTruckInput | truckzoneUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: truckzoneUpdateManyWithWhereWithoutTruckInput | truckzoneUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: truckzoneScalarWhereInput | truckzoneScalarWhereInput[]
  }

  export type lorrytripUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<lorrytripCreateWithoutTruckInput, lorrytripUncheckedCreateWithoutTruckInput> | lorrytripCreateWithoutTruckInput[] | lorrytripUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: lorrytripCreateOrConnectWithoutTruckInput | lorrytripCreateOrConnectWithoutTruckInput[]
    upsert?: lorrytripUpsertWithWhereUniqueWithoutTruckInput | lorrytripUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: lorrytripCreateManyTruckInputEnvelope
    set?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    disconnect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    delete?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    connect?: lorrytripWhereUniqueInput | lorrytripWhereUniqueInput[]
    update?: lorrytripUpdateWithWhereUniqueWithoutTruckInput | lorrytripUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: lorrytripUpdateManyWithWhereWithoutTruckInput | lorrytripUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: lorrytripScalarWhereInput | lorrytripScalarWhereInput[]
  }

  export type truckzoneUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<truckzoneCreateWithoutTruckInput, truckzoneUncheckedCreateWithoutTruckInput> | truckzoneCreateWithoutTruckInput[] | truckzoneUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: truckzoneCreateOrConnectWithoutTruckInput | truckzoneCreateOrConnectWithoutTruckInput[]
    upsert?: truckzoneUpsertWithWhereUniqueWithoutTruckInput | truckzoneUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: truckzoneCreateManyTruckInputEnvelope
    set?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    disconnect?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    delete?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    connect?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    update?: truckzoneUpdateWithWhereUniqueWithoutTruckInput | truckzoneUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: truckzoneUpdateManyWithWhereWithoutTruckInput | truckzoneUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: truckzoneScalarWhereInput | truckzoneScalarWhereInput[]
  }

  export type truckCreateNestedOneWithoutTruckzoneInput = {
    create?: XOR<truckCreateWithoutTruckzoneInput, truckUncheckedCreateWithoutTruckzoneInput>
    connectOrCreate?: truckCreateOrConnectWithoutTruckzoneInput
    connect?: truckWhereUniqueInput
  }

  export type zoneCreateNestedOneWithoutTruckzoneInput = {
    create?: XOR<zoneCreateWithoutTruckzoneInput, zoneUncheckedCreateWithoutTruckzoneInput>
    connectOrCreate?: zoneCreateOrConnectWithoutTruckzoneInput
    connect?: zoneWhereUniqueInput
  }

  export type truckUpdateOneRequiredWithoutTruckzoneNestedInput = {
    create?: XOR<truckCreateWithoutTruckzoneInput, truckUncheckedCreateWithoutTruckzoneInput>
    connectOrCreate?: truckCreateOrConnectWithoutTruckzoneInput
    upsert?: truckUpsertWithoutTruckzoneInput
    connect?: truckWhereUniqueInput
    update?: XOR<XOR<truckUpdateToOneWithWhereWithoutTruckzoneInput, truckUpdateWithoutTruckzoneInput>, truckUncheckedUpdateWithoutTruckzoneInput>
  }

  export type zoneUpdateOneRequiredWithoutTruckzoneNestedInput = {
    create?: XOR<zoneCreateWithoutTruckzoneInput, zoneUncheckedCreateWithoutTruckzoneInput>
    connectOrCreate?: zoneCreateOrConnectWithoutTruckzoneInput
    upsert?: zoneUpsertWithoutTruckzoneInput
    connect?: zoneWhereUniqueInput
    update?: XOR<XOR<zoneUpdateToOneWithWhereWithoutTruckzoneInput, zoneUpdateWithoutTruckzoneInput>, zoneUncheckedUpdateWithoutTruckzoneInput>
  }

  export type buildingCreateNestedManyWithoutZoneInput = {
    create?: XOR<buildingCreateWithoutZoneInput, buildingUncheckedCreateWithoutZoneInput> | buildingCreateWithoutZoneInput[] | buildingUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: buildingCreateOrConnectWithoutZoneInput | buildingCreateOrConnectWithoutZoneInput[]
    createMany?: buildingCreateManyZoneInputEnvelope
    connect?: buildingWhereUniqueInput | buildingWhereUniqueInput[]
  }

  export type truckzoneCreateNestedManyWithoutZoneInput = {
    create?: XOR<truckzoneCreateWithoutZoneInput, truckzoneUncheckedCreateWithoutZoneInput> | truckzoneCreateWithoutZoneInput[] | truckzoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: truckzoneCreateOrConnectWithoutZoneInput | truckzoneCreateOrConnectWithoutZoneInput[]
    createMany?: truckzoneCreateManyZoneInputEnvelope
    connect?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
  }

  export type buildingUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<buildingCreateWithoutZoneInput, buildingUncheckedCreateWithoutZoneInput> | buildingCreateWithoutZoneInput[] | buildingUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: buildingCreateOrConnectWithoutZoneInput | buildingCreateOrConnectWithoutZoneInput[]
    createMany?: buildingCreateManyZoneInputEnvelope
    connect?: buildingWhereUniqueInput | buildingWhereUniqueInput[]
  }

  export type truckzoneUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<truckzoneCreateWithoutZoneInput, truckzoneUncheckedCreateWithoutZoneInput> | truckzoneCreateWithoutZoneInput[] | truckzoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: truckzoneCreateOrConnectWithoutZoneInput | truckzoneCreateOrConnectWithoutZoneInput[]
    createMany?: truckzoneCreateManyZoneInputEnvelope
    connect?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
  }

  export type buildingUpdateManyWithoutZoneNestedInput = {
    create?: XOR<buildingCreateWithoutZoneInput, buildingUncheckedCreateWithoutZoneInput> | buildingCreateWithoutZoneInput[] | buildingUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: buildingCreateOrConnectWithoutZoneInput | buildingCreateOrConnectWithoutZoneInput[]
    upsert?: buildingUpsertWithWhereUniqueWithoutZoneInput | buildingUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: buildingCreateManyZoneInputEnvelope
    set?: buildingWhereUniqueInput | buildingWhereUniqueInput[]
    disconnect?: buildingWhereUniqueInput | buildingWhereUniqueInput[]
    delete?: buildingWhereUniqueInput | buildingWhereUniqueInput[]
    connect?: buildingWhereUniqueInput | buildingWhereUniqueInput[]
    update?: buildingUpdateWithWhereUniqueWithoutZoneInput | buildingUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: buildingUpdateManyWithWhereWithoutZoneInput | buildingUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: buildingScalarWhereInput | buildingScalarWhereInput[]
  }

  export type truckzoneUpdateManyWithoutZoneNestedInput = {
    create?: XOR<truckzoneCreateWithoutZoneInput, truckzoneUncheckedCreateWithoutZoneInput> | truckzoneCreateWithoutZoneInput[] | truckzoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: truckzoneCreateOrConnectWithoutZoneInput | truckzoneCreateOrConnectWithoutZoneInput[]
    upsert?: truckzoneUpsertWithWhereUniqueWithoutZoneInput | truckzoneUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: truckzoneCreateManyZoneInputEnvelope
    set?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    disconnect?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    delete?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    connect?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    update?: truckzoneUpdateWithWhereUniqueWithoutZoneInput | truckzoneUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: truckzoneUpdateManyWithWhereWithoutZoneInput | truckzoneUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: truckzoneScalarWhereInput | truckzoneScalarWhereInput[]
  }

  export type buildingUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<buildingCreateWithoutZoneInput, buildingUncheckedCreateWithoutZoneInput> | buildingCreateWithoutZoneInput[] | buildingUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: buildingCreateOrConnectWithoutZoneInput | buildingCreateOrConnectWithoutZoneInput[]
    upsert?: buildingUpsertWithWhereUniqueWithoutZoneInput | buildingUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: buildingCreateManyZoneInputEnvelope
    set?: buildingWhereUniqueInput | buildingWhereUniqueInput[]
    disconnect?: buildingWhereUniqueInput | buildingWhereUniqueInput[]
    delete?: buildingWhereUniqueInput | buildingWhereUniqueInput[]
    connect?: buildingWhereUniqueInput | buildingWhereUniqueInput[]
    update?: buildingUpdateWithWhereUniqueWithoutZoneInput | buildingUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: buildingUpdateManyWithWhereWithoutZoneInput | buildingUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: buildingScalarWhereInput | buildingScalarWhereInput[]
  }

  export type truckzoneUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<truckzoneCreateWithoutZoneInput, truckzoneUncheckedCreateWithoutZoneInput> | truckzoneCreateWithoutZoneInput[] | truckzoneUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: truckzoneCreateOrConnectWithoutZoneInput | truckzoneCreateOrConnectWithoutZoneInput[]
    upsert?: truckzoneUpsertWithWhereUniqueWithoutZoneInput | truckzoneUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: truckzoneCreateManyZoneInputEnvelope
    set?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    disconnect?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    delete?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    connect?: truckzoneWhereUniqueInput | truckzoneWhereUniqueInput[]
    update?: truckzoneUpdateWithWhereUniqueWithoutZoneInput | truckzoneUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: truckzoneUpdateManyWithWhereWithoutZoneInput | truckzoneUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: truckzoneScalarWhereInput | truckzoneScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type zoneCreateWithoutBuildingInput = {
    zoneid: string
    zonename?: string | null
    truckzone?: truckzoneCreateNestedManyWithoutZoneInput
  }

  export type zoneUncheckedCreateWithoutBuildingInput = {
    zoneid: string
    zonename?: string | null
    truckzone?: truckzoneUncheckedCreateNestedManyWithoutZoneInput
  }

  export type zoneCreateOrConnectWithoutBuildingInput = {
    where: zoneWhereUniqueInput
    create: XOR<zoneCreateWithoutBuildingInput, zoneUncheckedCreateWithoutBuildingInput>
  }

  export type ordersCreateWithoutBuildingInput = {
    orderid: string
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
    orderproduct?: orderproductCreateNestedManyWithoutOrdersInput
    customer?: customerCreateNestedOneWithoutOrdersInput
    team?: teamCreateNestedOneWithoutOrdersInput
    employee?: employeeCreateNestedOneWithoutOrdersInput
    timeslot?: timeslotCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutBuildingInput = {
    orderid: string
    customerid?: string | null
    employeeid?: string | null
    deliveryteamid?: string | null
    timeslotid?: string | null
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
    orderproduct?: orderproductUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type ordersCreateOrConnectWithoutBuildingInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutBuildingInput, ordersUncheckedCreateWithoutBuildingInput>
  }

  export type ordersCreateManyBuildingInputEnvelope = {
    data: ordersCreateManyBuildingInput | ordersCreateManyBuildingInput[]
    skipDuplicates?: boolean
  }

  export type zoneUpsertWithoutBuildingInput = {
    update: XOR<zoneUpdateWithoutBuildingInput, zoneUncheckedUpdateWithoutBuildingInput>
    create: XOR<zoneCreateWithoutBuildingInput, zoneUncheckedCreateWithoutBuildingInput>
    where?: zoneWhereInput
  }

  export type zoneUpdateToOneWithWhereWithoutBuildingInput = {
    where?: zoneWhereInput
    data: XOR<zoneUpdateWithoutBuildingInput, zoneUncheckedUpdateWithoutBuildingInput>
  }

  export type zoneUpdateWithoutBuildingInput = {
    zoneid?: StringFieldUpdateOperationsInput | string
    zonename?: NullableStringFieldUpdateOperationsInput | string | null
    truckzone?: truckzoneUpdateManyWithoutZoneNestedInput
  }

  export type zoneUncheckedUpdateWithoutBuildingInput = {
    zoneid?: StringFieldUpdateOperationsInput | string
    zonename?: NullableStringFieldUpdateOperationsInput | string | null
    truckzone?: truckzoneUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ordersUpsertWithWhereUniqueWithoutBuildingInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutBuildingInput, ordersUncheckedUpdateWithoutBuildingInput>
    create: XOR<ordersCreateWithoutBuildingInput, ordersUncheckedCreateWithoutBuildingInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutBuildingInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutBuildingInput, ordersUncheckedUpdateWithoutBuildingInput>
  }

  export type ordersUpdateManyWithWhereWithoutBuildingInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutBuildingInput>
  }

  export type ordersScalarWhereInput = {
    AND?: ordersScalarWhereInput | ordersScalarWhereInput[]
    OR?: ordersScalarWhereInput[]
    NOT?: ordersScalarWhereInput | ordersScalarWhereInput[]
    orderid?: StringFilter<"orders"> | string
    customerid?: StringNullableFilter<"orders"> | string | null
    employeeid?: StringNullableFilter<"orders"> | string | null
    deliveryteamid?: StringNullableFilter<"orders"> | string | null
    buildingid?: StringNullableFilter<"orders"> | string | null
    timeslotid?: StringNullableFilter<"orders"> | string | null
    numberofattempts?: IntNullableFilter<"orders"> | number | null
    scheduledstartdatetime?: DateTimeNullableFilter<"orders"> | Date | string | null
    scheduledenddatetime?: DateTimeNullableFilter<"orders"> | Date | string | null
    actualstartdatetime?: DateTimeNullableFilter<"orders"> | Date | string | null
    actualenddatetime?: DateTimeNullableFilter<"orders"> | Date | string | null
    actualarrivaldatetime?: DateTimeNullableFilter<"orders"> | Date | string | null
    customerrating?: DecimalNullableFilter<"orders"> | Decimal | DecimalJsLike | number | string | null
    delayreason?: StringNullableFilter<"orders"> | string | null
    customerfeedback?: StringNullableFilter<"orders"> | string | null
    proofofdeliveryurl?: StringNullableFilter<"orders"> | string | null
    orderstatus?: StringNullableFilter<"orders"> | string | null
    updatedat?: DateTimeNullableFilter<"orders"> | Date | string | null
    createdat?: DateTimeNullableFilter<"orders"> | Date | string | null
  }

  export type ordersCreateWithoutCustomerInput = {
    orderid: string
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
    orderproduct?: orderproductCreateNestedManyWithoutOrdersInput
    building?: buildingCreateNestedOneWithoutOrdersInput
    team?: teamCreateNestedOneWithoutOrdersInput
    employee?: employeeCreateNestedOneWithoutOrdersInput
    timeslot?: timeslotCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutCustomerInput = {
    orderid: string
    employeeid?: string | null
    deliveryteamid?: string | null
    buildingid?: string | null
    timeslotid?: string | null
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
    orderproduct?: orderproductUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type ordersCreateOrConnectWithoutCustomerInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutCustomerInput, ordersUncheckedCreateWithoutCustomerInput>
  }

  export type ordersCreateManyCustomerInputEnvelope = {
    data: ordersCreateManyCustomerInput | ordersCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ordersUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutCustomerInput, ordersUncheckedUpdateWithoutCustomerInput>
    create: XOR<ordersCreateWithoutCustomerInput, ordersUncheckedCreateWithoutCustomerInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutCustomerInput, ordersUncheckedUpdateWithoutCustomerInput>
  }

  export type ordersUpdateManyWithWhereWithoutCustomerInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutCustomerInput>
  }

  export type employeeteamassignmentCreateWithoutEmployeeInput = {
    team: teamCreateNestedOneWithoutEmployeeteamassignmentInput
  }

  export type employeeteamassignmentUncheckedCreateWithoutEmployeeInput = {
    teamid: string
  }

  export type employeeteamassignmentCreateOrConnectWithoutEmployeeInput = {
    where: employeeteamassignmentWhereUniqueInput
    create: XOR<employeeteamassignmentCreateWithoutEmployeeInput, employeeteamassignmentUncheckedCreateWithoutEmployeeInput>
  }

  export type employeeteamassignmentCreateManyEmployeeInputEnvelope = {
    data: employeeteamassignmentCreateManyEmployeeInput | employeeteamassignmentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type ordersCreateWithoutEmployeeInput = {
    orderid: string
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
    orderproduct?: orderproductCreateNestedManyWithoutOrdersInput
    building?: buildingCreateNestedOneWithoutOrdersInput
    customer?: customerCreateNestedOneWithoutOrdersInput
    team?: teamCreateNestedOneWithoutOrdersInput
    timeslot?: timeslotCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutEmployeeInput = {
    orderid: string
    customerid?: string | null
    deliveryteamid?: string | null
    buildingid?: string | null
    timeslotid?: string | null
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
    orderproduct?: orderproductUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type ordersCreateOrConnectWithoutEmployeeInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutEmployeeInput, ordersUncheckedCreateWithoutEmployeeInput>
  }

  export type ordersCreateManyEmployeeInputEnvelope = {
    data: ordersCreateManyEmployeeInput | ordersCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type employeeteamassignmentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: employeeteamassignmentWhereUniqueInput
    update: XOR<employeeteamassignmentUpdateWithoutEmployeeInput, employeeteamassignmentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<employeeteamassignmentCreateWithoutEmployeeInput, employeeteamassignmentUncheckedCreateWithoutEmployeeInput>
  }

  export type employeeteamassignmentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: employeeteamassignmentWhereUniqueInput
    data: XOR<employeeteamassignmentUpdateWithoutEmployeeInput, employeeteamassignmentUncheckedUpdateWithoutEmployeeInput>
  }

  export type employeeteamassignmentUpdateManyWithWhereWithoutEmployeeInput = {
    where: employeeteamassignmentScalarWhereInput
    data: XOR<employeeteamassignmentUpdateManyMutationInput, employeeteamassignmentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type employeeteamassignmentScalarWhereInput = {
    AND?: employeeteamassignmentScalarWhereInput | employeeteamassignmentScalarWhereInput[]
    OR?: employeeteamassignmentScalarWhereInput[]
    NOT?: employeeteamassignmentScalarWhereInput | employeeteamassignmentScalarWhereInput[]
    employeeid?: StringFilter<"employeeteamassignment"> | string
    teamid?: StringFilter<"employeeteamassignment"> | string
  }

  export type ordersUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutEmployeeInput, ordersUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ordersCreateWithoutEmployeeInput, ordersUncheckedCreateWithoutEmployeeInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutEmployeeInput, ordersUncheckedUpdateWithoutEmployeeInput>
  }

  export type ordersUpdateManyWithWhereWithoutEmployeeInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type employeeCreateWithoutEmployeeteamassignmentInput = {
    employeeid: string
    name?: string | null
    email?: string | null
    contact_number?: string | null
    role?: string | null
    active_flag?: boolean | null
    displayname?: string | null
    createdat?: Date | string | null
    bio?: string | null
    orders?: ordersCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutEmployeeteamassignmentInput = {
    employeeid: string
    name?: string | null
    email?: string | null
    contact_number?: string | null
    role?: string | null
    active_flag?: boolean | null
    displayname?: string | null
    createdat?: Date | string | null
    bio?: string | null
    orders?: ordersUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutEmployeeteamassignmentInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutEmployeeteamassignmentInput, employeeUncheckedCreateWithoutEmployeeteamassignmentInput>
  }

  export type teamCreateWithoutEmployeeteamassignmentInput = {
    teamid: string
    teamtype?: string | null
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripCreateNestedManyWithoutTeam_lorrytrip_deliveryteamidToteamInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripCreateNestedManyWithoutTeam_lorrytrip_warehouseteamidToteamInput
    orders?: ordersCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutEmployeeteamassignmentInput = {
    teamid: string
    teamtype?: string | null
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripUncheckedCreateNestedManyWithoutTeam_lorrytrip_deliveryteamidToteamInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripUncheckedCreateNestedManyWithoutTeam_lorrytrip_warehouseteamidToteamInput
    orders?: ordersUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutEmployeeteamassignmentInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutEmployeeteamassignmentInput, teamUncheckedCreateWithoutEmployeeteamassignmentInput>
  }

  export type employeeUpsertWithoutEmployeeteamassignmentInput = {
    update: XOR<employeeUpdateWithoutEmployeeteamassignmentInput, employeeUncheckedUpdateWithoutEmployeeteamassignmentInput>
    create: XOR<employeeCreateWithoutEmployeeteamassignmentInput, employeeUncheckedCreateWithoutEmployeeteamassignmentInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutEmployeeteamassignmentInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutEmployeeteamassignmentInput, employeeUncheckedUpdateWithoutEmployeeteamassignmentInput>
  }

  export type employeeUpdateWithoutEmployeeteamassignmentInput = {
    employeeid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    active_flag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutEmployeeteamassignmentInput = {
    employeeid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    active_flag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type teamUpsertWithoutEmployeeteamassignmentInput = {
    update: XOR<teamUpdateWithoutEmployeeteamassignmentInput, teamUncheckedUpdateWithoutEmployeeteamassignmentInput>
    create: XOR<teamCreateWithoutEmployeeteamassignmentInput, teamUncheckedCreateWithoutEmployeeteamassignmentInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutEmployeeteamassignmentInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutEmployeeteamassignmentInput, teamUncheckedUpdateWithoutEmployeeteamassignmentInput>
  }

  export type teamUpdateWithoutEmployeeteamassignmentInput = {
    teamid?: StringFieldUpdateOperationsInput | string
    teamtype?: NullableStringFieldUpdateOperationsInput | string | null
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripUpdateManyWithoutTeam_lorrytrip_deliveryteamidToteamNestedInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripUpdateManyWithoutTeam_lorrytrip_warehouseteamidToteamNestedInput
    orders?: ordersUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutEmployeeteamassignmentInput = {
    teamid?: StringFieldUpdateOperationsInput | string
    teamtype?: NullableStringFieldUpdateOperationsInput | string | null
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripUncheckedUpdateManyWithoutTeam_lorrytrip_deliveryteamidToteamNestedInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripUncheckedUpdateManyWithoutTeam_lorrytrip_warehouseteamidToteamNestedInput
    orders?: ordersUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamCreateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput = {
    teamid: string
    teamtype?: string | null
    employeeteamassignment?: employeeteamassignmentCreateNestedManyWithoutTeamInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripCreateNestedManyWithoutTeam_lorrytrip_warehouseteamidToteamInput
    orders?: ordersCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput = {
    teamid: string
    teamtype?: string | null
    employeeteamassignment?: employeeteamassignmentUncheckedCreateNestedManyWithoutTeamInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripUncheckedCreateNestedManyWithoutTeam_lorrytrip_warehouseteamidToteamInput
    orders?: ordersUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput, teamUncheckedCreateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput>
  }

  export type truckCreateWithoutLorrytripInput = {
    truckid: string
    carplate?: string | null
    tone?: number | null
    lengthcm?: number | null
    widthcm?: number | null
    heightcm?: number | null
    truckzone?: truckzoneCreateNestedManyWithoutTruckInput
  }

  export type truckUncheckedCreateWithoutLorrytripInput = {
    truckid: string
    carplate?: string | null
    tone?: number | null
    lengthcm?: number | null
    widthcm?: number | null
    heightcm?: number | null
    truckzone?: truckzoneUncheckedCreateNestedManyWithoutTruckInput
  }

  export type truckCreateOrConnectWithoutLorrytripInput = {
    where: truckWhereUniqueInput
    create: XOR<truckCreateWithoutLorrytripInput, truckUncheckedCreateWithoutLorrytripInput>
  }

  export type teamCreateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput = {
    teamid: string
    teamtype?: string | null
    employeeteamassignment?: employeeteamassignmentCreateNestedManyWithoutTeamInput
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripCreateNestedManyWithoutTeam_lorrytrip_deliveryteamidToteamInput
    orders?: ordersCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput = {
    teamid: string
    teamtype?: string | null
    employeeteamassignment?: employeeteamassignmentUncheckedCreateNestedManyWithoutTeamInput
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripUncheckedCreateNestedManyWithoutTeam_lorrytrip_deliveryteamidToteamInput
    orders?: ordersUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput, teamUncheckedCreateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput>
  }

  export type timeslotCreateWithoutLorrytripInput = {
    timeslotid: string
    date?: Date | string | null
    timewindowstart?: Date | string | null
    timewindowend?: Date | string | null
    availableflag?: boolean | null
    orders?: ordersCreateNestedManyWithoutTimeslotInput
  }

  export type timeslotUncheckedCreateWithoutLorrytripInput = {
    timeslotid: string
    date?: Date | string | null
    timewindowstart?: Date | string | null
    timewindowend?: Date | string | null
    availableflag?: boolean | null
    orders?: ordersUncheckedCreateNestedManyWithoutTimeslotInput
  }

  export type timeslotCreateOrConnectWithoutLorrytripInput = {
    where: timeslotWhereUniqueInput
    create: XOR<timeslotCreateWithoutLorrytripInput, timeslotUncheckedCreateWithoutLorrytripInput>
  }

  export type timeslotCreateManyLorrytripInputEnvelope = {
    data: timeslotCreateManyLorrytripInput | timeslotCreateManyLorrytripInput[]
    skipDuplicates?: boolean
  }

  export type teamUpsertWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput = {
    update: XOR<teamUpdateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput, teamUncheckedUpdateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput>
    create: XOR<teamCreateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput, teamUncheckedCreateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput, teamUncheckedUpdateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput>
  }

  export type teamUpdateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput = {
    teamid?: StringFieldUpdateOperationsInput | string
    teamtype?: NullableStringFieldUpdateOperationsInput | string | null
    employeeteamassignment?: employeeteamassignmentUpdateManyWithoutTeamNestedInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripUpdateManyWithoutTeam_lorrytrip_warehouseteamidToteamNestedInput
    orders?: ordersUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput = {
    teamid?: StringFieldUpdateOperationsInput | string
    teamtype?: NullableStringFieldUpdateOperationsInput | string | null
    employeeteamassignment?: employeeteamassignmentUncheckedUpdateManyWithoutTeamNestedInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripUncheckedUpdateManyWithoutTeam_lorrytrip_warehouseteamidToteamNestedInput
    orders?: ordersUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type truckUpsertWithoutLorrytripInput = {
    update: XOR<truckUpdateWithoutLorrytripInput, truckUncheckedUpdateWithoutLorrytripInput>
    create: XOR<truckCreateWithoutLorrytripInput, truckUncheckedCreateWithoutLorrytripInput>
    where?: truckWhereInput
  }

  export type truckUpdateToOneWithWhereWithoutLorrytripInput = {
    where?: truckWhereInput
    data: XOR<truckUpdateWithoutLorrytripInput, truckUncheckedUpdateWithoutLorrytripInput>
  }

  export type truckUpdateWithoutLorrytripInput = {
    truckid?: StringFieldUpdateOperationsInput | string
    carplate?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: NullableIntFieldUpdateOperationsInput | number | null
    lengthcm?: NullableIntFieldUpdateOperationsInput | number | null
    widthcm?: NullableIntFieldUpdateOperationsInput | number | null
    heightcm?: NullableIntFieldUpdateOperationsInput | number | null
    truckzone?: truckzoneUpdateManyWithoutTruckNestedInput
  }

  export type truckUncheckedUpdateWithoutLorrytripInput = {
    truckid?: StringFieldUpdateOperationsInput | string
    carplate?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: NullableIntFieldUpdateOperationsInput | number | null
    lengthcm?: NullableIntFieldUpdateOperationsInput | number | null
    widthcm?: NullableIntFieldUpdateOperationsInput | number | null
    heightcm?: NullableIntFieldUpdateOperationsInput | number | null
    truckzone?: truckzoneUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type teamUpsertWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput = {
    update: XOR<teamUpdateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput, teamUncheckedUpdateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput>
    create: XOR<teamCreateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput, teamUncheckedCreateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput, teamUncheckedUpdateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput>
  }

  export type teamUpdateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput = {
    teamid?: StringFieldUpdateOperationsInput | string
    teamtype?: NullableStringFieldUpdateOperationsInput | string | null
    employeeteamassignment?: employeeteamassignmentUpdateManyWithoutTeamNestedInput
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripUpdateManyWithoutTeam_lorrytrip_deliveryteamidToteamNestedInput
    orders?: ordersUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput = {
    teamid?: StringFieldUpdateOperationsInput | string
    teamtype?: NullableStringFieldUpdateOperationsInput | string | null
    employeeteamassignment?: employeeteamassignmentUncheckedUpdateManyWithoutTeamNestedInput
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripUncheckedUpdateManyWithoutTeam_lorrytrip_deliveryteamidToteamNestedInput
    orders?: ordersUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type timeslotUpsertWithWhereUniqueWithoutLorrytripInput = {
    where: timeslotWhereUniqueInput
    update: XOR<timeslotUpdateWithoutLorrytripInput, timeslotUncheckedUpdateWithoutLorrytripInput>
    create: XOR<timeslotCreateWithoutLorrytripInput, timeslotUncheckedCreateWithoutLorrytripInput>
  }

  export type timeslotUpdateWithWhereUniqueWithoutLorrytripInput = {
    where: timeslotWhereUniqueInput
    data: XOR<timeslotUpdateWithoutLorrytripInput, timeslotUncheckedUpdateWithoutLorrytripInput>
  }

  export type timeslotUpdateManyWithWhereWithoutLorrytripInput = {
    where: timeslotScalarWhereInput
    data: XOR<timeslotUpdateManyMutationInput, timeslotUncheckedUpdateManyWithoutLorrytripInput>
  }

  export type timeslotScalarWhereInput = {
    AND?: timeslotScalarWhereInput | timeslotScalarWhereInput[]
    OR?: timeslotScalarWhereInput[]
    NOT?: timeslotScalarWhereInput | timeslotScalarWhereInput[]
    timeslotid?: StringFilter<"timeslot"> | string
    lorrytripid?: StringNullableFilter<"timeslot"> | string | null
    date?: DateTimeNullableFilter<"timeslot"> | Date | string | null
    timewindowstart?: DateTimeNullableFilter<"timeslot"> | Date | string | null
    timewindowend?: DateTimeNullableFilter<"timeslot"> | Date | string | null
    availableflag?: BoolNullableFilter<"timeslot"> | boolean | null
  }

  export type ordersCreateWithoutOrderproductInput = {
    orderid: string
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
    building?: buildingCreateNestedOneWithoutOrdersInput
    customer?: customerCreateNestedOneWithoutOrdersInput
    team?: teamCreateNestedOneWithoutOrdersInput
    employee?: employeeCreateNestedOneWithoutOrdersInput
    timeslot?: timeslotCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutOrderproductInput = {
    orderid: string
    customerid?: string | null
    employeeid?: string | null
    deliveryteamid?: string | null
    buildingid?: string | null
    timeslotid?: string | null
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
  }

  export type ordersCreateOrConnectWithoutOrderproductInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutOrderproductInput, ordersUncheckedCreateWithoutOrderproductInput>
  }

  export type productCreateWithoutOrderproductInput = {
    productid: string
    productname?: string | null
    packagelengthcm?: number | null
    packagewidthcm?: number | null
    packageheightcm?: number | null
    installerteamrequiredflag?: boolean | null
    dismantlerequiredflag?: boolean | null
    dismantleextratime?: number | null
    estimatedinstallationtimemin?: number | null
    estimatedinstallationtimemax?: number | null
    fragileflag?: boolean | null
    noliedownflag?: boolean | null
  }

  export type productUncheckedCreateWithoutOrderproductInput = {
    productid: string
    productname?: string | null
    packagelengthcm?: number | null
    packagewidthcm?: number | null
    packageheightcm?: number | null
    installerteamrequiredflag?: boolean | null
    dismantlerequiredflag?: boolean | null
    dismantleextratime?: number | null
    estimatedinstallationtimemin?: number | null
    estimatedinstallationtimemax?: number | null
    fragileflag?: boolean | null
    noliedownflag?: boolean | null
  }

  export type productCreateOrConnectWithoutOrderproductInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutOrderproductInput, productUncheckedCreateWithoutOrderproductInput>
  }

  export type ordersUpsertWithoutOrderproductInput = {
    update: XOR<ordersUpdateWithoutOrderproductInput, ordersUncheckedUpdateWithoutOrderproductInput>
    create: XOR<ordersCreateWithoutOrderproductInput, ordersUncheckedCreateWithoutOrderproductInput>
    where?: ordersWhereInput
  }

  export type ordersUpdateToOneWithWhereWithoutOrderproductInput = {
    where?: ordersWhereInput
    data: XOR<ordersUpdateWithoutOrderproductInput, ordersUncheckedUpdateWithoutOrderproductInput>
  }

  export type ordersUpdateWithoutOrderproductInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    building?: buildingUpdateOneWithoutOrdersNestedInput
    customer?: customerUpdateOneWithoutOrdersNestedInput
    team?: teamUpdateOneWithoutOrdersNestedInput
    employee?: employeeUpdateOneWithoutOrdersNestedInput
    timeslot?: timeslotUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateWithoutOrderproductInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    employeeid?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    buildingid?: NullableStringFieldUpdateOperationsInput | string | null
    timeslotid?: NullableStringFieldUpdateOperationsInput | string | null
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type productUpsertWithoutOrderproductInput = {
    update: XOR<productUpdateWithoutOrderproductInput, productUncheckedUpdateWithoutOrderproductInput>
    create: XOR<productCreateWithoutOrderproductInput, productUncheckedCreateWithoutOrderproductInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutOrderproductInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutOrderproductInput, productUncheckedUpdateWithoutOrderproductInput>
  }

  export type productUpdateWithoutOrderproductInput = {
    productid?: StringFieldUpdateOperationsInput | string
    productname?: NullableStringFieldUpdateOperationsInput | string | null
    packagelengthcm?: NullableIntFieldUpdateOperationsInput | number | null
    packagewidthcm?: NullableIntFieldUpdateOperationsInput | number | null
    packageheightcm?: NullableIntFieldUpdateOperationsInput | number | null
    installerteamrequiredflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismantlerequiredflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismantleextratime?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedinstallationtimemin?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedinstallationtimemax?: NullableIntFieldUpdateOperationsInput | number | null
    fragileflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    noliedownflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type productUncheckedUpdateWithoutOrderproductInput = {
    productid?: StringFieldUpdateOperationsInput | string
    productname?: NullableStringFieldUpdateOperationsInput | string | null
    packagelengthcm?: NullableIntFieldUpdateOperationsInput | number | null
    packagewidthcm?: NullableIntFieldUpdateOperationsInput | number | null
    packageheightcm?: NullableIntFieldUpdateOperationsInput | number | null
    installerteamrequiredflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismantlerequiredflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dismantleextratime?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedinstallationtimemin?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedinstallationtimemax?: NullableIntFieldUpdateOperationsInput | number | null
    fragileflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    noliedownflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type orderproductCreateWithoutOrdersInput = {
    quantity?: number | null
    product: productCreateNestedOneWithoutOrderproductInput
  }

  export type orderproductUncheckedCreateWithoutOrdersInput = {
    productid: string
    quantity?: number | null
  }

  export type orderproductCreateOrConnectWithoutOrdersInput = {
    where: orderproductWhereUniqueInput
    create: XOR<orderproductCreateWithoutOrdersInput, orderproductUncheckedCreateWithoutOrdersInput>
  }

  export type orderproductCreateManyOrdersInputEnvelope = {
    data: orderproductCreateManyOrdersInput | orderproductCreateManyOrdersInput[]
    skipDuplicates?: boolean
  }

  export type buildingCreateWithoutOrdersInput = {
    buildingid: string
    buildingname?: string | null
    housingtype?: string | null
    postalcode?: string | null
    vehiclesizelimit?: string | null
    vehiclelengthlimit?: Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: boolean | null
    liftavailable?: boolean | null
    stairsavailable?: boolean | null
    narrowdoorways?: boolean | null
    parkingdistance?: number | null
    preregistrationrequired?: boolean | null
    accesstimewindowstart?: Date | string | null
    accesstimewindowend?: Date | string | null
    notes?: string | null
    specialequipmentneeded?: string | null
    liftdimensions?: string | null
    zone?: zoneCreateNestedOneWithoutBuildingInput
  }

  export type buildingUncheckedCreateWithoutOrdersInput = {
    buildingid: string
    buildingname?: string | null
    housingtype?: string | null
    postalcode?: string | null
    zoneid?: string | null
    vehiclesizelimit?: string | null
    vehiclelengthlimit?: Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: boolean | null
    liftavailable?: boolean | null
    stairsavailable?: boolean | null
    narrowdoorways?: boolean | null
    parkingdistance?: number | null
    preregistrationrequired?: boolean | null
    accesstimewindowstart?: Date | string | null
    accesstimewindowend?: Date | string | null
    notes?: string | null
    specialequipmentneeded?: string | null
    liftdimensions?: string | null
  }

  export type buildingCreateOrConnectWithoutOrdersInput = {
    where: buildingWhereUniqueInput
    create: XOR<buildingCreateWithoutOrdersInput, buildingUncheckedCreateWithoutOrdersInput>
  }

  export type customerCreateWithoutOrdersInput = {
    customerid: string
    name?: string | null
    displayname?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    bio?: string | null
    notificationsenabled?: boolean | null
    createdat?: Date | string | null
  }

  export type customerUncheckedCreateWithoutOrdersInput = {
    customerid: string
    name?: string | null
    displayname?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    postcode?: string | null
    bio?: string | null
    notificationsenabled?: boolean | null
    createdat?: Date | string | null
  }

  export type customerCreateOrConnectWithoutOrdersInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutOrdersInput, customerUncheckedCreateWithoutOrdersInput>
  }

  export type teamCreateWithoutOrdersInput = {
    teamid: string
    teamtype?: string | null
    employeeteamassignment?: employeeteamassignmentCreateNestedManyWithoutTeamInput
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripCreateNestedManyWithoutTeam_lorrytrip_deliveryteamidToteamInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripCreateNestedManyWithoutTeam_lorrytrip_warehouseteamidToteamInput
  }

  export type teamUncheckedCreateWithoutOrdersInput = {
    teamid: string
    teamtype?: string | null
    employeeteamassignment?: employeeteamassignmentUncheckedCreateNestedManyWithoutTeamInput
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripUncheckedCreateNestedManyWithoutTeam_lorrytrip_deliveryteamidToteamInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripUncheckedCreateNestedManyWithoutTeam_lorrytrip_warehouseteamidToteamInput
  }

  export type teamCreateOrConnectWithoutOrdersInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutOrdersInput, teamUncheckedCreateWithoutOrdersInput>
  }

  export type employeeCreateWithoutOrdersInput = {
    employeeid: string
    name?: string | null
    email?: string | null
    contact_number?: string | null
    role?: string | null
    active_flag?: boolean | null
    displayname?: string | null
    createdat?: Date | string | null
    bio?: string | null
    employeeteamassignment?: employeeteamassignmentCreateNestedManyWithoutEmployeeInput
  }

  export type employeeUncheckedCreateWithoutOrdersInput = {
    employeeid: string
    name?: string | null
    email?: string | null
    contact_number?: string | null
    role?: string | null
    active_flag?: boolean | null
    displayname?: string | null
    createdat?: Date | string | null
    bio?: string | null
    employeeteamassignment?: employeeteamassignmentUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type employeeCreateOrConnectWithoutOrdersInput = {
    where: employeeWhereUniqueInput
    create: XOR<employeeCreateWithoutOrdersInput, employeeUncheckedCreateWithoutOrdersInput>
  }

  export type timeslotCreateWithoutOrdersInput = {
    timeslotid: string
    date?: Date | string | null
    timewindowstart?: Date | string | null
    timewindowend?: Date | string | null
    availableflag?: boolean | null
    lorrytrip?: lorrytripCreateNestedOneWithoutTimeslotInput
  }

  export type timeslotUncheckedCreateWithoutOrdersInput = {
    timeslotid: string
    lorrytripid?: string | null
    date?: Date | string | null
    timewindowstart?: Date | string | null
    timewindowend?: Date | string | null
    availableflag?: boolean | null
  }

  export type timeslotCreateOrConnectWithoutOrdersInput = {
    where: timeslotWhereUniqueInput
    create: XOR<timeslotCreateWithoutOrdersInput, timeslotUncheckedCreateWithoutOrdersInput>
  }

  export type orderproductUpsertWithWhereUniqueWithoutOrdersInput = {
    where: orderproductWhereUniqueInput
    update: XOR<orderproductUpdateWithoutOrdersInput, orderproductUncheckedUpdateWithoutOrdersInput>
    create: XOR<orderproductCreateWithoutOrdersInput, orderproductUncheckedCreateWithoutOrdersInput>
  }

  export type orderproductUpdateWithWhereUniqueWithoutOrdersInput = {
    where: orderproductWhereUniqueInput
    data: XOR<orderproductUpdateWithoutOrdersInput, orderproductUncheckedUpdateWithoutOrdersInput>
  }

  export type orderproductUpdateManyWithWhereWithoutOrdersInput = {
    where: orderproductScalarWhereInput
    data: XOR<orderproductUpdateManyMutationInput, orderproductUncheckedUpdateManyWithoutOrdersInput>
  }

  export type orderproductScalarWhereInput = {
    AND?: orderproductScalarWhereInput | orderproductScalarWhereInput[]
    OR?: orderproductScalarWhereInput[]
    NOT?: orderproductScalarWhereInput | orderproductScalarWhereInput[]
    orderid?: StringFilter<"orderproduct"> | string
    productid?: StringFilter<"orderproduct"> | string
    quantity?: IntNullableFilter<"orderproduct"> | number | null
  }

  export type buildingUpsertWithoutOrdersInput = {
    update: XOR<buildingUpdateWithoutOrdersInput, buildingUncheckedUpdateWithoutOrdersInput>
    create: XOR<buildingCreateWithoutOrdersInput, buildingUncheckedCreateWithoutOrdersInput>
    where?: buildingWhereInput
  }

  export type buildingUpdateToOneWithWhereWithoutOrdersInput = {
    where?: buildingWhereInput
    data: XOR<buildingUpdateWithoutOrdersInput, buildingUncheckedUpdateWithoutOrdersInput>
  }

  export type buildingUpdateWithoutOrdersInput = {
    buildingid?: StringFieldUpdateOperationsInput | string
    buildingname?: NullableStringFieldUpdateOperationsInput | string | null
    housingtype?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclesizelimit?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclelengthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liftavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stairsavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    narrowdoorways?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parkingdistance?: NullableIntFieldUpdateOperationsInput | number | null
    preregistrationrequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accesstimewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesstimewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specialequipmentneeded?: NullableStringFieldUpdateOperationsInput | string | null
    liftdimensions?: NullableStringFieldUpdateOperationsInput | string | null
    zone?: zoneUpdateOneWithoutBuildingNestedInput
  }

  export type buildingUncheckedUpdateWithoutOrdersInput = {
    buildingid?: StringFieldUpdateOperationsInput | string
    buildingname?: NullableStringFieldUpdateOperationsInput | string | null
    housingtype?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    zoneid?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclesizelimit?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclelengthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liftavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stairsavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    narrowdoorways?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parkingdistance?: NullableIntFieldUpdateOperationsInput | number | null
    preregistrationrequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accesstimewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesstimewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specialequipmentneeded?: NullableStringFieldUpdateOperationsInput | string | null
    liftdimensions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customerUpsertWithoutOrdersInput = {
    update: XOR<customerUpdateWithoutOrdersInput, customerUncheckedUpdateWithoutOrdersInput>
    create: XOR<customerCreateWithoutOrdersInput, customerUncheckedCreateWithoutOrdersInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutOrdersInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutOrdersInput, customerUncheckedUpdateWithoutOrdersInput>
  }

  export type customerUpdateWithoutOrdersInput = {
    customerid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsenabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type customerUncheckedUpdateWithoutOrdersInput = {
    customerid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    notificationsenabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type teamUpsertWithoutOrdersInput = {
    update: XOR<teamUpdateWithoutOrdersInput, teamUncheckedUpdateWithoutOrdersInput>
    create: XOR<teamCreateWithoutOrdersInput, teamUncheckedCreateWithoutOrdersInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutOrdersInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutOrdersInput, teamUncheckedUpdateWithoutOrdersInput>
  }

  export type teamUpdateWithoutOrdersInput = {
    teamid?: StringFieldUpdateOperationsInput | string
    teamtype?: NullableStringFieldUpdateOperationsInput | string | null
    employeeteamassignment?: employeeteamassignmentUpdateManyWithoutTeamNestedInput
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripUpdateManyWithoutTeam_lorrytrip_deliveryteamidToteamNestedInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripUpdateManyWithoutTeam_lorrytrip_warehouseteamidToteamNestedInput
  }

  export type teamUncheckedUpdateWithoutOrdersInput = {
    teamid?: StringFieldUpdateOperationsInput | string
    teamtype?: NullableStringFieldUpdateOperationsInput | string | null
    employeeteamassignment?: employeeteamassignmentUncheckedUpdateManyWithoutTeamNestedInput
    lorrytrip_lorrytrip_deliveryteamidToteam?: lorrytripUncheckedUpdateManyWithoutTeam_lorrytrip_deliveryteamidToteamNestedInput
    lorrytrip_lorrytrip_warehouseteamidToteam?: lorrytripUncheckedUpdateManyWithoutTeam_lorrytrip_warehouseteamidToteamNestedInput
  }

  export type employeeUpsertWithoutOrdersInput = {
    update: XOR<employeeUpdateWithoutOrdersInput, employeeUncheckedUpdateWithoutOrdersInput>
    create: XOR<employeeCreateWithoutOrdersInput, employeeUncheckedCreateWithoutOrdersInput>
    where?: employeeWhereInput
  }

  export type employeeUpdateToOneWithWhereWithoutOrdersInput = {
    where?: employeeWhereInput
    data: XOR<employeeUpdateWithoutOrdersInput, employeeUncheckedUpdateWithoutOrdersInput>
  }

  export type employeeUpdateWithoutOrdersInput = {
    employeeid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    active_flag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    employeeteamassignment?: employeeteamassignmentUpdateManyWithoutEmployeeNestedInput
  }

  export type employeeUncheckedUpdateWithoutOrdersInput = {
    employeeid?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    active_flag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    displayname?: NullableStringFieldUpdateOperationsInput | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    employeeteamassignment?: employeeteamassignmentUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type timeslotUpsertWithoutOrdersInput = {
    update: XOR<timeslotUpdateWithoutOrdersInput, timeslotUncheckedUpdateWithoutOrdersInput>
    create: XOR<timeslotCreateWithoutOrdersInput, timeslotUncheckedCreateWithoutOrdersInput>
    where?: timeslotWhereInput
  }

  export type timeslotUpdateToOneWithWhereWithoutOrdersInput = {
    where?: timeslotWhereInput
    data: XOR<timeslotUpdateWithoutOrdersInput, timeslotUncheckedUpdateWithoutOrdersInput>
  }

  export type timeslotUpdateWithoutOrdersInput = {
    timeslotid?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lorrytrip?: lorrytripUpdateOneWithoutTimeslotNestedInput
  }

  export type timeslotUncheckedUpdateWithoutOrdersInput = {
    timeslotid?: StringFieldUpdateOperationsInput | string
    lorrytripid?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type orderproductCreateWithoutProductInput = {
    quantity?: number | null
    orders: ordersCreateNestedOneWithoutOrderproductInput
  }

  export type orderproductUncheckedCreateWithoutProductInput = {
    orderid: string
    quantity?: number | null
  }

  export type orderproductCreateOrConnectWithoutProductInput = {
    where: orderproductWhereUniqueInput
    create: XOR<orderproductCreateWithoutProductInput, orderproductUncheckedCreateWithoutProductInput>
  }

  export type orderproductCreateManyProductInputEnvelope = {
    data: orderproductCreateManyProductInput | orderproductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type orderproductUpsertWithWhereUniqueWithoutProductInput = {
    where: orderproductWhereUniqueInput
    update: XOR<orderproductUpdateWithoutProductInput, orderproductUncheckedUpdateWithoutProductInput>
    create: XOR<orderproductCreateWithoutProductInput, orderproductUncheckedCreateWithoutProductInput>
  }

  export type orderproductUpdateWithWhereUniqueWithoutProductInput = {
    where: orderproductWhereUniqueInput
    data: XOR<orderproductUpdateWithoutProductInput, orderproductUncheckedUpdateWithoutProductInput>
  }

  export type orderproductUpdateManyWithWhereWithoutProductInput = {
    where: orderproductScalarWhereInput
    data: XOR<orderproductUpdateManyMutationInput, orderproductUncheckedUpdateManyWithoutProductInput>
  }

  export type employeeteamassignmentCreateWithoutTeamInput = {
    employee: employeeCreateNestedOneWithoutEmployeeteamassignmentInput
  }

  export type employeeteamassignmentUncheckedCreateWithoutTeamInput = {
    employeeid: string
  }

  export type employeeteamassignmentCreateOrConnectWithoutTeamInput = {
    where: employeeteamassignmentWhereUniqueInput
    create: XOR<employeeteamassignmentCreateWithoutTeamInput, employeeteamassignmentUncheckedCreateWithoutTeamInput>
  }

  export type employeeteamassignmentCreateManyTeamInputEnvelope = {
    data: employeeteamassignmentCreateManyTeamInput | employeeteamassignmentCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type lorrytripCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput = {
    lorrytripid: string
    truck?: truckCreateNestedOneWithoutLorrytripInput
    team_lorrytrip_warehouseteamidToteam?: teamCreateNestedOneWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput
    timeslot?: timeslotCreateNestedManyWithoutLorrytripInput
  }

  export type lorrytripUncheckedCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput = {
    lorrytripid: string
    warehouseteamid?: string | null
    truckid?: string | null
    timeslot?: timeslotUncheckedCreateNestedManyWithoutLorrytripInput
  }

  export type lorrytripCreateOrConnectWithoutTeam_lorrytrip_deliveryteamidToteamInput = {
    where: lorrytripWhereUniqueInput
    create: XOR<lorrytripCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput, lorrytripUncheckedCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput>
  }

  export type lorrytripCreateManyTeam_lorrytrip_deliveryteamidToteamInputEnvelope = {
    data: lorrytripCreateManyTeam_lorrytrip_deliveryteamidToteamInput | lorrytripCreateManyTeam_lorrytrip_deliveryteamidToteamInput[]
    skipDuplicates?: boolean
  }

  export type lorrytripCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput = {
    lorrytripid: string
    team_lorrytrip_deliveryteamidToteam?: teamCreateNestedOneWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput
    truck?: truckCreateNestedOneWithoutLorrytripInput
    timeslot?: timeslotCreateNestedManyWithoutLorrytripInput
  }

  export type lorrytripUncheckedCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput = {
    lorrytripid: string
    deliveryteamid?: string | null
    truckid?: string | null
    timeslot?: timeslotUncheckedCreateNestedManyWithoutLorrytripInput
  }

  export type lorrytripCreateOrConnectWithoutTeam_lorrytrip_warehouseteamidToteamInput = {
    where: lorrytripWhereUniqueInput
    create: XOR<lorrytripCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput, lorrytripUncheckedCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput>
  }

  export type lorrytripCreateManyTeam_lorrytrip_warehouseteamidToteamInputEnvelope = {
    data: lorrytripCreateManyTeam_lorrytrip_warehouseteamidToteamInput | lorrytripCreateManyTeam_lorrytrip_warehouseteamidToteamInput[]
    skipDuplicates?: boolean
  }

  export type ordersCreateWithoutTeamInput = {
    orderid: string
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
    orderproduct?: orderproductCreateNestedManyWithoutOrdersInput
    building?: buildingCreateNestedOneWithoutOrdersInput
    customer?: customerCreateNestedOneWithoutOrdersInput
    employee?: employeeCreateNestedOneWithoutOrdersInput
    timeslot?: timeslotCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutTeamInput = {
    orderid: string
    customerid?: string | null
    employeeid?: string | null
    buildingid?: string | null
    timeslotid?: string | null
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
    orderproduct?: orderproductUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type ordersCreateOrConnectWithoutTeamInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutTeamInput, ordersUncheckedCreateWithoutTeamInput>
  }

  export type ordersCreateManyTeamInputEnvelope = {
    data: ordersCreateManyTeamInput | ordersCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type employeeteamassignmentUpsertWithWhereUniqueWithoutTeamInput = {
    where: employeeteamassignmentWhereUniqueInput
    update: XOR<employeeteamassignmentUpdateWithoutTeamInput, employeeteamassignmentUncheckedUpdateWithoutTeamInput>
    create: XOR<employeeteamassignmentCreateWithoutTeamInput, employeeteamassignmentUncheckedCreateWithoutTeamInput>
  }

  export type employeeteamassignmentUpdateWithWhereUniqueWithoutTeamInput = {
    where: employeeteamassignmentWhereUniqueInput
    data: XOR<employeeteamassignmentUpdateWithoutTeamInput, employeeteamassignmentUncheckedUpdateWithoutTeamInput>
  }

  export type employeeteamassignmentUpdateManyWithWhereWithoutTeamInput = {
    where: employeeteamassignmentScalarWhereInput
    data: XOR<employeeteamassignmentUpdateManyMutationInput, employeeteamassignmentUncheckedUpdateManyWithoutTeamInput>
  }

  export type lorrytripUpsertWithWhereUniqueWithoutTeam_lorrytrip_deliveryteamidToteamInput = {
    where: lorrytripWhereUniqueInput
    update: XOR<lorrytripUpdateWithoutTeam_lorrytrip_deliveryteamidToteamInput, lorrytripUncheckedUpdateWithoutTeam_lorrytrip_deliveryteamidToteamInput>
    create: XOR<lorrytripCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput, lorrytripUncheckedCreateWithoutTeam_lorrytrip_deliveryteamidToteamInput>
  }

  export type lorrytripUpdateWithWhereUniqueWithoutTeam_lorrytrip_deliveryteamidToteamInput = {
    where: lorrytripWhereUniqueInput
    data: XOR<lorrytripUpdateWithoutTeam_lorrytrip_deliveryteamidToteamInput, lorrytripUncheckedUpdateWithoutTeam_lorrytrip_deliveryteamidToteamInput>
  }

  export type lorrytripUpdateManyWithWhereWithoutTeam_lorrytrip_deliveryteamidToteamInput = {
    where: lorrytripScalarWhereInput
    data: XOR<lorrytripUpdateManyMutationInput, lorrytripUncheckedUpdateManyWithoutTeam_lorrytrip_deliveryteamidToteamInput>
  }

  export type lorrytripScalarWhereInput = {
    AND?: lorrytripScalarWhereInput | lorrytripScalarWhereInput[]
    OR?: lorrytripScalarWhereInput[]
    NOT?: lorrytripScalarWhereInput | lorrytripScalarWhereInput[]
    lorrytripid?: StringFilter<"lorrytrip"> | string
    deliveryteamid?: StringNullableFilter<"lorrytrip"> | string | null
    warehouseteamid?: StringNullableFilter<"lorrytrip"> | string | null
    truckid?: StringNullableFilter<"lorrytrip"> | string | null
  }

  export type lorrytripUpsertWithWhereUniqueWithoutTeam_lorrytrip_warehouseteamidToteamInput = {
    where: lorrytripWhereUniqueInput
    update: XOR<lorrytripUpdateWithoutTeam_lorrytrip_warehouseteamidToteamInput, lorrytripUncheckedUpdateWithoutTeam_lorrytrip_warehouseteamidToteamInput>
    create: XOR<lorrytripCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput, lorrytripUncheckedCreateWithoutTeam_lorrytrip_warehouseteamidToteamInput>
  }

  export type lorrytripUpdateWithWhereUniqueWithoutTeam_lorrytrip_warehouseteamidToteamInput = {
    where: lorrytripWhereUniqueInput
    data: XOR<lorrytripUpdateWithoutTeam_lorrytrip_warehouseteamidToteamInput, lorrytripUncheckedUpdateWithoutTeam_lorrytrip_warehouseteamidToteamInput>
  }

  export type lorrytripUpdateManyWithWhereWithoutTeam_lorrytrip_warehouseteamidToteamInput = {
    where: lorrytripScalarWhereInput
    data: XOR<lorrytripUpdateManyMutationInput, lorrytripUncheckedUpdateManyWithoutTeam_lorrytrip_warehouseteamidToteamInput>
  }

  export type ordersUpsertWithWhereUniqueWithoutTeamInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutTeamInput, ordersUncheckedUpdateWithoutTeamInput>
    create: XOR<ordersCreateWithoutTeamInput, ordersUncheckedCreateWithoutTeamInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutTeamInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutTeamInput, ordersUncheckedUpdateWithoutTeamInput>
  }

  export type ordersUpdateManyWithWhereWithoutTeamInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutTeamInput>
  }

  export type ordersCreateWithoutTimeslotInput = {
    orderid: string
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
    orderproduct?: orderproductCreateNestedManyWithoutOrdersInput
    building?: buildingCreateNestedOneWithoutOrdersInput
    customer?: customerCreateNestedOneWithoutOrdersInput
    team?: teamCreateNestedOneWithoutOrdersInput
    employee?: employeeCreateNestedOneWithoutOrdersInput
  }

  export type ordersUncheckedCreateWithoutTimeslotInput = {
    orderid: string
    customerid?: string | null
    employeeid?: string | null
    deliveryteamid?: string | null
    buildingid?: string | null
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
    orderproduct?: orderproductUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type ordersCreateOrConnectWithoutTimeslotInput = {
    where: ordersWhereUniqueInput
    create: XOR<ordersCreateWithoutTimeslotInput, ordersUncheckedCreateWithoutTimeslotInput>
  }

  export type ordersCreateManyTimeslotInputEnvelope = {
    data: ordersCreateManyTimeslotInput | ordersCreateManyTimeslotInput[]
    skipDuplicates?: boolean
  }

  export type lorrytripCreateWithoutTimeslotInput = {
    lorrytripid: string
    team_lorrytrip_deliveryteamidToteam?: teamCreateNestedOneWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput
    truck?: truckCreateNestedOneWithoutLorrytripInput
    team_lorrytrip_warehouseteamidToteam?: teamCreateNestedOneWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput
  }

  export type lorrytripUncheckedCreateWithoutTimeslotInput = {
    lorrytripid: string
    deliveryteamid?: string | null
    warehouseteamid?: string | null
    truckid?: string | null
  }

  export type lorrytripCreateOrConnectWithoutTimeslotInput = {
    where: lorrytripWhereUniqueInput
    create: XOR<lorrytripCreateWithoutTimeslotInput, lorrytripUncheckedCreateWithoutTimeslotInput>
  }

  export type ordersUpsertWithWhereUniqueWithoutTimeslotInput = {
    where: ordersWhereUniqueInput
    update: XOR<ordersUpdateWithoutTimeslotInput, ordersUncheckedUpdateWithoutTimeslotInput>
    create: XOR<ordersCreateWithoutTimeslotInput, ordersUncheckedCreateWithoutTimeslotInput>
  }

  export type ordersUpdateWithWhereUniqueWithoutTimeslotInput = {
    where: ordersWhereUniqueInput
    data: XOR<ordersUpdateWithoutTimeslotInput, ordersUncheckedUpdateWithoutTimeslotInput>
  }

  export type ordersUpdateManyWithWhereWithoutTimeslotInput = {
    where: ordersScalarWhereInput
    data: XOR<ordersUpdateManyMutationInput, ordersUncheckedUpdateManyWithoutTimeslotInput>
  }

  export type lorrytripUpsertWithoutTimeslotInput = {
    update: XOR<lorrytripUpdateWithoutTimeslotInput, lorrytripUncheckedUpdateWithoutTimeslotInput>
    create: XOR<lorrytripCreateWithoutTimeslotInput, lorrytripUncheckedCreateWithoutTimeslotInput>
    where?: lorrytripWhereInput
  }

  export type lorrytripUpdateToOneWithWhereWithoutTimeslotInput = {
    where?: lorrytripWhereInput
    data: XOR<lorrytripUpdateWithoutTimeslotInput, lorrytripUncheckedUpdateWithoutTimeslotInput>
  }

  export type lorrytripUpdateWithoutTimeslotInput = {
    lorrytripid?: StringFieldUpdateOperationsInput | string
    team_lorrytrip_deliveryteamidToteam?: teamUpdateOneWithoutLorrytrip_lorrytrip_deliveryteamidToteamNestedInput
    truck?: truckUpdateOneWithoutLorrytripNestedInput
    team_lorrytrip_warehouseteamidToteam?: teamUpdateOneWithoutLorrytrip_lorrytrip_warehouseteamidToteamNestedInput
  }

  export type lorrytripUncheckedUpdateWithoutTimeslotInput = {
    lorrytripid?: StringFieldUpdateOperationsInput | string
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseteamid?: NullableStringFieldUpdateOperationsInput | string | null
    truckid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lorrytripCreateWithoutTruckInput = {
    lorrytripid: string
    team_lorrytrip_deliveryteamidToteam?: teamCreateNestedOneWithoutLorrytrip_lorrytrip_deliveryteamidToteamInput
    team_lorrytrip_warehouseteamidToteam?: teamCreateNestedOneWithoutLorrytrip_lorrytrip_warehouseteamidToteamInput
    timeslot?: timeslotCreateNestedManyWithoutLorrytripInput
  }

  export type lorrytripUncheckedCreateWithoutTruckInput = {
    lorrytripid: string
    deliveryteamid?: string | null
    warehouseteamid?: string | null
    timeslot?: timeslotUncheckedCreateNestedManyWithoutLorrytripInput
  }

  export type lorrytripCreateOrConnectWithoutTruckInput = {
    where: lorrytripWhereUniqueInput
    create: XOR<lorrytripCreateWithoutTruckInput, lorrytripUncheckedCreateWithoutTruckInput>
  }

  export type lorrytripCreateManyTruckInputEnvelope = {
    data: lorrytripCreateManyTruckInput | lorrytripCreateManyTruckInput[]
    skipDuplicates?: boolean
  }

  export type truckzoneCreateWithoutTruckInput = {
    isprimaryzone?: boolean | null
    zone: zoneCreateNestedOneWithoutTruckzoneInput
  }

  export type truckzoneUncheckedCreateWithoutTruckInput = {
    zoneid: string
    isprimaryzone?: boolean | null
  }

  export type truckzoneCreateOrConnectWithoutTruckInput = {
    where: truckzoneWhereUniqueInput
    create: XOR<truckzoneCreateWithoutTruckInput, truckzoneUncheckedCreateWithoutTruckInput>
  }

  export type truckzoneCreateManyTruckInputEnvelope = {
    data: truckzoneCreateManyTruckInput | truckzoneCreateManyTruckInput[]
    skipDuplicates?: boolean
  }

  export type lorrytripUpsertWithWhereUniqueWithoutTruckInput = {
    where: lorrytripWhereUniqueInput
    update: XOR<lorrytripUpdateWithoutTruckInput, lorrytripUncheckedUpdateWithoutTruckInput>
    create: XOR<lorrytripCreateWithoutTruckInput, lorrytripUncheckedCreateWithoutTruckInput>
  }

  export type lorrytripUpdateWithWhereUniqueWithoutTruckInput = {
    where: lorrytripWhereUniqueInput
    data: XOR<lorrytripUpdateWithoutTruckInput, lorrytripUncheckedUpdateWithoutTruckInput>
  }

  export type lorrytripUpdateManyWithWhereWithoutTruckInput = {
    where: lorrytripScalarWhereInput
    data: XOR<lorrytripUpdateManyMutationInput, lorrytripUncheckedUpdateManyWithoutTruckInput>
  }

  export type truckzoneUpsertWithWhereUniqueWithoutTruckInput = {
    where: truckzoneWhereUniqueInput
    update: XOR<truckzoneUpdateWithoutTruckInput, truckzoneUncheckedUpdateWithoutTruckInput>
    create: XOR<truckzoneCreateWithoutTruckInput, truckzoneUncheckedCreateWithoutTruckInput>
  }

  export type truckzoneUpdateWithWhereUniqueWithoutTruckInput = {
    where: truckzoneWhereUniqueInput
    data: XOR<truckzoneUpdateWithoutTruckInput, truckzoneUncheckedUpdateWithoutTruckInput>
  }

  export type truckzoneUpdateManyWithWhereWithoutTruckInput = {
    where: truckzoneScalarWhereInput
    data: XOR<truckzoneUpdateManyMutationInput, truckzoneUncheckedUpdateManyWithoutTruckInput>
  }

  export type truckzoneScalarWhereInput = {
    AND?: truckzoneScalarWhereInput | truckzoneScalarWhereInput[]
    OR?: truckzoneScalarWhereInput[]
    NOT?: truckzoneScalarWhereInput | truckzoneScalarWhereInput[]
    truckid?: StringFilter<"truckzone"> | string
    zoneid?: StringFilter<"truckzone"> | string
    isprimaryzone?: BoolNullableFilter<"truckzone"> | boolean | null
  }

  export type truckCreateWithoutTruckzoneInput = {
    truckid: string
    carplate?: string | null
    tone?: number | null
    lengthcm?: number | null
    widthcm?: number | null
    heightcm?: number | null
    lorrytrip?: lorrytripCreateNestedManyWithoutTruckInput
  }

  export type truckUncheckedCreateWithoutTruckzoneInput = {
    truckid: string
    carplate?: string | null
    tone?: number | null
    lengthcm?: number | null
    widthcm?: number | null
    heightcm?: number | null
    lorrytrip?: lorrytripUncheckedCreateNestedManyWithoutTruckInput
  }

  export type truckCreateOrConnectWithoutTruckzoneInput = {
    where: truckWhereUniqueInput
    create: XOR<truckCreateWithoutTruckzoneInput, truckUncheckedCreateWithoutTruckzoneInput>
  }

  export type zoneCreateWithoutTruckzoneInput = {
    zoneid: string
    zonename?: string | null
    building?: buildingCreateNestedManyWithoutZoneInput
  }

  export type zoneUncheckedCreateWithoutTruckzoneInput = {
    zoneid: string
    zonename?: string | null
    building?: buildingUncheckedCreateNestedManyWithoutZoneInput
  }

  export type zoneCreateOrConnectWithoutTruckzoneInput = {
    where: zoneWhereUniqueInput
    create: XOR<zoneCreateWithoutTruckzoneInput, zoneUncheckedCreateWithoutTruckzoneInput>
  }

  export type truckUpsertWithoutTruckzoneInput = {
    update: XOR<truckUpdateWithoutTruckzoneInput, truckUncheckedUpdateWithoutTruckzoneInput>
    create: XOR<truckCreateWithoutTruckzoneInput, truckUncheckedCreateWithoutTruckzoneInput>
    where?: truckWhereInput
  }

  export type truckUpdateToOneWithWhereWithoutTruckzoneInput = {
    where?: truckWhereInput
    data: XOR<truckUpdateWithoutTruckzoneInput, truckUncheckedUpdateWithoutTruckzoneInput>
  }

  export type truckUpdateWithoutTruckzoneInput = {
    truckid?: StringFieldUpdateOperationsInput | string
    carplate?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: NullableIntFieldUpdateOperationsInput | number | null
    lengthcm?: NullableIntFieldUpdateOperationsInput | number | null
    widthcm?: NullableIntFieldUpdateOperationsInput | number | null
    heightcm?: NullableIntFieldUpdateOperationsInput | number | null
    lorrytrip?: lorrytripUpdateManyWithoutTruckNestedInput
  }

  export type truckUncheckedUpdateWithoutTruckzoneInput = {
    truckid?: StringFieldUpdateOperationsInput | string
    carplate?: NullableStringFieldUpdateOperationsInput | string | null
    tone?: NullableIntFieldUpdateOperationsInput | number | null
    lengthcm?: NullableIntFieldUpdateOperationsInput | number | null
    widthcm?: NullableIntFieldUpdateOperationsInput | number | null
    heightcm?: NullableIntFieldUpdateOperationsInput | number | null
    lorrytrip?: lorrytripUncheckedUpdateManyWithoutTruckNestedInput
  }

  export type zoneUpsertWithoutTruckzoneInput = {
    update: XOR<zoneUpdateWithoutTruckzoneInput, zoneUncheckedUpdateWithoutTruckzoneInput>
    create: XOR<zoneCreateWithoutTruckzoneInput, zoneUncheckedCreateWithoutTruckzoneInput>
    where?: zoneWhereInput
  }

  export type zoneUpdateToOneWithWhereWithoutTruckzoneInput = {
    where?: zoneWhereInput
    data: XOR<zoneUpdateWithoutTruckzoneInput, zoneUncheckedUpdateWithoutTruckzoneInput>
  }

  export type zoneUpdateWithoutTruckzoneInput = {
    zoneid?: StringFieldUpdateOperationsInput | string
    zonename?: NullableStringFieldUpdateOperationsInput | string | null
    building?: buildingUpdateManyWithoutZoneNestedInput
  }

  export type zoneUncheckedUpdateWithoutTruckzoneInput = {
    zoneid?: StringFieldUpdateOperationsInput | string
    zonename?: NullableStringFieldUpdateOperationsInput | string | null
    building?: buildingUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type buildingCreateWithoutZoneInput = {
    buildingid: string
    buildingname?: string | null
    housingtype?: string | null
    postalcode?: string | null
    vehiclesizelimit?: string | null
    vehiclelengthlimit?: Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: boolean | null
    liftavailable?: boolean | null
    stairsavailable?: boolean | null
    narrowdoorways?: boolean | null
    parkingdistance?: number | null
    preregistrationrequired?: boolean | null
    accesstimewindowstart?: Date | string | null
    accesstimewindowend?: Date | string | null
    notes?: string | null
    specialequipmentneeded?: string | null
    liftdimensions?: string | null
    orders?: ordersCreateNestedManyWithoutBuildingInput
  }

  export type buildingUncheckedCreateWithoutZoneInput = {
    buildingid: string
    buildingname?: string | null
    housingtype?: string | null
    postalcode?: string | null
    vehiclesizelimit?: string | null
    vehiclelengthlimit?: Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: boolean | null
    liftavailable?: boolean | null
    stairsavailable?: boolean | null
    narrowdoorways?: boolean | null
    parkingdistance?: number | null
    preregistrationrequired?: boolean | null
    accesstimewindowstart?: Date | string | null
    accesstimewindowend?: Date | string | null
    notes?: string | null
    specialequipmentneeded?: string | null
    liftdimensions?: string | null
    orders?: ordersUncheckedCreateNestedManyWithoutBuildingInput
  }

  export type buildingCreateOrConnectWithoutZoneInput = {
    where: buildingWhereUniqueInput
    create: XOR<buildingCreateWithoutZoneInput, buildingUncheckedCreateWithoutZoneInput>
  }

  export type buildingCreateManyZoneInputEnvelope = {
    data: buildingCreateManyZoneInput | buildingCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type truckzoneCreateWithoutZoneInput = {
    isprimaryzone?: boolean | null
    truck: truckCreateNestedOneWithoutTruckzoneInput
  }

  export type truckzoneUncheckedCreateWithoutZoneInput = {
    truckid: string
    isprimaryzone?: boolean | null
  }

  export type truckzoneCreateOrConnectWithoutZoneInput = {
    where: truckzoneWhereUniqueInput
    create: XOR<truckzoneCreateWithoutZoneInput, truckzoneUncheckedCreateWithoutZoneInput>
  }

  export type truckzoneCreateManyZoneInputEnvelope = {
    data: truckzoneCreateManyZoneInput | truckzoneCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type buildingUpsertWithWhereUniqueWithoutZoneInput = {
    where: buildingWhereUniqueInput
    update: XOR<buildingUpdateWithoutZoneInput, buildingUncheckedUpdateWithoutZoneInput>
    create: XOR<buildingCreateWithoutZoneInput, buildingUncheckedCreateWithoutZoneInput>
  }

  export type buildingUpdateWithWhereUniqueWithoutZoneInput = {
    where: buildingWhereUniqueInput
    data: XOR<buildingUpdateWithoutZoneInput, buildingUncheckedUpdateWithoutZoneInput>
  }

  export type buildingUpdateManyWithWhereWithoutZoneInput = {
    where: buildingScalarWhereInput
    data: XOR<buildingUpdateManyMutationInput, buildingUncheckedUpdateManyWithoutZoneInput>
  }

  export type buildingScalarWhereInput = {
    AND?: buildingScalarWhereInput | buildingScalarWhereInput[]
    OR?: buildingScalarWhereInput[]
    NOT?: buildingScalarWhereInput | buildingScalarWhereInput[]
    buildingid?: StringFilter<"building"> | string
    buildingname?: StringNullableFilter<"building"> | string | null
    housingtype?: StringNullableFilter<"building"> | string | null
    postalcode?: StringNullableFilter<"building"> | string | null
    zoneid?: StringNullableFilter<"building"> | string | null
    vehiclesizelimit?: StringNullableFilter<"building"> | string | null
    vehiclelengthlimit?: DecimalNullableFilter<"building"> | Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: DecimalNullableFilter<"building"> | Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: BoolNullableFilter<"building"> | boolean | null
    liftavailable?: BoolNullableFilter<"building"> | boolean | null
    stairsavailable?: BoolNullableFilter<"building"> | boolean | null
    narrowdoorways?: BoolNullableFilter<"building"> | boolean | null
    parkingdistance?: IntNullableFilter<"building"> | number | null
    preregistrationrequired?: BoolNullableFilter<"building"> | boolean | null
    accesstimewindowstart?: DateTimeNullableFilter<"building"> | Date | string | null
    accesstimewindowend?: DateTimeNullableFilter<"building"> | Date | string | null
    notes?: StringNullableFilter<"building"> | string | null
    specialequipmentneeded?: StringNullableFilter<"building"> | string | null
    liftdimensions?: StringNullableFilter<"building"> | string | null
  }

  export type truckzoneUpsertWithWhereUniqueWithoutZoneInput = {
    where: truckzoneWhereUniqueInput
    update: XOR<truckzoneUpdateWithoutZoneInput, truckzoneUncheckedUpdateWithoutZoneInput>
    create: XOR<truckzoneCreateWithoutZoneInput, truckzoneUncheckedCreateWithoutZoneInput>
  }

  export type truckzoneUpdateWithWhereUniqueWithoutZoneInput = {
    where: truckzoneWhereUniqueInput
    data: XOR<truckzoneUpdateWithoutZoneInput, truckzoneUncheckedUpdateWithoutZoneInput>
  }

  export type truckzoneUpdateManyWithWhereWithoutZoneInput = {
    where: truckzoneScalarWhereInput
    data: XOR<truckzoneUpdateManyMutationInput, truckzoneUncheckedUpdateManyWithoutZoneInput>
  }

  export type ordersCreateManyBuildingInput = {
    orderid: string
    customerid?: string | null
    employeeid?: string | null
    deliveryteamid?: string | null
    timeslotid?: string | null
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
  }

  export type ordersUpdateWithoutBuildingInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderproduct?: orderproductUpdateManyWithoutOrdersNestedInput
    customer?: customerUpdateOneWithoutOrdersNestedInput
    team?: teamUpdateOneWithoutOrdersNestedInput
    employee?: employeeUpdateOneWithoutOrdersNestedInput
    timeslot?: timeslotUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateWithoutBuildingInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    employeeid?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    timeslotid?: NullableStringFieldUpdateOperationsInput | string | null
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderproduct?: orderproductUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateManyWithoutBuildingInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    employeeid?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    timeslotid?: NullableStringFieldUpdateOperationsInput | string | null
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ordersCreateManyCustomerInput = {
    orderid: string
    employeeid?: string | null
    deliveryteamid?: string | null
    buildingid?: string | null
    timeslotid?: string | null
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
  }

  export type ordersUpdateWithoutCustomerInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderproduct?: orderproductUpdateManyWithoutOrdersNestedInput
    building?: buildingUpdateOneWithoutOrdersNestedInput
    team?: teamUpdateOneWithoutOrdersNestedInput
    employee?: employeeUpdateOneWithoutOrdersNestedInput
    timeslot?: timeslotUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateWithoutCustomerInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    employeeid?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    buildingid?: NullableStringFieldUpdateOperationsInput | string | null
    timeslotid?: NullableStringFieldUpdateOperationsInput | string | null
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderproduct?: orderproductUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateManyWithoutCustomerInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    employeeid?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    buildingid?: NullableStringFieldUpdateOperationsInput | string | null
    timeslotid?: NullableStringFieldUpdateOperationsInput | string | null
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type employeeteamassignmentCreateManyEmployeeInput = {
    teamid: string
  }

  export type ordersCreateManyEmployeeInput = {
    orderid: string
    customerid?: string | null
    deliveryteamid?: string | null
    buildingid?: string | null
    timeslotid?: string | null
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
  }

  export type employeeteamassignmentUpdateWithoutEmployeeInput = {
    team?: teamUpdateOneRequiredWithoutEmployeeteamassignmentNestedInput
  }

  export type employeeteamassignmentUncheckedUpdateWithoutEmployeeInput = {
    teamid?: StringFieldUpdateOperationsInput | string
  }

  export type employeeteamassignmentUncheckedUpdateManyWithoutEmployeeInput = {
    teamid?: StringFieldUpdateOperationsInput | string
  }

  export type ordersUpdateWithoutEmployeeInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderproduct?: orderproductUpdateManyWithoutOrdersNestedInput
    building?: buildingUpdateOneWithoutOrdersNestedInput
    customer?: customerUpdateOneWithoutOrdersNestedInput
    team?: teamUpdateOneWithoutOrdersNestedInput
    timeslot?: timeslotUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateWithoutEmployeeInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    buildingid?: NullableStringFieldUpdateOperationsInput | string | null
    timeslotid?: NullableStringFieldUpdateOperationsInput | string | null
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderproduct?: orderproductUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateManyWithoutEmployeeInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    buildingid?: NullableStringFieldUpdateOperationsInput | string | null
    timeslotid?: NullableStringFieldUpdateOperationsInput | string | null
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type timeslotCreateManyLorrytripInput = {
    timeslotid: string
    date?: Date | string | null
    timewindowstart?: Date | string | null
    timewindowend?: Date | string | null
    availableflag?: boolean | null
  }

  export type timeslotUpdateWithoutLorrytripInput = {
    timeslotid?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orders?: ordersUpdateManyWithoutTimeslotNestedInput
  }

  export type timeslotUncheckedUpdateWithoutLorrytripInput = {
    timeslotid?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
    orders?: ordersUncheckedUpdateManyWithoutTimeslotNestedInput
  }

  export type timeslotUncheckedUpdateManyWithoutLorrytripInput = {
    timeslotid?: StringFieldUpdateOperationsInput | string
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availableflag?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type orderproductCreateManyOrdersInput = {
    productid: string
    quantity?: number | null
  }

  export type orderproductUpdateWithoutOrdersInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    product?: productUpdateOneRequiredWithoutOrderproductNestedInput
  }

  export type orderproductUncheckedUpdateWithoutOrdersInput = {
    productid?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type orderproductUncheckedUpdateManyWithoutOrdersInput = {
    productid?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type orderproductCreateManyProductInput = {
    orderid: string
    quantity?: number | null
  }

  export type orderproductUpdateWithoutProductInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    orders?: ordersUpdateOneRequiredWithoutOrderproductNestedInput
  }

  export type orderproductUncheckedUpdateWithoutProductInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type orderproductUncheckedUpdateManyWithoutProductInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type employeeteamassignmentCreateManyTeamInput = {
    employeeid: string
  }

  export type lorrytripCreateManyTeam_lorrytrip_deliveryteamidToteamInput = {
    lorrytripid: string
    warehouseteamid?: string | null
    truckid?: string | null
  }

  export type lorrytripCreateManyTeam_lorrytrip_warehouseteamidToteamInput = {
    lorrytripid: string
    deliveryteamid?: string | null
    truckid?: string | null
  }

  export type ordersCreateManyTeamInput = {
    orderid: string
    customerid?: string | null
    employeeid?: string | null
    buildingid?: string | null
    timeslotid?: string | null
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
  }

  export type employeeteamassignmentUpdateWithoutTeamInput = {
    employee?: employeeUpdateOneRequiredWithoutEmployeeteamassignmentNestedInput
  }

  export type employeeteamassignmentUncheckedUpdateWithoutTeamInput = {
    employeeid?: StringFieldUpdateOperationsInput | string
  }

  export type employeeteamassignmentUncheckedUpdateManyWithoutTeamInput = {
    employeeid?: StringFieldUpdateOperationsInput | string
  }

  export type lorrytripUpdateWithoutTeam_lorrytrip_deliveryteamidToteamInput = {
    lorrytripid?: StringFieldUpdateOperationsInput | string
    truck?: truckUpdateOneWithoutLorrytripNestedInput
    team_lorrytrip_warehouseteamidToteam?: teamUpdateOneWithoutLorrytrip_lorrytrip_warehouseteamidToteamNestedInput
    timeslot?: timeslotUpdateManyWithoutLorrytripNestedInput
  }

  export type lorrytripUncheckedUpdateWithoutTeam_lorrytrip_deliveryteamidToteamInput = {
    lorrytripid?: StringFieldUpdateOperationsInput | string
    warehouseteamid?: NullableStringFieldUpdateOperationsInput | string | null
    truckid?: NullableStringFieldUpdateOperationsInput | string | null
    timeslot?: timeslotUncheckedUpdateManyWithoutLorrytripNestedInput
  }

  export type lorrytripUncheckedUpdateManyWithoutTeam_lorrytrip_deliveryteamidToteamInput = {
    lorrytripid?: StringFieldUpdateOperationsInput | string
    warehouseteamid?: NullableStringFieldUpdateOperationsInput | string | null
    truckid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type lorrytripUpdateWithoutTeam_lorrytrip_warehouseteamidToteamInput = {
    lorrytripid?: StringFieldUpdateOperationsInput | string
    team_lorrytrip_deliveryteamidToteam?: teamUpdateOneWithoutLorrytrip_lorrytrip_deliveryteamidToteamNestedInput
    truck?: truckUpdateOneWithoutLorrytripNestedInput
    timeslot?: timeslotUpdateManyWithoutLorrytripNestedInput
  }

  export type lorrytripUncheckedUpdateWithoutTeam_lorrytrip_warehouseteamidToteamInput = {
    lorrytripid?: StringFieldUpdateOperationsInput | string
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    truckid?: NullableStringFieldUpdateOperationsInput | string | null
    timeslot?: timeslotUncheckedUpdateManyWithoutLorrytripNestedInput
  }

  export type lorrytripUncheckedUpdateManyWithoutTeam_lorrytrip_warehouseteamidToteamInput = {
    lorrytripid?: StringFieldUpdateOperationsInput | string
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    truckid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ordersUpdateWithoutTeamInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderproduct?: orderproductUpdateManyWithoutOrdersNestedInput
    building?: buildingUpdateOneWithoutOrdersNestedInput
    customer?: customerUpdateOneWithoutOrdersNestedInput
    employee?: employeeUpdateOneWithoutOrdersNestedInput
    timeslot?: timeslotUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateWithoutTeamInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    employeeid?: NullableStringFieldUpdateOperationsInput | string | null
    buildingid?: NullableStringFieldUpdateOperationsInput | string | null
    timeslotid?: NullableStringFieldUpdateOperationsInput | string | null
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderproduct?: orderproductUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateManyWithoutTeamInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    employeeid?: NullableStringFieldUpdateOperationsInput | string | null
    buildingid?: NullableStringFieldUpdateOperationsInput | string | null
    timeslotid?: NullableStringFieldUpdateOperationsInput | string | null
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ordersCreateManyTimeslotInput = {
    orderid: string
    customerid?: string | null
    employeeid?: string | null
    deliveryteamid?: string | null
    buildingid?: string | null
    numberofattempts?: number | null
    scheduledstartdatetime?: Date | string | null
    scheduledenddatetime?: Date | string | null
    actualstartdatetime?: Date | string | null
    actualenddatetime?: Date | string | null
    actualarrivaldatetime?: Date | string | null
    customerrating?: Decimal | DecimalJsLike | number | string | null
    delayreason?: string | null
    customerfeedback?: string | null
    proofofdeliveryurl?: string | null
    orderstatus?: string | null
    updatedat?: Date | string | null
    createdat?: Date | string | null
  }

  export type ordersUpdateWithoutTimeslotInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderproduct?: orderproductUpdateManyWithoutOrdersNestedInput
    building?: buildingUpdateOneWithoutOrdersNestedInput
    customer?: customerUpdateOneWithoutOrdersNestedInput
    team?: teamUpdateOneWithoutOrdersNestedInput
    employee?: employeeUpdateOneWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateWithoutTimeslotInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    employeeid?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    buildingid?: NullableStringFieldUpdateOperationsInput | string | null
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    orderproduct?: orderproductUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type ordersUncheckedUpdateManyWithoutTimeslotInput = {
    orderid?: StringFieldUpdateOperationsInput | string
    customerid?: NullableStringFieldUpdateOperationsInput | string | null
    employeeid?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    buildingid?: NullableStringFieldUpdateOperationsInput | string | null
    numberofattempts?: NullableIntFieldUpdateOperationsInput | number | null
    scheduledstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualstartdatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualenddatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualarrivaldatetime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerrating?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delayreason?: NullableStringFieldUpdateOperationsInput | string | null
    customerfeedback?: NullableStringFieldUpdateOperationsInput | string | null
    proofofdeliveryurl?: NullableStringFieldUpdateOperationsInput | string | null
    orderstatus?: NullableStringFieldUpdateOperationsInput | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type lorrytripCreateManyTruckInput = {
    lorrytripid: string
    deliveryteamid?: string | null
    warehouseteamid?: string | null
  }

  export type truckzoneCreateManyTruckInput = {
    zoneid: string
    isprimaryzone?: boolean | null
  }

  export type lorrytripUpdateWithoutTruckInput = {
    lorrytripid?: StringFieldUpdateOperationsInput | string
    team_lorrytrip_deliveryteamidToteam?: teamUpdateOneWithoutLorrytrip_lorrytrip_deliveryteamidToteamNestedInput
    team_lorrytrip_warehouseteamidToteam?: teamUpdateOneWithoutLorrytrip_lorrytrip_warehouseteamidToteamNestedInput
    timeslot?: timeslotUpdateManyWithoutLorrytripNestedInput
  }

  export type lorrytripUncheckedUpdateWithoutTruckInput = {
    lorrytripid?: StringFieldUpdateOperationsInput | string
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseteamid?: NullableStringFieldUpdateOperationsInput | string | null
    timeslot?: timeslotUncheckedUpdateManyWithoutLorrytripNestedInput
  }

  export type lorrytripUncheckedUpdateManyWithoutTruckInput = {
    lorrytripid?: StringFieldUpdateOperationsInput | string
    deliveryteamid?: NullableStringFieldUpdateOperationsInput | string | null
    warehouseteamid?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type truckzoneUpdateWithoutTruckInput = {
    isprimaryzone?: NullableBoolFieldUpdateOperationsInput | boolean | null
    zone?: zoneUpdateOneRequiredWithoutTruckzoneNestedInput
  }

  export type truckzoneUncheckedUpdateWithoutTruckInput = {
    zoneid?: StringFieldUpdateOperationsInput | string
    isprimaryzone?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type truckzoneUncheckedUpdateManyWithoutTruckInput = {
    zoneid?: StringFieldUpdateOperationsInput | string
    isprimaryzone?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type buildingCreateManyZoneInput = {
    buildingid: string
    buildingname?: string | null
    housingtype?: string | null
    postalcode?: string | null
    vehiclesizelimit?: string | null
    vehiclelengthlimit?: Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: boolean | null
    liftavailable?: boolean | null
    stairsavailable?: boolean | null
    narrowdoorways?: boolean | null
    parkingdistance?: number | null
    preregistrationrequired?: boolean | null
    accesstimewindowstart?: Date | string | null
    accesstimewindowend?: Date | string | null
    notes?: string | null
    specialequipmentneeded?: string | null
    liftdimensions?: string | null
  }

  export type truckzoneCreateManyZoneInput = {
    truckid: string
    isprimaryzone?: boolean | null
  }

  export type buildingUpdateWithoutZoneInput = {
    buildingid?: StringFieldUpdateOperationsInput | string
    buildingname?: NullableStringFieldUpdateOperationsInput | string | null
    housingtype?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclesizelimit?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclelengthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liftavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stairsavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    narrowdoorways?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parkingdistance?: NullableIntFieldUpdateOperationsInput | number | null
    preregistrationrequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accesstimewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesstimewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specialequipmentneeded?: NullableStringFieldUpdateOperationsInput | string | null
    liftdimensions?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUpdateManyWithoutBuildingNestedInput
  }

  export type buildingUncheckedUpdateWithoutZoneInput = {
    buildingid?: StringFieldUpdateOperationsInput | string
    buildingname?: NullableStringFieldUpdateOperationsInput | string | null
    housingtype?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclesizelimit?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclelengthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liftavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stairsavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    narrowdoorways?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parkingdistance?: NullableIntFieldUpdateOperationsInput | number | null
    preregistrationrequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accesstimewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesstimewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specialequipmentneeded?: NullableStringFieldUpdateOperationsInput | string | null
    liftdimensions?: NullableStringFieldUpdateOperationsInput | string | null
    orders?: ordersUncheckedUpdateManyWithoutBuildingNestedInput
  }

  export type buildingUncheckedUpdateManyWithoutZoneInput = {
    buildingid?: StringFieldUpdateOperationsInput | string
    buildingname?: NullableStringFieldUpdateOperationsInput | string | null
    housingtype?: NullableStringFieldUpdateOperationsInput | string | null
    postalcode?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclesizelimit?: NullableStringFieldUpdateOperationsInput | string | null
    vehiclelengthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    vehiclewidthlimit?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    loadingbayavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    liftavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stairsavailable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    narrowdoorways?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parkingdistance?: NullableIntFieldUpdateOperationsInput | number | null
    preregistrationrequired?: NullableBoolFieldUpdateOperationsInput | boolean | null
    accesstimewindowstart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accesstimewindowend?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    specialequipmentneeded?: NullableStringFieldUpdateOperationsInput | string | null
    liftdimensions?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type truckzoneUpdateWithoutZoneInput = {
    isprimaryzone?: NullableBoolFieldUpdateOperationsInput | boolean | null
    truck?: truckUpdateOneRequiredWithoutTruckzoneNestedInput
  }

  export type truckzoneUncheckedUpdateWithoutZoneInput = {
    truckid?: StringFieldUpdateOperationsInput | string
    isprimaryzone?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type truckzoneUncheckedUpdateManyWithoutZoneInput = {
    truckid?: StringFieldUpdateOperationsInput | string
    isprimaryzone?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}